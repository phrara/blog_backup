{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/gallery/index/1.jpg","path":"gallery/index/1.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/10.jpg","path":"gallery/index/10.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/11.jpg","path":"gallery/index/11.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/2.jpg","path":"gallery/index/2.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/3.jpg","path":"gallery/index/3.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/5.jpg","path":"gallery/index/5.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/4.jpg","path":"gallery/index/4.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/6.jpg","path":"gallery/index/6.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/7.jpg","path":"gallery/index/7.jpg","modified":1,"renderable":0},{"_id":"source/gallery/index/8.png","path":"gallery/index/8.png","modified":1,"renderable":0},{"_id":"source/gallery/index/9.jpg","path":"gallery/index/9.jpg","modified":1,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/mouse.css","path":"css/mouse.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/universe.css","path":"css/universe.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c1.jpg","path":"img/c1.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c10.jpg","path":"img/c10.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c11.png","path":"img/c11.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c12.png","path":"img/c12.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c2.jpg","path":"img/c2.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c3.png","path":"img/c3.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c5.jpg","path":"img/c5.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c4.png","path":"img/c4.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c6.jpg","path":"img/c6.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c7.jpg","path":"img/c7.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c9.jpg","path":"img/c9.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/c8.jpg","path":"img/c8.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/cur.png","path":"img/cur.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/cur1.png","path":"img/cur1.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/curb.png","path":"img/curb.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/cur2.png","path":"img/cur2.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favi.png","path":"img/favi.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/mov.gif","path":"img/mov.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/sub.jpg","path":"img/sub.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/photo.jpg","path":"img/photo.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/top.jpg","path":"img/top.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/top1.jpg","path":"img/top1.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/universe.js","path":"js/universe.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/DGA域名.md","hash":"2f3e4b3db78a8f2faac49de538185beedc83b617","modified":1681461454375},{"_id":"source/_posts/Etcd-学习.md","hash":"1e3cec986018c2c5d2764f4cec6442c76b864864","modified":1662615671377},{"_id":"source/_posts/GFS-解读.md","hash":"8e7d438f13da7fae41d70984647918a86a2bc680","modified":1662882036295},{"_id":"source/_posts/Go-zero框架学习.md","hash":"8c67f0e5832fb96509fedc478900bdc492cf420b","modified":1662615619940},{"_id":"source/_posts/IPFS-Windows.md","hash":"72bc1a22d31bdb6996333fde54f65ce0cb863f32","modified":1665328806266},{"_id":"source/_posts/Go-OpenGL.md","hash":"05179364bfdf38d5080f025910cb15cf303cc24c","modified":1663255802631},{"_id":"source/_posts/K8s(1).md","hash":"b3463edc90b01aa4791702de44fa65cb60958410","modified":1680618228581},{"_id":"source/_posts/Raft算法.md","hash":"850b03ecc094e6b4092c24919c8cfb08e4a1cfbd","modified":1663308050531},{"_id":"source/_posts/conda安装jupyter.md","hash":"8ae9bfac0ceb769b3559bf52ab9bd7aadd4087f0","modified":1663746386382},{"_id":"source/_posts/docker学习.md","hash":"9c4e5a1064ce8c40e4e68966c1a42417877cf464","modified":1679023695045},{"_id":"source/categories/index.md","hash":"16932928629b8f54328f77653f4ba66a9183c1ce","modified":1662616286823},{"_id":"source/_posts/hello-world.md","hash":"372b7083163ddf84cc7fc3d116675c6810cc2715","modified":1662561134951},{"_id":"source/_posts/带状疱疹病史.md","hash":"0f65fde47a4e0e3c2ac2708052966ac401d6dde0","modified":1681461454377},{"_id":"source/_posts/汇编语言.md","hash":"3638976e1faf35bd519e708243baf2d4c25749b4","modified":1665631917441},{"_id":"source/music/index.md","hash":"ccbae7388510617e34a80165ef2039b0bd83215b","modified":1663260274577},{"_id":"source/gallery/index.md","hash":"723a962c7c9b871d6bb366479d2c3ea0b6f48d31","modified":1662622634000},{"_id":"source/tags/index.md","hash":"cd9fc6b90ffae56df32d6210437d1b834ad71425","modified":1662616224665},{"_id":"source/_posts/GFS-解读/cons.png","hash":"951b95c813ba0201a32734f816ca6cfe7ddc4e45","modified":1662865680448},{"_id":"source/_posts/GFS-解读/react.jpg","hash":"3aeb68a0ca029dcdd2394451a90ed5aa192a3425","modified":1662865146778},{"_id":"source/_posts/IPFS-Windows/zip.png","hash":"a1d54920e910168be250f1b72ef1b622829305db","modified":1665327434323},{"_id":"source/_posts/DGA域名/markov.png","hash":"d59cb319c4785a9428535cca0df0250fb24c847c","modified":1681461024388},{"_id":"source/_posts/K8s(1)/err0.png","hash":"51bbffe59449ff10bf0e4c01d9453cc155c95089","modified":1679929213782},{"_id":"source/_posts/K8s(1)/err2.png","hash":"4fbcbf99ad6b29c7d0647158bab58cfea542ffad","modified":1679933074687},{"_id":"source/_posts/K8s(1)/err1.png","hash":"17417da0aecc46470c5edb0d5e9131302593fdfe","modified":1679933071092},{"_id":"source/_posts/K8s(1)/err3.png","hash":"367f3f0b5602345b1ec2879a43c5acb324de4657","modified":1680363901377},{"_id":"source/_posts/K8s(1)/err4.png","hash":"298375ec9e5fbea5cf2fa64695207fe98fc2c56f","modified":1680363899079},{"_id":"source/_posts/K8s(1)/err5.png","hash":"ecb361a9535a4f2c33b5a7b1d00559d7b8f1b354","modified":1680363889126},{"_id":"source/_posts/K8s(1)/err6.png","hash":"6f213ab0bc12d2ff0e61c47d5aeeea8c7ae4048f","modified":1680363896236},{"_id":"source/_posts/K8s(1)/use1.png","hash":"55f052e225dd7adf7124a6f7bd538834023fa30d","modified":1680414413887},{"_id":"source/_posts/K8s(1)/use2.png","hash":"67b91dcd7e6215a499a1ce0d61630efffceff768","modified":1680414546882},{"_id":"source/_posts/K8s(1)/succ0.png","hash":"0302d1d295e3b56281e7182a965289ac910c56bc","modified":1680363904045},{"_id":"source/_posts/K8s(1)/use3.png","hash":"e2f9ee9b2e35570f2a7e03b961086d87b88ad157","modified":1680414638536},{"_id":"source/_posts/K8s(1)/use5.png","hash":"90a0e127e7ebd1aebba59b4b4badda7636c641b4","modified":1680415179871},{"_id":"source/_posts/Raft算法/role.jpg","hash":"9fa129f841b0c18d821628f039338bb0044f4334","modified":1663061793896},{"_id":"source/_posts/Raft算法/votin_fail.png","hash":"941edd1dac95139089d4d89a1a3b2625ffd2b10a","modified":1663122515760},{"_id":"source/_posts/Raft算法/voting.png","hash":"924792864ccd40d242268a99df5a5c7e6a6db781","modified":1663122381925},{"_id":"source/_posts/docker学习/2a9868ee4596ff49f1311f20178704f.png","hash":"8891eeec63773c72acb6e8e3ac286bf2a1531360","modified":1678789004813},{"_id":"source/_posts/docker学习/c5f7d7d0c8d5f55c6c637a68a704e9d.png","hash":"f6be0642a7fc0e106e50469bfa95500bf815493b","modified":1678789000966},{"_id":"source/_posts/Etcd-学习/architecture.png","hash":"baaf9e8db0bf3413640a6b001206624464cb8242","modified":1661604384535},{"_id":"source/_posts/GFS-解读/arch.jpg","hash":"5f8177c12a56089e78abb5472d9129f823447d6b","modified":1662779096854},{"_id":"source/_posts/DGA域名/C2DGA.png","hash":"e0157cf6b740007183b4fa240c586987279b4637","modified":1681315738385},{"_id":"source/_posts/DGA域名/orchard.png","hash":"4b2444356c5da184d9df2acf35e523fef3a1c9ce","modified":1681455978844},{"_id":"source/_posts/K8s(1)/use0.png","hash":"8f649429dd5a273eb437c6356f0b4b4a74ae4589","modified":1680414344617},{"_id":"source/_posts/K8s(1)/succ1.png","hash":"8a2f65b9ded69a408039aa66dd32c660fd6beaa6","modified":1680363908413},{"_id":"source/_posts/Raft算法/fm.png","hash":"c85fd2cdaa36a9e77f58e6cd41da98c73fdea8e5","modified":1663059930930},{"_id":"source/_posts/docker学习/dockerfile_cmd.png","hash":"faa3ab6aca4a1f4c0298557ffb45db796dba7ac2","modified":1678851598015},{"_id":"source/_posts/conda安装jupyter/1.png","hash":"bd1394ee02c63740ea123864f4e6493a11880d51","modified":1663745885262},{"_id":"source/_posts/docker学习/ufs.png","hash":"93528a5cd6d21ded6b94bf2487ed71efceb76b25","modified":1678806253138},{"_id":"source/_posts/K8s(1)/use4.png","hash":"d26790f07f4d0032aed38c5c0bb5c21da82f516f","modified":1680414778511},{"_id":"source/gallery/index/9.jpg","hash":"6e03576b0ac945397b35020202a3cc9b342de787","modified":1662622494754},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1662560558165},{"_id":"themes/butterfly/README.md","hash":"851d8e3e0ba8d9da305eb2f2ec63221296c04080","modified":1662560558166},{"_id":"themes/butterfly/README_CN.md","hash":"c03bd24e375f0f9bbc4238d0ee9bae7f4db2f032","modified":1662560558166},{"_id":"themes/butterfly/_config.yml","hash":"b1d580b2b8ddbbaf91a95c1d2342fa2a0e1f3d67","modified":1662560558166},{"_id":"themes/butterfly/package.json","hash":"fcf19a2e42a7684dc4cab3e9b28b5f893296dc3b","modified":1662560558189},{"_id":"themes/butterfly/plugins.yml","hash":"57ed4bc4e74dd8fcbdb330a35a0bd1a0fafebab1","modified":1662560558189},{"_id":"themes/butterfly/languages/default.yml","hash":"335731ef259a3cec2499a2d5b050025ff4bdc608","modified":1662560558166},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1662560558167},{"_id":"themes/butterfly/languages/en.yml","hash":"a96ab1bbe74e99ca2e4d67da9d83f442eb9b73af","modified":1662560558167},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1662560558167},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1662560558188},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1662560558188},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"4adf079fb0170e3a8de6ddbb0392d6d1120030c4","modified":1662560558167},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"dcb10d62249bb149af8ad78db3ee6e342c6d6be7","modified":1662560558167},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1662560558189},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1662560558189},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1662560558165},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1662560558164},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1662560558165},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"e1043b8f149371d5a4ab0f1306eabc2988bed071","modified":1662560558164},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1662560558165},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1662560558168},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1662560558168},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"ddea99847fd41323f183cd0c9dae3174c586f5b3","modified":1662560558168},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1d0f1b84be352862046e780800d696e80ef1cdd1","modified":1662560558168},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"3d95525a6d809be2f2a1cd6b33d3b7ecc0457d62","modified":1662560558172},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1662560558190},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"8e6f0677c190d44c64222054e2e7c065fc6c4802","modified":1662560558190},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"176332aa4d01728d0bd084e9b02c60167dc307dd","modified":1662560558190},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b3e05e3440b078f57391c113d6b0c8ecff112720","modified":1662560558190},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1662560558174},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"4f41fc46410e1e3018ff87e1d1a5c28be7258119","modified":1662560558175},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1662560558190},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"205562ec188bfba5686c51af77486550d0927df5","modified":1662560558174},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"b92cc4648cfe5fb28c58943727823d1178b73a4a","modified":1662560558190},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"6c3b7d0874fa499800a4fd49894c481b05ec750c","modified":1662560558191},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1662560558191},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1662560558192},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"c445140fa16f19bf5fb617fa735504e7799d4d42","modified":1662560558192},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"db4f5971c27f49a4cb47d34729f4ddf9919d392b","modified":1662560558192},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1662560558192},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c07efb04120914363b8de2c276ac5783b82db776","modified":1662560558193},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"83bfb16ab8d440be04e1b1f889f6affa7ad65a67","modified":1662560558193},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1662560558193},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1662560558193},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"6d4cd2393945a9316339351cab588265f5c18d73","modified":1662560558193},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1662560558194},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1662560558194},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1662560558205},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1662560558206},{"_id":"themes/butterfly/source/css/mouse.css","hash":"1adf92b0f3f73070f468ae8bc8e4b8c5a2dccd40","modified":1663138607918},{"_id":"themes/butterfly/source/css/var.styl","hash":"584ef7b18d5e677eb2e62f9b139097d3b714a993","modified":1662560558205},{"_id":"themes/butterfly/source/css/universe.css","hash":"7374d54c80015e2ae9ef699adfdc8b6cefb1059f","modified":1662603620104},{"_id":"themes/butterfly/source/img/cur.png","hash":"0af6c68da0c2d7243d61ae594c1e4d392f57bc1e","modified":1662702164061},{"_id":"themes/butterfly/source/img/cur1.png","hash":"7955e68b626b64843ae9735af9c00a5cb8d9c50f","modified":1662702293517},{"_id":"themes/butterfly/source/img/curb.png","hash":"4843509ec823eadbfa4f29bb5bceeaf367289b28","modified":1663139388664},{"_id":"themes/butterfly/source/img/cur2.png","hash":"ba50bc252a412484aeb67d26024cd614917d432c","modified":1662704611006},{"_id":"themes/butterfly/source/img/favi.png","hash":"46f98417bc35385401a9ede3bf3907b403979e8a","modified":1662623339452},{"_id":"themes/butterfly/source/img/favicon.png","hash":"46f98417bc35385401a9ede3bf3907b403979e8a","modified":1662622939850},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1662560558206},{"_id":"themes/butterfly/source/img/photo.jpg","hash":"cb0b442e6062b3b00ce37b04cb0d08cb84bfc6a1","modified":1662991279408},{"_id":"themes/butterfly/source/js/main.js","hash":"0b673b89d24b78b8544cc0e048953e6dcba3e9bf","modified":1662560558207},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1662560558169},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1662560558208},{"_id":"themes/butterfly/source/js/utils.js","hash":"fdb9e5b38f076953a2431b8f682388b030694b55","modified":1662560558208},{"_id":"themes/butterfly/source/js/universe.js","hash":"7e0a822110964ba8cc8816c3cabc0a5f5c134d39","modified":1662603553226},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1662560558169},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"8a3f9e674b44e6a92d4df22baca65d9d30007dc3","modified":1662560558169},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1662560558169},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1662560558170},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1662560558170},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"6f489b24f06578440f18b629db56c810f00f8c3f","modified":1662560558171},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"a9e56b1c41bf327859b0a7bcb8e72b458bd851b2","modified":1662560558171},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1662560558171},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1662560558171},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1662560558172},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1662560558172},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1662560558170},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1662560558172},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1662560558170},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1662560558172},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"8b8e04d3d9462b3790ba17e5a865dab5a4740a73","modified":1662560558173},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1662560558173},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fc3e67e5ae4774d9e89964ba96beed28f34ee8f0","modified":1662560558170},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1662560558174},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1662560558173},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e2eba0fcb8332cb333b2aff9c76664e40e2e1974","modified":1662560558173},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"8f43fdeaf8cff4a35bab74b48c963786ca015620","modified":1662560558174},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1662560558174},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1662560558175},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1662560558181},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"4e026840c915327e45331e63e4b7ef287e871204","modified":1662560558184},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1662560558184},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1662560558184},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d561d36229692e2c8a9ee45a7c24c0c2b3599170","modified":1662560558186},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1662560558186},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1662603176710},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"08641633d38903351a7424baf9893d9038ba057d","modified":1662560558186},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1662560558187},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1662560558186},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"c02b1779bd0ebca6749f195be096b6ca574bfa29","modified":1662560558187},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1662560558187},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1662560558187},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1662560558187},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1662560558188},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1662560558188},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f562648de515abc873609bfe9b9f799c8cf42b72","modified":1662560558195},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"5e0e9e9b2cd3c256d52423e2278e790aa387a53a","modified":1662560558188},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1662560558188},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"b9d7d23dc8810542b8c8ffcbfbd3694318debcc6","modified":1662560558195},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"a2aa5caf338ff5323b6ff0601ebcc09e710d8398","modified":1662560558195},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1662560558197},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"af6e3357b8f6df18d0775b8352551c0f8ce38e55","modified":1662560558197},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1662560558197},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1662560558198},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e931ef81754a7b9d999fa23d134c620e68e75491","modified":1662560558199},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"612d2f8a53141b353078f2a3405d8d44a79d9558","modified":1662560558199},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"844858ae87c7278996ce484c6b456db354c48764","modified":1662560558199},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1662560558199},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"9f880a6fa91784a4d3e9ffb0d4607e8a74d4d929","modified":1662560558199},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1662560558200},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1662560558200},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1662560558200},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1662560558201},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"d72218cb5a6bfe048ae1c92009bd815a08a53d3a","modified":1662560558202},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"1c1c585ba99cb4004956b5e98fc044260b456f99","modified":1662560558200},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1662560558202},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"e02b52bdd337c0ed3c9d3a507d1011403c38881d","modified":1662560558200},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a714776e3d585369f2285b6bb4e1564539c58d8b","modified":1662560558202},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"5dabc3a5330cc28f0666d1cd8db0d67f553fd854","modified":1662560558201},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"1fed25162d7204480e9bcf476b3246e1717107ca","modified":1662560558201},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1662560558203},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1662560558202},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"6d2a841c7656fb28b1e15afe1d7dda56c424b7d7","modified":1662560558202},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"45792c13c7c439d412b7dc597d74d24f3b598406","modified":1662560558203},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"d1398399eb7f1cc004fbcefa18f56188cc8fec8c","modified":1662560558203},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"cced94e70b4b90130cfa215582be2adbf883efba","modified":1662560558203},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"84c42716e833d2d1dd47195ea996803ffa0e58ec","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1662560558204},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1662560558205},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1662560558204},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1662560558204},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"d0d60008ef4ff74298ff062878766f194a2e4a70","modified":1662560558207},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"f72e002d56903a49c36174e77e42f88b8af8bd44","modified":1662560558207},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"645087801624a73cbee63269cfd399e9da39c663","modified":1662560558175},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1662560558175},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"dfbec0a99e38ebeac46931121b3a70b9a1e34b79","modified":1662560558175},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1662560558176},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"38b85d216d9377ddbaa2e5867e2f03805227237c","modified":1662560558176},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1662560558176},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1662560558176},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"6e5ccc9ea4346c71ad4cbf1e9f1cb83bb45e6f27","modified":1662560558176},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1662560558177},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1662560558177},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1662560558177},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1662560558177},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"a5ddcf84ce8855c7801289270009e29c3a103150","modified":1662560558177},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e657b87b721b6ef9149686630a205f4ebb7f2716","modified":1662560558178},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1662560558178},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"55f7c144e4ef7a7f317bcdab8044fd8f89bdd5d9","modified":1662560558178},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"3b551ab7618b36795480015b5cf565288df5b957","modified":1662560558178},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"8c16214a610ff8087628f32d005a1b0aab3bb910","modified":1662560558178},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c83f37e9618fbc03ecab25db54f14dbbf9e7ce10","modified":1662560558179},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"319463fc8ff993b798f2293b659b522ad7770cf0","modified":1662560558179},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"3df2f59c9552a1f2e6f0d50c4ae97e72c5392b59","modified":1662560558179},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"5b44b4e5f2445260811de81edd3eeeb97d8bb583","modified":1662560558179},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f04263a3bd7efb7f1b250cfee112e82f49805492","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"d48d59ebf8c0142fb3c4592a0d35874f85e6fd4c","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"ccb5c3f2a821b87986998595743387d7c997c16e","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1662560558181},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"e45152e4ebc3fb2462916be93f98d18f0574f2d3","modified":1662560558181},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1662560558180},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1662560558181},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"77ac27a24b8347668c4df9d5c44c9461c69eaec9","modified":1662560558182},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"056756e43908519039b8bbd7a90f8c49d561eb52","modified":1662560558182},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"297d34d83e7bff8ec3b8bc19bb0f4d901c35fe5a","modified":1662560558182},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b2ede1f6b41026ebd233ac076a405889a6eec76b","modified":1662560558182},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"cd1ce86441dc508e4c3dbf8b829046455ba8a6b4","modified":1662560558182},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1662560558183},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"bc207dcb771fc2c2c329f29d01708ff6b18443da","modified":1662560558183},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"af5d3d87b736598dafcf5871863596592cacdfe1","modified":1662560558184},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"33368c0b80e4c4e78f3c7ee9bec0fed70ad838ca","modified":1662560558183},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"91a72e94743befa21a7b1c557fbb3751efb87ab0","modified":1662560558183},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"63ef0b2a75cf26a94c5bcd885f3a1c144451b852","modified":1662560558183},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1662560558184},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"3b5ef84744a1a8fec5a63554079008040d96f924","modified":1662560558185},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1662560558185},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1662560558185},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1662560558185},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1662560558196},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"b45fc15c3ae7db3a0fbce0d6da74a72a95ca8a2b","modified":1662560558185},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1662560558196},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1662560558196},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1662560558196},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1662560558197},{"_id":"source/gallery/index/7.jpg","hash":"48342afdf9822c598af60c3cd8c93d382dee93b7","modified":1662620743463},{"_id":"themes/butterfly/source/img/c9.jpg","hash":"799830518b1be36be6adf3d112268ad7201e84a7","modified":1662623023943},{"_id":"source/gallery/index/6.jpg","hash":"649e14a8e235f5cf542f49582c5a6735146a1666","modified":1662620639659},{"_id":"source/gallery/index/1.jpg","hash":"2adfe132d145a91e7ffffbe81b30460c715ac47f","modified":1662620195928},{"_id":"themes/butterfly/source/img/top.jpg","hash":"e68a2a41d74b237a9f309a3658b9eb83d3372e6c","modified":1662625352394},{"_id":"source/gallery/index/3.jpg","hash":"1dcecfa65c8d0345c8f5b3bc76a9a5f61614bd6f","modified":1662620575902},{"_id":"source/gallery/index/2.jpg","hash":"76890e4de5f386bd1a5d98cb06d8916777509e76","modified":1662620525878},{"_id":"source/gallery/index/5.jpg","hash":"14a0fe19126e40ed50e9697239bb621586196c8d","modified":1662620651484},{"_id":"source/gallery/index/4.jpg","hash":"437a9547c01f218adb01c8173477367e80f9a77b","modified":1662620614485},{"_id":"source/gallery/index/11.jpg","hash":"d277c50560a0470966da87aded1dcf865f08fbad","modified":1662622543135},{"_id":"themes/butterfly/source/img/c6.jpg","hash":"e5620f672399e032d227f2fcbee85f49a100e731","modified":1662613688038},{"_id":"themes/butterfly/source/img/sub.jpg","hash":"102f267ff7ad8b760ba75855517151b684c060f2","modified":1662616716133},{"_id":"themes/butterfly/source/img/c5.jpg","hash":"c74f49fc971661094bf340d168998339fe65b2e9","modified":1662613662173},{"_id":"themes/butterfly/source/img/c8.jpg","hash":"56a6c7562c0c6d959d0b22a32a8271b9ccb6fe07","modified":1662614013164},{"_id":"source/gallery/index/8.png","hash":"e1e1ffef7a17ffe286a99cd2ff9c82d9a6ea3d5f","modified":1662621499813},{"_id":"themes/butterfly/source/img/c10.jpg","hash":"93119e91bc7506a271357a8cb08d8b2de3f9604b","modified":1662614058710},{"_id":"themes/butterfly/source/img/top1.jpg","hash":"0d23e97bd120b10eb2df53b1da30cb211b7f19e1","modified":1662646593777},{"_id":"themes/butterfly/source/img/c7.jpg","hash":"a75329c04072e58808c6ec0cafa896f51d531d77","modified":1662614079542},{"_id":"themes/butterfly/source/img/c4.png","hash":"a6cb944e925084b5eeb6115074ea1dbffd7380ed","modified":1643259988962},{"_id":"themes/butterfly/source/img/mov.gif","hash":"9537ebb16c9a1467b709c46481f3668a96af7cb2","modified":1663261407323},{"_id":"source/gallery/index/10.jpg","hash":"c3a0ae4ed1a5b2eaa9c514f9d1654afd9af98de6","modified":1662622514737},{"_id":"themes/butterfly/source/img/c11.png","hash":"3ad85e2fa37717d3fef383f53bc9277ada73286f","modified":1663384193625},{"_id":"themes/butterfly/source/img/c12.png","hash":"f91d28acad48e4aafeb25057922ea3f66bbdf9ce","modified":1663384296157},{"_id":"themes/butterfly/source/img/c2.jpg","hash":"d3e7ee314156e459759cef9206b63c94be7036c9","modified":1662380228101},{"_id":"themes/butterfly/source/img/c1.jpg","hash":"f080d002873cf9859f472799b34b65a5a9e87828","modified":1661174400916},{"_id":"themes/butterfly/source/img/c3.png","hash":"9c612ed297d5feaa16080169c25f0d4da0240674","modified":1663384089239},{"_id":"public/categories/index.html","hash":"fde2308e760ddb305ad515f4934cbe56f308bbf3","modified":1681463713314},{"_id":"public/music/index.html","hash":"02e39ccf91194353d70700bd7eda9974c1807223","modified":1681463713314},{"_id":"public/gallery/index.html","hash":"ad31af45acf7e3bb262bc3cad373fa423fab78ce","modified":1681463713314},{"_id":"public/tags/index.html","hash":"9cb59c2ec7cbdbb127f69d656edb4ad5fa2f2f74","modified":1681463713314},{"_id":"public/post/19ce5f52/index.html","hash":"25c9119910db78d7d9a8b1c3499e0524c4f88523","modified":1681463713314},{"_id":"public/post/9c057035/index.html","hash":"ccbdfbdcd7358b0227ea2d11e7704aa69037124f","modified":1681463713314},{"_id":"public/post/7fb3659b/index.html","hash":"d799568796d1a6d1ff704e13708c6c151ac17794","modified":1681463713314},{"_id":"public/post/8e372fbf/index.html","hash":"0f2d71a41fafe1d11dcbd042a9e7d9db19cbad94","modified":1681463713314},{"_id":"public/post/3e9a9d51/index.html","hash":"4a5e70f74b85f506021a5fa23bbb2a3ca3170e01","modified":1681463713314},{"_id":"public/post/bdcd1c7d/index.html","hash":"f5f4b432d84463a6c627a3ff86d8a066a73168fe","modified":1681463713314},{"_id":"public/post/7264fd3f/index.html","hash":"89febd0079663220e889762ca060f16cb2fdb111","modified":1681463713314},{"_id":"public/post/f2b485e3/index.html","hash":"cef9212ab11ad439453696280d40b3275d16e0da","modified":1681463713314},{"_id":"public/post/1df31392/index.html","hash":"ec272e2ecb7148c5bbc04b3c044c3ef6f285c3ec","modified":1681463713314},{"_id":"public/post/8e41db39/index.html","hash":"16194d3610f6d36d07e06c1e73dd862851ef7078","modified":1681463713314},{"_id":"public/post/26cc52b5/index.html","hash":"18b2342d625c8916667727b190cd2145a0993394","modified":1681463713314},{"_id":"public/archives/index.html","hash":"8f2953d0a39f01ced346eeb5464ef5eb95ff2b9d","modified":1681463713314},{"_id":"public/post/0/index.html","hash":"0fb718ff426fd24b90cdbd156bb8cbcd65478c20","modified":1681463713314},{"_id":"public/post/4a17b156/index.html","hash":"d53d2c03096d9988e43643efa4d7a0afa007131d","modified":1681463713314},{"_id":"public/archives/page/2/index.html","hash":"2e3ab8d3b4a8b7ee5771b8eab9f04972dcab776a","modified":1681463713314},{"_id":"public/archives/2022/index.html","hash":"4866ae6f96fb49e74aba86bdfd1400cc9fd21c84","modified":1681463713314},{"_id":"public/archives/2022/09/index.html","hash":"fbcd2b795bda510c2e2ba57114b1e53e92e05e4c","modified":1681463713314},{"_id":"public/archives/2022/10/index.html","hash":"3ef957c29920a477584579266b9c47bf3fe84d27","modified":1681463713314},{"_id":"public/archives/2023/index.html","hash":"c8b98986a84679b79d80b2b7b63faf1d3677cfb4","modified":1681463713314},{"_id":"public/archives/2023/03/index.html","hash":"d7f88c006d73b6aed58210ba97561d787898d5e2","modified":1681463713314},{"_id":"public/categories/security/index.html","hash":"2d4eda0b2787365b6ff0bb80d49d31237e69bc88","modified":1681463713314},{"_id":"public/archives/2023/04/index.html","hash":"9730029f6f409f66939ccfcca56495e23ac07d0f","modified":1681463713314},{"_id":"public/categories/微服务/index.html","hash":"b71eec2a4c36b4dfe33bdb488d3d02ebaf3e4e72","modified":1681463713314},{"_id":"public/categories/MIT-6-824/index.html","hash":"f02d2048b1ec7276c480051c85f4b30d5522f1df","modified":1681463713314},{"_id":"public/categories/图形学/index.html","hash":"be327582751b7036671aec2eedacea3f91097963","modified":1681463713314},{"_id":"public/categories/大创/index.html","hash":"13704965bcf830de51e5be19f8786726f1307e87","modified":1681463713314},{"_id":"public/categories/微服务/分布式/index.html","hash":"a5c259501ec4a8f58b69451c724c8a888383376a","modified":1681463713314},{"_id":"public/categories/云计算/index.html","hash":"87d8e061d24280bbf45d67edcdbeed9fd28f8d72","modified":1681463713314},{"_id":"public/categories/微服务/RPC/index.html","hash":"5b682258ad3b5189b0e7b6e3e51ab9f2c281b80b","modified":1681463713314},{"_id":"public/categories/DL/index.html","hash":"ce424a595f2017cb889e33efda56f6256ec42b30","modified":1681463713314},{"_id":"public/categories/大创/区块链/index.html","hash":"7156df9b4204375c4bec469e87e03a8d07c86bba","modified":1681463713314},{"_id":"public/categories/云计算/K8s/index.html","hash":"6c4268cdd87e002319f03e8fae2359ffc0a9edec","modified":1681463713314},{"_id":"public/categories/life/index.html","hash":"11adc1a996e7f8c376f0651b18a6c608b0774a01","modified":1681463713314},{"_id":"public/categories/计算机底层/index.html","hash":"4c06218ae1ee2e1bab73e9df64d0f93b0830e753","modified":1681463713314},{"_id":"public/page/2/index.html","hash":"18be1b474ca044ea94fcbc0c8cd34c99ac5474fb","modified":1681463713314},{"_id":"public/tags/DGA/index.html","hash":"2785e2e4c0e3b44d646dd585c118e79d52f917a8","modified":1681463713314},{"_id":"public/tags/微服务/index.html","hash":"83a682f8fb9c5baf119f8d36cf26ce556eb04e33","modified":1681463713314},{"_id":"public/index.html","hash":"369b4cebe8bcc5396be373fb2a018b19c7f801f3","modified":1681463713314},{"_id":"public/tags/分布式/index.html","hash":"b856d0d6e593888f305359b8af78e692d315deec","modified":1681463713314},{"_id":"public/tags/Raft/index.html","hash":"516824cafcda24aef67b55b4126d0e35013e54a3","modified":1681463713314},{"_id":"public/tags/存储/index.html","hash":"3c71b373ee50ab4dabc2136e9a61bb17dad6e9f5","modified":1681463713314},{"_id":"public/tags/文件系统/index.html","hash":"429729bcee7b629638f8ff8af6fdabde76520fd2","modified":1681463713314},{"_id":"public/tags/web/index.html","hash":"0a57803635f36633d45513616b10302b1faf018e","modified":1681463713314},{"_id":"public/tags/RPC/index.html","hash":"bf0d3cebb7a22761a64d9a64b1c86acad6378a69","modified":1681463713314},{"_id":"public/tags/OpenGL/index.html","hash":"6cba5518e5df119e5236e898c6613998c4d72ef8","modified":1681463713314},{"_id":"public/tags/图形学/index.html","hash":"0965c46312fe818df656fa36603c652da5a45043","modified":1681463713314},{"_id":"public/tags/Decentralization/index.html","hash":"626ba634f6b02dca3ba5826905ff131713f44070","modified":1681463713314},{"_id":"public/tags/区块链/index.html","hash":"e9be8ce05033a35c5b333469bdf48cc8a0a01aba","modified":1681463713314},{"_id":"public/tags/P2P/index.html","hash":"33167cbf9bf73212da001dcddc7b8b2b8b6ebb39","modified":1681463713314},{"_id":"public/tags/容器/index.html","hash":"a3d5a13a2a87b81307b812a1c58440d1399d27c2","modified":1681463713314},{"_id":"public/tags/docker/index.html","hash":"5aec6efd300ecfb66a13b5516c33047aa4a72fd3","modified":1681463713314},{"_id":"public/tags/共识算法-consensus/index.html","hash":"3ea5c17224bde615eadb87a51149d9a9b8547c94","modified":1681463713314},{"_id":"public/tags/jupyter-notebook/index.html","hash":"3716067624d7302fd65281c6d14538f18fb6aa7f","modified":1681463713314},{"_id":"public/tags/life/index.html","hash":"cfa643642833d146a4d4210dfdf9b8415df88183","modified":1681463713314},{"_id":"public/tags/汇编语言/index.html","hash":"a2a77f3ee96bed09ae85e06fcab56984db2be0d3","modified":1681463713314},{"_id":"public/css/mouse.css","hash":"5428454d104a4bba9dbc2fe5c5346ca4e0404bc2","modified":1681463713314},{"_id":"public/css/universe.css","hash":"b296f879cdef4d77f1cb8df9860065bdb5543884","modified":1681463713314},{"_id":"public/css/index.css","hash":"48035eb0c84327b33e31774d5938d2513d4931d0","modified":1681463713314},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1681463713314},{"_id":"public/img/curb.png","hash":"4843509ec823eadbfa4f29bb5bceeaf367289b28","modified":1681463713314},{"_id":"public/img/cur.png","hash":"0af6c68da0c2d7243d61ae594c1e4d392f57bc1e","modified":1681463713314},{"_id":"public/img/cur1.png","hash":"7955e68b626b64843ae9735af9c00a5cb8d9c50f","modified":1681463713314},{"_id":"public/img/cur2.png","hash":"ba50bc252a412484aeb67d26024cd614917d432c","modified":1681463713314},{"_id":"public/img/favicon.png","hash":"46f98417bc35385401a9ede3bf3907b403979e8a","modified":1681463713314},{"_id":"public/img/favi.png","hash":"46f98417bc35385401a9ede3bf3907b403979e8a","modified":1681463713314},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1681463713314},{"_id":"public/img/photo.jpg","hash":"cb0b442e6062b3b00ce37b04cb0d08cb84bfc6a1","modified":1681463713314},{"_id":"public/post/19ce5f52/markov.png","hash":"d59cb319c4785a9428535cca0df0250fb24c847c","modified":1681463713314},{"_id":"public/post/f2b485e3/cons.png","hash":"951b95c813ba0201a32734f816ca6cfe7ddc4e45","modified":1681463713314},{"_id":"public/post/f2b485e3/react.jpg","hash":"3aeb68a0ca029dcdd2394451a90ed5aa192a3425","modified":1681463713314},{"_id":"public/post/8e372fbf/err0.png","hash":"51bbffe59449ff10bf0e4c01d9453cc155c95089","modified":1681463713314},{"_id":"public/post/3e9a9d51/zip.png","hash":"a1d54920e910168be250f1b72ef1b622829305db","modified":1681463713314},{"_id":"public/post/8e372fbf/err1.png","hash":"17417da0aecc46470c5edb0d5e9131302593fdfe","modified":1681463713314},{"_id":"public/post/8e372fbf/err2.png","hash":"4fbcbf99ad6b29c7d0647158bab58cfea542ffad","modified":1681463713314},{"_id":"public/post/8e372fbf/err3.png","hash":"367f3f0b5602345b1ec2879a43c5acb324de4657","modified":1681463713314},{"_id":"public/post/8e372fbf/err4.png","hash":"298375ec9e5fbea5cf2fa64695207fe98fc2c56f","modified":1681463713314},{"_id":"public/post/8e372fbf/err5.png","hash":"ecb361a9535a4f2c33b5a7b1d00559d7b8f1b354","modified":1681463713314},{"_id":"public/post/8e372fbf/err6.png","hash":"6f213ab0bc12d2ff0e61c47d5aeeea8c7ae4048f","modified":1681463713314},{"_id":"public/post/8e372fbf/succ0.png","hash":"0302d1d295e3b56281e7182a965289ac910c56bc","modified":1681463713314},{"_id":"public/post/8e372fbf/use1.png","hash":"55f052e225dd7adf7124a6f7bd538834023fa30d","modified":1681463713314},{"_id":"public/post/8e372fbf/use2.png","hash":"67b91dcd7e6215a499a1ce0d61630efffceff768","modified":1681463713314},{"_id":"public/post/8e372fbf/use3.png","hash":"e2f9ee9b2e35570f2a7e03b961086d87b88ad157","modified":1681463713314},{"_id":"public/post/8e372fbf/use5.png","hash":"90a0e127e7ebd1aebba59b4b4badda7636c641b4","modified":1681463713314},{"_id":"public/post/1df31392/role.jpg","hash":"9fa129f841b0c18d821628f039338bb0044f4334","modified":1681463713314},{"_id":"public/post/1df31392/voting.png","hash":"924792864ccd40d242268a99df5a5c7e6a6db781","modified":1681463713314},{"_id":"public/post/7fb3659b/2a9868ee4596ff49f1311f20178704f.png","hash":"8891eeec63773c72acb6e8e3ac286bf2a1531360","modified":1681463713314},{"_id":"public/post/1df31392/votin_fail.png","hash":"941edd1dac95139089d4d89a1a3b2625ffd2b10a","modified":1681463713314},{"_id":"public/post/7fb3659b/c5f7d7d0c8d5f55c6c637a68a704e9d.png","hash":"f6be0642a7fc0e106e50469bfa95500bf815493b","modified":1681463713314},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681463713314},{"_id":"public/js/universe.js","hash":"917e3c2bda5c898f50c9a123d6de9037bd9c9b89","modified":1681463713314},{"_id":"public/js/search/algolia.js","hash":"9feb248552667c53ce1b19bc7a295215f8c77008","modified":1681463713314},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1681463713314},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1681463713314},{"_id":"public/js/main.js","hash":"73d2624ed465e4cfb1ebb00b2c8a24f5fc29bb21","modified":1681463713314},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1681463713314},{"_id":"public/img/c9.jpg","hash":"799830518b1be36be6adf3d112268ad7201e84a7","modified":1681463713314},{"_id":"public/post/19ce5f52/C2DGA.png","hash":"e0157cf6b740007183b4fa240c586987279b4637","modified":1681463713314},{"_id":"public/post/26cc52b5/architecture.png","hash":"baaf9e8db0bf3413640a6b001206624464cb8242","modified":1681463713314},{"_id":"public/post/f2b485e3/arch.jpg","hash":"5f8177c12a56089e78abb5472d9129f823447d6b","modified":1681463713314},{"_id":"public/post/19ce5f52/orchard.png","hash":"4b2444356c5da184d9df2acf35e523fef3a1c9ce","modified":1681463713314},{"_id":"public/post/8e372fbf/succ1.png","hash":"8a2f65b9ded69a408039aa66dd32c660fd6beaa6","modified":1681463713314},{"_id":"public/post/8e372fbf/use0.png","hash":"8f649429dd5a273eb437c6356f0b4b4a74ae4589","modified":1681463713314},{"_id":"public/post/1df31392/fm.png","hash":"c85fd2cdaa36a9e77f58e6cd41da98c73fdea8e5","modified":1681463713314},{"_id":"public/post/7fb3659b/dockerfile_cmd.png","hash":"faa3ab6aca4a1f4c0298557ffb45db796dba7ac2","modified":1681463713314},{"_id":"public/post/bdcd1c7d/1.png","hash":"bd1394ee02c63740ea123864f4e6493a11880d51","modified":1681463713314},{"_id":"public/post/7fb3659b/ufs.png","hash":"93528a5cd6d21ded6b94bf2487ed71efceb76b25","modified":1681463713314},{"_id":"public/img/top.jpg","hash":"e68a2a41d74b237a9f309a3658b9eb83d3372e6c","modified":1681463713314},{"_id":"public/post/8e372fbf/use4.png","hash":"d26790f07f4d0032aed38c5c0bb5c21da82f516f","modified":1681463713314},{"_id":"public/gallery/index/9.jpg","hash":"6e03576b0ac945397b35020202a3cc9b342de787","modified":1681463713314},{"_id":"public/gallery/index/7.jpg","hash":"48342afdf9822c598af60c3cd8c93d382dee93b7","modified":1681463713314},{"_id":"public/img/c6.jpg","hash":"e5620f672399e032d227f2fcbee85f49a100e731","modified":1681463713314},{"_id":"public/gallery/index/6.jpg","hash":"649e14a8e235f5cf542f49582c5a6735146a1666","modified":1681463713314},{"_id":"public/img/sub.jpg","hash":"102f267ff7ad8b760ba75855517151b684c060f2","modified":1681463713314},{"_id":"public/gallery/index/1.jpg","hash":"2adfe132d145a91e7ffffbe81b30460c715ac47f","modified":1681463713314},{"_id":"public/img/c5.jpg","hash":"c74f49fc971661094bf340d168998339fe65b2e9","modified":1681463713314},{"_id":"public/img/c8.jpg","hash":"56a6c7562c0c6d959d0b22a32a8271b9ccb6fe07","modified":1681463713314},{"_id":"public/gallery/index/2.jpg","hash":"76890e4de5f386bd1a5d98cb06d8916777509e76","modified":1681463713314},{"_id":"public/gallery/index/5.jpg","hash":"14a0fe19126e40ed50e9697239bb621586196c8d","modified":1681463713314},{"_id":"public/gallery/index/3.jpg","hash":"1dcecfa65c8d0345c8f5b3bc76a9a5f61614bd6f","modified":1681463713314},{"_id":"public/gallery/index/4.jpg","hash":"437a9547c01f218adb01c8173477367e80f9a77b","modified":1681463713314},{"_id":"public/img/c10.jpg","hash":"93119e91bc7506a271357a8cb08d8b2de3f9604b","modified":1681463713314},{"_id":"public/img/top1.jpg","hash":"0d23e97bd120b10eb2df53b1da30cb211b7f19e1","modified":1681463713314},{"_id":"public/gallery/index/11.jpg","hash":"d277c50560a0470966da87aded1dcf865f08fbad","modified":1681463713314},{"_id":"public/img/c7.jpg","hash":"a75329c04072e58808c6ec0cafa896f51d531d77","modified":1681463713314},{"_id":"public/img/c4.png","hash":"a6cb944e925084b5eeb6115074ea1dbffd7380ed","modified":1681463713314},{"_id":"public/gallery/index/8.png","hash":"e1e1ffef7a17ffe286a99cd2ff9c82d9a6ea3d5f","modified":1681463713314},{"_id":"public/img/mov.gif","hash":"9537ebb16c9a1467b709c46481f3668a96af7cb2","modified":1681463713314},{"_id":"public/gallery/index/10.jpg","hash":"c3a0ae4ed1a5b2eaa9c514f9d1654afd9af98de6","modified":1681463713314},{"_id":"public/img/c11.png","hash":"3ad85e2fa37717d3fef383f53bc9277ada73286f","modified":1681463713314},{"_id":"public/img/c12.png","hash":"f91d28acad48e4aafeb25057922ea3f66bbdf9ce","modified":1681463713314},{"_id":"public/img/c2.jpg","hash":"d3e7ee314156e459759cef9206b63c94be7036c9","modified":1681463713314},{"_id":"public/img/c1.jpg","hash":"f080d002873cf9859f472799b34b65a5a9e87828","modified":1681463713314},{"_id":"public/img/c3.png","hash":"9c612ed297d5feaa16080169c25f0d4da0240674","modified":1681463713314}],"Category":[{"name":"security","_id":"clggc2xjh0004ecwdertm8iaj"},{"name":"微服务","_id":"clggc2xjl000becwdclnyhwrg"},{"name":"MIT 6.824","_id":"clggc2xjn000hecwd2qcf05j7"},{"name":"图形学","_id":"clggc2xjr000pecwd8gi66org"},{"name":"大创","_id":"clggc2xjs000uecwd8el597sh"},{"name":"分布式","parent":"clggc2xjl000becwdclnyhwrg","_id":"clggc2xjs000yecwde6p8hkbq"},{"name":"云计算","_id":"clggc2xjt0010ecwdfgh6c2cf"},{"name":"DL","_id":"clggc2xju0019ecwd0rrae7vq"},{"name":"RPC","parent":"clggc2xjl000becwdclnyhwrg","_id":"clggc2xjv001cecwd1an644er"},{"name":"区块链","parent":"clggc2xjs000uecwd8el597sh","_id":"clggc2xjv001hecwdf9xkb4wj"},{"name":"K8s","parent":"clggc2xjt0010ecwdfgh6c2cf","_id":"clggc2xjw001lecwd75y8fydh"},{"name":"life","_id":"clggc2xk3002fecwd5b9efqkf"},{"name":"计算机底层","_id":"clggc2xk4002hecwd6zev8hc6"}],"Data":[],"Page":[{"title":"分类","date":"2022-09-08T05:50:56.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-09-08 13:50:56\ntype: \"categories\"\n---\n","updated":"2022-09-08T05:51:26.823Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clggc2xjb0000ecwdf4gdfblj","content":"","site":{"data":{}},"cover":"/img/c10.jpg","excerpt":"","more":""},{"title":"gallery","date":"2022-09-08T06:37:37.000Z","_content":"\n{% gallery %}\n![](index/1.jpg)\n![](index/2.jpg)\n![](index/3.jpg)\n![](index/4.jpg)\n![](index/5.jpg)\n![](index/6.jpg)\n![](index/7.jpg)\n![](index/8.png)\n\n![](index/9.jpg)\n\n![](index/10.jpg)\n\n![](index/11.jpg)\n\n{% endgallery %}\n\n","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2022-09-08 14:37:37\n---\n\n{% gallery %}\n![](index/1.jpg)\n![](index/2.jpg)\n![](index/3.jpg)\n![](index/4.jpg)\n![](index/5.jpg)\n![](index/6.jpg)\n![](index/7.jpg)\n![](index/8.png)\n\n![](index/9.jpg)\n\n![](index/10.jpg)\n\n![](index/11.jpg)\n\n{% endgallery %}\n\n","updated":"2022-09-08T07:37:14.000Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"clggc2xjf0002ecwd965acupe","content":"<div class=\"fj-gallery\"><p><img src=\"/gallery/index/1.jpg\"><br><img src=\"/gallery/index/2.jpg\"><br><img src=\"/gallery/index/3.jpg\"><br><img src=\"/gallery/index/4.jpg\"><br><img src=\"/gallery/index/5.jpg\"><br><img src=\"/gallery/index/6.jpg\"><br><img src=\"/gallery/index/7.jpg\"><br><img src=\"/gallery/index/8.png\"></p><p><img src=\"/gallery/index/9.jpg\"></p><p><img src=\"/gallery/index/10.jpg\"></p><p><img src=\"/gallery/index/11.jpg\"></p>\n          </div>\n\n","site":{"data":{}},"cover":"/img/c9.jpg","excerpt":"","more":"<div class=\"fj-gallery\"><p><img src=\"/gallery/index/1.jpg\"><br><img src=\"/gallery/index/2.jpg\"><br><img src=\"/gallery/index/3.jpg\"><br><img src=\"/gallery/index/4.jpg\"><br><img src=\"/gallery/index/5.jpg\"><br><img src=\"/gallery/index/6.jpg\"><br><img src=\"/gallery/index/7.jpg\"><br><img src=\"/gallery/index/8.png\"></p><p><img src=\"/gallery/index/9.jpg\"></p><p><img src=\"/gallery/index/10.jpg\"></p><p><img src=\"/gallery/index/11.jpg\"></p>\n          </div>\n\n"},{"title":"music","date":"2022-09-15T16:34:03.000Z","type":"music","_content":"\n{% meting \"3013413533\" \"tencent\" \"playlist\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n","source":"music/index.md","raw":"---\ntitle: music\ndate: 2022-09-16 00:34:03\ntype: \"music\"\n---\n\n{% meting \"3013413533\" \"tencent\" \"playlist\" \"theme:#555\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %}\n","updated":"2022-09-15T16:44:34.577Z","path":"music/index.html","comments":1,"layout":"page","_id":"clggc2xji0006ecwdhrtfeo68","content":"\n    <div id=\"aplayer-leqBbgdZ\" class=\"aplayer aplayer-tag-marker meting-tag-marker\" data-id=\"3013413533\" data-server=\"tencent\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#555\"></div>\n","site":{"data":{}},"cover":"/img/c1.jpg","excerpt":"","more":"\n    <div id=\"aplayer-leqBbgdZ\" class=\"aplayer aplayer-tag-marker meting-tag-marker\" data-id=\"3013413533\" data-server=\"tencent\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#555\"></div>\n"},{"title":"标签","date":"2022-09-08T05:49:42.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-09-08 13:49:42\ntype: \"tags\"\n---\n","updated":"2022-09-08T05:50:24.665Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clggc2xjj0008ecwd96eq5mwh","content":"","site":{"data":{}},"cover":"/img/c2.jpg","excerpt":"","more":""}],"Post":[{"title":"DGA域名","abbrlink":"19ce5f52","_content":"\n# 简介\n\n>DGA（Domain generation algorithms），中文名：**域名生成算法**，其可以生成大量随机的域名来供恶意软件连接C&C控制服务器。 恶意软件编写者将采用同样的种子和算法生成与恶意软件相同的域名列表，从中选取几个来作为控制服务器，恶意软件会持续解析这些域名，直到发现可用的服务器地址。\n\n## C2 & DGA\n![C&C攻击下的运用](./DGA域名/C2DGA.png)\n\n\n很显然，在这种方式下，传统基于黑名单的防护手段无法起作用：\n1.  黑名单的更新速度远远赶不上DGA域名的生成速度；\n2. 一般来说，一个DGA域名的存活时间通常在1-7天左右；\n3. 防御者必须阻断所有的DGA域名才能阻断C2通信；\n因此，DGA域名的使用使得攻击容易，隐蔽性提高，防御变得困难。\n\n最近使用 DGA 创建命令和控制 (C&C) 服务器的恶意软件攻击示例包括 Conficker、Zeus 和 Dyre。\n\n# DGA域名分类\nDGA算法由两部分构成，种子（算法输入）和算法，可以根据种子和算法对DGA域名进行分类，DGA域名可以表示为AGD（Algorithmically-Generated Domains）。\n\n## 按照种子进行分类\n\n+ **基于时间的种子（Time dependence）**。DGA算法将会使用时间信息作为输入，如：感染主机的系统时间，http响应的时间等。\n\n+ **是否具有确定性（Determinism）**。主流的DGA算法的输入是确定的，因此AGD可以被提前计算，但是也有一些DGA算法的输入是不确定的，如：`Bedep`以欧洲中央银行每天发布的外汇参考汇率作为种子，`Torpig`用twitter的关键词作为种子，只有在确定时间窗口内注册域名才能生效。\n\n根据种子的分类方法，DGA域名可以分为以下4类：\n\n**1. TID（time-independent and deterministic）**，与时间不相关，可确定；\n**2. TDD（time-dependent and deterministic）**，与时间相关，可确定；\n**3. TDN（time-dependent and non-deterministic）**，与时间相关，不可确定；\n**4. TIN（time-independent and non-deterministic**），与时间不相关，不可确定；\n\n## 按照生成算法进行分类\n\n现有DGA生成算法一般可以分为如下4类：\n+ **基于算术（Arithmetic-based）**：该类型算法会生成一组可用ASCII编码表示的值，从而构成DGA域名，流行度最高；实现简单，规律性强\n+ **基于哈希（Hash-based）**：用哈希值的16进制表示产生的DGA域名，常使用的哈希算法有：MD5，SHA256；混乱度高，可预测性低\n+ **基于词典（Wordlist-based）**：该方式会从专有词典中挑选单词进行组合，减少域名字符上的随机性，迷惑性更强，词典内嵌在恶意程序中或者从公有服务中提取；\n+ **基于排列组合（或称置换，Permutation-based）**：对一个初始域名进行字符上的排列组合。\n\n## 举例\n|  family   |        category         |               example               |\n|:---------:|:-----------------------:|:-----------------------------------:|\n|  fobber   | Arithmetic-based & TID  |        yomaebzlsinlytabp.net        |\n|   simda   | Permutation-based & TID |             qexyfag.com             |\n| verblecon |    Hash-based & TDD     | 03d4b0f5a86d723f81d534a4eb1638de.tk |\n|   pizd    |  Wordlist-based & TDD   |         effortpossible.net          |\n|  Orchard  |    Hash-based & TDN     |        8992a8e4.duckdns.org         |\n\n### Orchard\n\n-   Orchard是一个使用了DGA技术的僵尸网络(botnet)家族，核心功能是在受害者机器上安装各种恶意软件。\n- 从2021年2月至2022年5月，先后检测到3个版本的Orchard样本，均使用了DGA技术。\n-   Orchard的DGA算法一直未变，但日期的使用方式一直在变，最新版同时支持使用比特币账号信息来生成单独的DGA域名。\n-   Orchard目前仍在活跃，致力于门罗币挖矿。\n\n**Orchard的工作流程**\n![](./DGA域名/orchard.png)\n\n**探测到的感染规模**\n```\n# v1, orcharddns.duckdns.org\n37,   45.61.185.36\n413,  45.61.186.52\n1301, 45.61.187.240\n207,  205.185.124.143\n\n# v2, orchardmaster.duckdns.org\n45,   45.61.185.36\n104,  45.61.186.52\n659,  45.61.187.240\n\n# v3, ojena.duckdns.org\n418,  45.61.185.231\n```\n\n\nOrchard v3 DGA域名不但使用日期信息，还会同时使用中本聪的比特币账号交易信息来生成DGA域名。因为比特币交易的不确定性，该技术比使用时间生成的DGA更难以检测，因而防御难度更大。\n\n>结合长期的跟踪结果和其它维度的信息，我们认为Orchard会是一个长期活跃、持续发展的botnet家族，值得警惕。\n>**原文出处**: https://blog.netlab.360.com/orchard-dga/\n\n\n---\n\n# DGA域名检测\n\n## 基于黑名单的检测与防护\n大多数DGA算法都具有时间相关和确定性，即它们的生成参数是可获取和可重用的，因此其生成的结果时可预测的。基于此特点，可以对每个恶意软件及其变体进行逆向分析获得域名生成算法和种子，从而提取给定日期和时间的有效域名集合，加入黑名单进行DGA域名检测。\n\n但是，有几点关键缺陷：\n1. 黑名单的更新速度远远赶不上DGA域名的生成速度，例如TDD型，linux内核高精度时钟可提供纳秒级别精度的时间数值，那么可产生的DGA域名不计其数；\n2. TDN与TIN型DGA域名的黑名单难以构建；\n3. DGA变种数量庞大，开源黑名单的DGA覆盖率低。\n因此，粗暴用DGA构建黑名单的方法可行性不高，并不能解决根本问题。\n\n## 基于第三方信息的检测\n+ 基于域名注册状态的检测\n\t+ 域名注册时间\n\t+ 域名使用度\n\t+ 域名审核级别\n+ 基于威胁情报平台提供的信息(DGA数据集等)进行检测\n\t+ 306netlab dga 360dga数据集  \n\t+ virustotal.com virustotal平台  \n\t+ x.threatboot.com 微步威胁情报平台  \n\t+ ti.360.cn 360威胁情报平台  \n\t+ tj-un.com 天际友盟平台\n\n## 基于信息学与统计学的检测\n+ 基于信息熵的检测\n+ 基于隐式马尔科夫模型检测\n\n![](./DGA域名/markov.png)\n\n## 基于AI的检测\n+ 基于深度学习\n\t+ LSTM网络\n\t+ GAN网络\n\n深度学习模型通过一个神经网络对已知的DGA域名和正常域名进行学习，从而获得一个鉴别DGA域名的分类器，深度学习模型解释性较低，难于调试，但是较传统模型效果更好，故而也有很多产品使用此方法。\n\n# 参考\n\n>https://data.netlab.360.com/dga/\n>https://bin.re/tag/dga/\n>https://blog.csdn.net/Hardworking666/article/details/123422221\n>https://github.com/baderj/domain_generation_algorithms\n>https://blog.csdn.net/whatday/article/details/114690030","source":"_posts/DGA域名.md","raw":"---\ntitle: DGA域名\ntags:\n  - DGA\ncategories:\n  - security\nabbrlink: 19ce5f52\n---\n\n# 简介\n\n>DGA（Domain generation algorithms），中文名：**域名生成算法**，其可以生成大量随机的域名来供恶意软件连接C&C控制服务器。 恶意软件编写者将采用同样的种子和算法生成与恶意软件相同的域名列表，从中选取几个来作为控制服务器，恶意软件会持续解析这些域名，直到发现可用的服务器地址。\n\n## C2 & DGA\n![C&C攻击下的运用](./DGA域名/C2DGA.png)\n\n\n很显然，在这种方式下，传统基于黑名单的防护手段无法起作用：\n1.  黑名单的更新速度远远赶不上DGA域名的生成速度；\n2. 一般来说，一个DGA域名的存活时间通常在1-7天左右；\n3. 防御者必须阻断所有的DGA域名才能阻断C2通信；\n因此，DGA域名的使用使得攻击容易，隐蔽性提高，防御变得困难。\n\n最近使用 DGA 创建命令和控制 (C&C) 服务器的恶意软件攻击示例包括 Conficker、Zeus 和 Dyre。\n\n# DGA域名分类\nDGA算法由两部分构成，种子（算法输入）和算法，可以根据种子和算法对DGA域名进行分类，DGA域名可以表示为AGD（Algorithmically-Generated Domains）。\n\n## 按照种子进行分类\n\n+ **基于时间的种子（Time dependence）**。DGA算法将会使用时间信息作为输入，如：感染主机的系统时间，http响应的时间等。\n\n+ **是否具有确定性（Determinism）**。主流的DGA算法的输入是确定的，因此AGD可以被提前计算，但是也有一些DGA算法的输入是不确定的，如：`Bedep`以欧洲中央银行每天发布的外汇参考汇率作为种子，`Torpig`用twitter的关键词作为种子，只有在确定时间窗口内注册域名才能生效。\n\n根据种子的分类方法，DGA域名可以分为以下4类：\n\n**1. TID（time-independent and deterministic）**，与时间不相关，可确定；\n**2. TDD（time-dependent and deterministic）**，与时间相关，可确定；\n**3. TDN（time-dependent and non-deterministic）**，与时间相关，不可确定；\n**4. TIN（time-independent and non-deterministic**），与时间不相关，不可确定；\n\n## 按照生成算法进行分类\n\n现有DGA生成算法一般可以分为如下4类：\n+ **基于算术（Arithmetic-based）**：该类型算法会生成一组可用ASCII编码表示的值，从而构成DGA域名，流行度最高；实现简单，规律性强\n+ **基于哈希（Hash-based）**：用哈希值的16进制表示产生的DGA域名，常使用的哈希算法有：MD5，SHA256；混乱度高，可预测性低\n+ **基于词典（Wordlist-based）**：该方式会从专有词典中挑选单词进行组合，减少域名字符上的随机性，迷惑性更强，词典内嵌在恶意程序中或者从公有服务中提取；\n+ **基于排列组合（或称置换，Permutation-based）**：对一个初始域名进行字符上的排列组合。\n\n## 举例\n|  family   |        category         |               example               |\n|:---------:|:-----------------------:|:-----------------------------------:|\n|  fobber   | Arithmetic-based & TID  |        yomaebzlsinlytabp.net        |\n|   simda   | Permutation-based & TID |             qexyfag.com             |\n| verblecon |    Hash-based & TDD     | 03d4b0f5a86d723f81d534a4eb1638de.tk |\n|   pizd    |  Wordlist-based & TDD   |         effortpossible.net          |\n|  Orchard  |    Hash-based & TDN     |        8992a8e4.duckdns.org         |\n\n### Orchard\n\n-   Orchard是一个使用了DGA技术的僵尸网络(botnet)家族，核心功能是在受害者机器上安装各种恶意软件。\n- 从2021年2月至2022年5月，先后检测到3个版本的Orchard样本，均使用了DGA技术。\n-   Orchard的DGA算法一直未变，但日期的使用方式一直在变，最新版同时支持使用比特币账号信息来生成单独的DGA域名。\n-   Orchard目前仍在活跃，致力于门罗币挖矿。\n\n**Orchard的工作流程**\n![](./DGA域名/orchard.png)\n\n**探测到的感染规模**\n```\n# v1, orcharddns.duckdns.org\n37,   45.61.185.36\n413,  45.61.186.52\n1301, 45.61.187.240\n207,  205.185.124.143\n\n# v2, orchardmaster.duckdns.org\n45,   45.61.185.36\n104,  45.61.186.52\n659,  45.61.187.240\n\n# v3, ojena.duckdns.org\n418,  45.61.185.231\n```\n\n\nOrchard v3 DGA域名不但使用日期信息，还会同时使用中本聪的比特币账号交易信息来生成DGA域名。因为比特币交易的不确定性，该技术比使用时间生成的DGA更难以检测，因而防御难度更大。\n\n>结合长期的跟踪结果和其它维度的信息，我们认为Orchard会是一个长期活跃、持续发展的botnet家族，值得警惕。\n>**原文出处**: https://blog.netlab.360.com/orchard-dga/\n\n\n---\n\n# DGA域名检测\n\n## 基于黑名单的检测与防护\n大多数DGA算法都具有时间相关和确定性，即它们的生成参数是可获取和可重用的，因此其生成的结果时可预测的。基于此特点，可以对每个恶意软件及其变体进行逆向分析获得域名生成算法和种子，从而提取给定日期和时间的有效域名集合，加入黑名单进行DGA域名检测。\n\n但是，有几点关键缺陷：\n1. 黑名单的更新速度远远赶不上DGA域名的生成速度，例如TDD型，linux内核高精度时钟可提供纳秒级别精度的时间数值，那么可产生的DGA域名不计其数；\n2. TDN与TIN型DGA域名的黑名单难以构建；\n3. DGA变种数量庞大，开源黑名单的DGA覆盖率低。\n因此，粗暴用DGA构建黑名单的方法可行性不高，并不能解决根本问题。\n\n## 基于第三方信息的检测\n+ 基于域名注册状态的检测\n\t+ 域名注册时间\n\t+ 域名使用度\n\t+ 域名审核级别\n+ 基于威胁情报平台提供的信息(DGA数据集等)进行检测\n\t+ 306netlab dga 360dga数据集  \n\t+ virustotal.com virustotal平台  \n\t+ x.threatboot.com 微步威胁情报平台  \n\t+ ti.360.cn 360威胁情报平台  \n\t+ tj-un.com 天际友盟平台\n\n## 基于信息学与统计学的检测\n+ 基于信息熵的检测\n+ 基于隐式马尔科夫模型检测\n\n![](./DGA域名/markov.png)\n\n## 基于AI的检测\n+ 基于深度学习\n\t+ LSTM网络\n\t+ GAN网络\n\n深度学习模型通过一个神经网络对已知的DGA域名和正常域名进行学习，从而获得一个鉴别DGA域名的分类器，深度学习模型解释性较低，难于调试，但是较传统模型效果更好，故而也有很多产品使用此方法。\n\n# 参考\n\n>https://data.netlab.360.com/dga/\n>https://bin.re/tag/dga/\n>https://blog.csdn.net/Hardworking666/article/details/123422221\n>https://github.com/baderj/domain_generation_algorithms\n>https://blog.csdn.net/whatday/article/details/114690030","slug":"DGA域名","published":1,"date":"2023-04-12T15:10:39.302Z","updated":"2023-04-14T08:37:34.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjd0001ecwdeyag3lt5","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><blockquote>\n<p>DGA（Domain generation algorithms），中文名：<strong>域名生成算法</strong>，其可以生成大量随机的域名来供恶意软件连接C&amp;C控制服务器。 恶意软件编写者将采用同样的种子和算法生成与恶意软件相同的域名列表，从中选取几个来作为控制服务器，恶意软件会持续解析这些域名，直到发现可用的服务器地址。</p>\n</blockquote>\n<h2 id=\"C2-amp-DGA\"><a href=\"#C2-amp-DGA\" class=\"headerlink\" title=\"C2 &amp; DGA\"></a>C2 &amp; DGA</h2><p><img src=\"/post/19ce5f52/C2DGA.png\" alt=\"C&amp;C攻击下的运用\"></p>\n<p>很显然，在这种方式下，传统基于黑名单的防护手段无法起作用：</p>\n<ol>\n<li> 黑名单的更新速度远远赶不上DGA域名的生成速度；</li>\n<li>一般来说，一个DGA域名的存活时间通常在1-7天左右；</li>\n<li>防御者必须阻断所有的DGA域名才能阻断C2通信；<br>因此，DGA域名的使用使得攻击容易，隐蔽性提高，防御变得困难。</li>\n</ol>\n<p>最近使用 DGA 创建命令和控制 (C&amp;C) 服务器的恶意软件攻击示例包括 Conficker、Zeus 和 Dyre。</p>\n<h1 id=\"DGA域名分类\"><a href=\"#DGA域名分类\" class=\"headerlink\" title=\"DGA域名分类\"></a>DGA域名分类</h1><p>DGA算法由两部分构成，种子（算法输入）和算法，可以根据种子和算法对DGA域名进行分类，DGA域名可以表示为AGD（Algorithmically-Generated Domains）。</p>\n<h2 id=\"按照种子进行分类\"><a href=\"#按照种子进行分类\" class=\"headerlink\" title=\"按照种子进行分类\"></a>按照种子进行分类</h2><ul>\n<li><p><strong>基于时间的种子（Time dependence）</strong>。DGA算法将会使用时间信息作为输入，如：感染主机的系统时间，http响应的时间等。</p>\n</li>\n<li><p><strong>是否具有确定性（Determinism）</strong>。主流的DGA算法的输入是确定的，因此AGD可以被提前计算，但是也有一些DGA算法的输入是不确定的，如：<code>Bedep</code>以欧洲中央银行每天发布的外汇参考汇率作为种子，<code>Torpig</code>用twitter的关键词作为种子，只有在确定时间窗口内注册域名才能生效。</p>\n</li>\n</ul>\n<p>根据种子的分类方法，DGA域名可以分为以下4类：</p>\n<p><strong>1. TID（time-independent and deterministic）</strong>，与时间不相关，可确定；<br><strong>2. TDD（time-dependent and deterministic）</strong>，与时间相关，可确定；<br><strong>3. TDN（time-dependent and non-deterministic）</strong>，与时间相关，不可确定；<br><strong>4. TIN（time-independent and non-deterministic</strong>），与时间不相关，不可确定；</p>\n<h2 id=\"按照生成算法进行分类\"><a href=\"#按照生成算法进行分类\" class=\"headerlink\" title=\"按照生成算法进行分类\"></a>按照生成算法进行分类</h2><p>现有DGA生成算法一般可以分为如下4类：</p>\n<ul>\n<li><strong>基于算术（Arithmetic-based）</strong>：该类型算法会生成一组可用ASCII编码表示的值，从而构成DGA域名，流行度最高；实现简单，规律性强</li>\n<li><strong>基于哈希（Hash-based）</strong>：用哈希值的16进制表示产生的DGA域名，常使用的哈希算法有：MD5，SHA256；混乱度高，可预测性低</li>\n<li><strong>基于词典（Wordlist-based）</strong>：该方式会从专有词典中挑选单词进行组合，减少域名字符上的随机性，迷惑性更强，词典内嵌在恶意程序中或者从公有服务中提取；</li>\n<li><strong>基于排列组合（或称置换，Permutation-based）</strong>：对一个初始域名进行字符上的排列组合。</li>\n</ul>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><table>\n<thead>\n<tr>\n<th align=\"center\">family</th>\n<th align=\"center\">category</th>\n<th align=\"center\">example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">fobber</td>\n<td align=\"center\">Arithmetic-based &amp; TID</td>\n<td align=\"center\">yomaebzlsinlytabp.net</td>\n</tr>\n<tr>\n<td align=\"center\">simda</td>\n<td align=\"center\">Permutation-based &amp; TID</td>\n<td align=\"center\">qexyfag.com</td>\n</tr>\n<tr>\n<td align=\"center\">verblecon</td>\n<td align=\"center\">Hash-based &amp; TDD</td>\n<td align=\"center\">03d4b0f5a86d723f81d534a4eb1638de.tk</td>\n</tr>\n<tr>\n<td align=\"center\">pizd</td>\n<td align=\"center\">Wordlist-based &amp; TDD</td>\n<td align=\"center\">effortpossible.net</td>\n</tr>\n<tr>\n<td align=\"center\">Orchard</td>\n<td align=\"center\">Hash-based &amp; TDN</td>\n<td align=\"center\">8992a8e4.duckdns.org</td>\n</tr>\n</tbody></table>\n<h3 id=\"Orchard\"><a href=\"#Orchard\" class=\"headerlink\" title=\"Orchard\"></a>Orchard</h3><ul>\n<li>  Orchard是一个使用了DGA技术的僵尸网络(botnet)家族，核心功能是在受害者机器上安装各种恶意软件。</li>\n<li>从2021年2月至2022年5月，先后检测到3个版本的Orchard样本，均使用了DGA技术。</li>\n<li>  Orchard的DGA算法一直未变，但日期的使用方式一直在变，最新版同时支持使用比特币账号信息来生成单独的DGA域名。</li>\n<li>  Orchard目前仍在活跃，致力于门罗币挖矿。</li>\n</ul>\n<p><strong>Orchard的工作流程</strong><br><img src=\"/post/19ce5f52/orchard.png\"></p>\n<p><strong>探测到的感染规模</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># v1, orcharddns.duckdns.org</span><br><span class=\"line\">37,   45.61.185.36</span><br><span class=\"line\">413,  45.61.186.52</span><br><span class=\"line\">1301, 45.61.187.240</span><br><span class=\"line\">207,  205.185.124.143</span><br><span class=\"line\"></span><br><span class=\"line\"># v2, orchardmaster.duckdns.org</span><br><span class=\"line\">45,   45.61.185.36</span><br><span class=\"line\">104,  45.61.186.52</span><br><span class=\"line\">659,  45.61.187.240</span><br><span class=\"line\"></span><br><span class=\"line\"># v3, ojena.duckdns.org</span><br><span class=\"line\">418,  45.61.185.231</span><br></pre></td></tr></table></figure>\n\n\n<p>Orchard v3 DGA域名不但使用日期信息，还会同时使用中本聪的比特币账号交易信息来生成DGA域名。因为比特币交易的不确定性，该技术比使用时间生成的DGA更难以检测，因而防御难度更大。</p>\n<blockquote>\n<p>结合长期的跟踪结果和其它维度的信息，我们认为Orchard会是一个长期活跃、持续发展的botnet家族，值得警惕。<br><strong>原文出处</strong>: <a href=\"https://blog.netlab.360.com/orchard-dga/\">https://blog.netlab.360.com/orchard-dga/</a></p>\n</blockquote>\n<hr>\n<h1 id=\"DGA域名检测\"><a href=\"#DGA域名检测\" class=\"headerlink\" title=\"DGA域名检测\"></a>DGA域名检测</h1><h2 id=\"基于黑名单的检测与防护\"><a href=\"#基于黑名单的检测与防护\" class=\"headerlink\" title=\"基于黑名单的检测与防护\"></a>基于黑名单的检测与防护</h2><p>大多数DGA算法都具有时间相关和确定性，即它们的生成参数是可获取和可重用的，因此其生成的结果时可预测的。基于此特点，可以对每个恶意软件及其变体进行逆向分析获得域名生成算法和种子，从而提取给定日期和时间的有效域名集合，加入黑名单进行DGA域名检测。</p>\n<p>但是，有几点关键缺陷：</p>\n<ol>\n<li>黑名单的更新速度远远赶不上DGA域名的生成速度，例如TDD型，linux内核高精度时钟可提供纳秒级别精度的时间数值，那么可产生的DGA域名不计其数；</li>\n<li>TDN与TIN型DGA域名的黑名单难以构建；</li>\n<li>DGA变种数量庞大，开源黑名单的DGA覆盖率低。<br>因此，粗暴用DGA构建黑名单的方法可行性不高，并不能解决根本问题。</li>\n</ol>\n<h2 id=\"基于第三方信息的检测\"><a href=\"#基于第三方信息的检测\" class=\"headerlink\" title=\"基于第三方信息的检测\"></a>基于第三方信息的检测</h2><ul>\n<li>基于域名注册状态的检测<ul>\n<li>域名注册时间</li>\n<li>域名使用度</li>\n<li>域名审核级别</li>\n</ul>\n</li>\n<li>基于威胁情报平台提供的信息(DGA数据集等)进行检测<ul>\n<li>306netlab dga 360dga数据集  </li>\n<li>virustotal.com virustotal平台  </li>\n<li>x.threatboot.com 微步威胁情报平台  </li>\n<li>ti.360.cn 360威胁情报平台  </li>\n<li>tj-un.com 天际友盟平台</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基于信息学与统计学的检测\"><a href=\"#基于信息学与统计学的检测\" class=\"headerlink\" title=\"基于信息学与统计学的检测\"></a>基于信息学与统计学的检测</h2><ul>\n<li>基于信息熵的检测</li>\n<li>基于隐式马尔科夫模型检测</li>\n</ul>\n<p><img src=\"/post/19ce5f52/markov.png\"></p>\n<h2 id=\"基于AI的检测\"><a href=\"#基于AI的检测\" class=\"headerlink\" title=\"基于AI的检测\"></a>基于AI的检测</h2><ul>\n<li>基于深度学习<ul>\n<li>LSTM网络</li>\n<li>GAN网络</li>\n</ul>\n</li>\n</ul>\n<p>深度学习模型通过一个神经网络对已知的DGA域名和正常域名进行学习，从而获得一个鉴别DGA域名的分类器，深度学习模型解释性较低，难于调试，但是较传统模型效果更好，故而也有很多产品使用此方法。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<p><a href=\"https://data.netlab.360.com/dga/\">https://data.netlab.360.com/dga/</a><br><a href=\"https://bin.re/tag/dga/\">https://bin.re/tag/dga/</a><br><a href=\"https://blog.csdn.net/Hardworking666/article/details/123422221\">https://blog.csdn.net/Hardworking666/article/details/123422221</a><br><a href=\"https://github.com/baderj/domain_generation_algorithms\">https://github.com/baderj/domain_generation_algorithms</a><br><a href=\"https://blog.csdn.net/whatday/article/details/114690030\">https://blog.csdn.net/whatday/article/details/114690030</a></p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/c3.png","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><blockquote>\n<p>DGA（Domain generation algorithms），中文名：<strong>域名生成算法</strong>，其可以生成大量随机的域名来供恶意软件连接C&amp;C控制服务器。 恶意软件编写者将采用同样的种子和算法生成与恶意软件相同的域名列表，从中选取几个来作为控制服务器，恶意软件会持续解析这些域名，直到发现可用的服务器地址。</p>\n</blockquote>\n<h2 id=\"C2-amp-DGA\"><a href=\"#C2-amp-DGA\" class=\"headerlink\" title=\"C2 &amp; DGA\"></a>C2 &amp; DGA</h2><p><img src=\"/post/19ce5f52/C2DGA.png\" alt=\"C&amp;C攻击下的运用\"></p>\n<p>很显然，在这种方式下，传统基于黑名单的防护手段无法起作用：</p>\n<ol>\n<li> 黑名单的更新速度远远赶不上DGA域名的生成速度；</li>\n<li>一般来说，一个DGA域名的存活时间通常在1-7天左右；</li>\n<li>防御者必须阻断所有的DGA域名才能阻断C2通信；<br>因此，DGA域名的使用使得攻击容易，隐蔽性提高，防御变得困难。</li>\n</ol>\n<p>最近使用 DGA 创建命令和控制 (C&amp;C) 服务器的恶意软件攻击示例包括 Conficker、Zeus 和 Dyre。</p>\n<h1 id=\"DGA域名分类\"><a href=\"#DGA域名分类\" class=\"headerlink\" title=\"DGA域名分类\"></a>DGA域名分类</h1><p>DGA算法由两部分构成，种子（算法输入）和算法，可以根据种子和算法对DGA域名进行分类，DGA域名可以表示为AGD（Algorithmically-Generated Domains）。</p>\n<h2 id=\"按照种子进行分类\"><a href=\"#按照种子进行分类\" class=\"headerlink\" title=\"按照种子进行分类\"></a>按照种子进行分类</h2><ul>\n<li><p><strong>基于时间的种子（Time dependence）</strong>。DGA算法将会使用时间信息作为输入，如：感染主机的系统时间，http响应的时间等。</p>\n</li>\n<li><p><strong>是否具有确定性（Determinism）</strong>。主流的DGA算法的输入是确定的，因此AGD可以被提前计算，但是也有一些DGA算法的输入是不确定的，如：<code>Bedep</code>以欧洲中央银行每天发布的外汇参考汇率作为种子，<code>Torpig</code>用twitter的关键词作为种子，只有在确定时间窗口内注册域名才能生效。</p>\n</li>\n</ul>\n<p>根据种子的分类方法，DGA域名可以分为以下4类：</p>\n<p><strong>1. TID（time-independent and deterministic）</strong>，与时间不相关，可确定；<br><strong>2. TDD（time-dependent and deterministic）</strong>，与时间相关，可确定；<br><strong>3. TDN（time-dependent and non-deterministic）</strong>，与时间相关，不可确定；<br><strong>4. TIN（time-independent and non-deterministic</strong>），与时间不相关，不可确定；</p>\n<h2 id=\"按照生成算法进行分类\"><a href=\"#按照生成算法进行分类\" class=\"headerlink\" title=\"按照生成算法进行分类\"></a>按照生成算法进行分类</h2><p>现有DGA生成算法一般可以分为如下4类：</p>\n<ul>\n<li><strong>基于算术（Arithmetic-based）</strong>：该类型算法会生成一组可用ASCII编码表示的值，从而构成DGA域名，流行度最高；实现简单，规律性强</li>\n<li><strong>基于哈希（Hash-based）</strong>：用哈希值的16进制表示产生的DGA域名，常使用的哈希算法有：MD5，SHA256；混乱度高，可预测性低</li>\n<li><strong>基于词典（Wordlist-based）</strong>：该方式会从专有词典中挑选单词进行组合，减少域名字符上的随机性，迷惑性更强，词典内嵌在恶意程序中或者从公有服务中提取；</li>\n<li><strong>基于排列组合（或称置换，Permutation-based）</strong>：对一个初始域名进行字符上的排列组合。</li>\n</ul>\n<h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><table>\n<thead>\n<tr>\n<th align=\"center\">family</th>\n<th align=\"center\">category</th>\n<th align=\"center\">example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">fobber</td>\n<td align=\"center\">Arithmetic-based &amp; TID</td>\n<td align=\"center\">yomaebzlsinlytabp.net</td>\n</tr>\n<tr>\n<td align=\"center\">simda</td>\n<td align=\"center\">Permutation-based &amp; TID</td>\n<td align=\"center\">qexyfag.com</td>\n</tr>\n<tr>\n<td align=\"center\">verblecon</td>\n<td align=\"center\">Hash-based &amp; TDD</td>\n<td align=\"center\">03d4b0f5a86d723f81d534a4eb1638de.tk</td>\n</tr>\n<tr>\n<td align=\"center\">pizd</td>\n<td align=\"center\">Wordlist-based &amp; TDD</td>\n<td align=\"center\">effortpossible.net</td>\n</tr>\n<tr>\n<td align=\"center\">Orchard</td>\n<td align=\"center\">Hash-based &amp; TDN</td>\n<td align=\"center\">8992a8e4.duckdns.org</td>\n</tr>\n</tbody></table>\n<h3 id=\"Orchard\"><a href=\"#Orchard\" class=\"headerlink\" title=\"Orchard\"></a>Orchard</h3><ul>\n<li>  Orchard是一个使用了DGA技术的僵尸网络(botnet)家族，核心功能是在受害者机器上安装各种恶意软件。</li>\n<li>从2021年2月至2022年5月，先后检测到3个版本的Orchard样本，均使用了DGA技术。</li>\n<li>  Orchard的DGA算法一直未变，但日期的使用方式一直在变，最新版同时支持使用比特币账号信息来生成单独的DGA域名。</li>\n<li>  Orchard目前仍在活跃，致力于门罗币挖矿。</li>\n</ul>\n<p><strong>Orchard的工作流程</strong><br><img src=\"/post/19ce5f52/orchard.png\"></p>\n<p><strong>探测到的感染规模</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># v1, orcharddns.duckdns.org</span><br><span class=\"line\">37,   45.61.185.36</span><br><span class=\"line\">413,  45.61.186.52</span><br><span class=\"line\">1301, 45.61.187.240</span><br><span class=\"line\">207,  205.185.124.143</span><br><span class=\"line\"></span><br><span class=\"line\"># v2, orchardmaster.duckdns.org</span><br><span class=\"line\">45,   45.61.185.36</span><br><span class=\"line\">104,  45.61.186.52</span><br><span class=\"line\">659,  45.61.187.240</span><br><span class=\"line\"></span><br><span class=\"line\"># v3, ojena.duckdns.org</span><br><span class=\"line\">418,  45.61.185.231</span><br></pre></td></tr></table></figure>\n\n\n<p>Orchard v3 DGA域名不但使用日期信息，还会同时使用中本聪的比特币账号交易信息来生成DGA域名。因为比特币交易的不确定性，该技术比使用时间生成的DGA更难以检测，因而防御难度更大。</p>\n<blockquote>\n<p>结合长期的跟踪结果和其它维度的信息，我们认为Orchard会是一个长期活跃、持续发展的botnet家族，值得警惕。<br><strong>原文出处</strong>: <a href=\"https://blog.netlab.360.com/orchard-dga/\">https://blog.netlab.360.com/orchard-dga/</a></p>\n</blockquote>\n<hr>\n<h1 id=\"DGA域名检测\"><a href=\"#DGA域名检测\" class=\"headerlink\" title=\"DGA域名检测\"></a>DGA域名检测</h1><h2 id=\"基于黑名单的检测与防护\"><a href=\"#基于黑名单的检测与防护\" class=\"headerlink\" title=\"基于黑名单的检测与防护\"></a>基于黑名单的检测与防护</h2><p>大多数DGA算法都具有时间相关和确定性，即它们的生成参数是可获取和可重用的，因此其生成的结果时可预测的。基于此特点，可以对每个恶意软件及其变体进行逆向分析获得域名生成算法和种子，从而提取给定日期和时间的有效域名集合，加入黑名单进行DGA域名检测。</p>\n<p>但是，有几点关键缺陷：</p>\n<ol>\n<li>黑名单的更新速度远远赶不上DGA域名的生成速度，例如TDD型，linux内核高精度时钟可提供纳秒级别精度的时间数值，那么可产生的DGA域名不计其数；</li>\n<li>TDN与TIN型DGA域名的黑名单难以构建；</li>\n<li>DGA变种数量庞大，开源黑名单的DGA覆盖率低。<br>因此，粗暴用DGA构建黑名单的方法可行性不高，并不能解决根本问题。</li>\n</ol>\n<h2 id=\"基于第三方信息的检测\"><a href=\"#基于第三方信息的检测\" class=\"headerlink\" title=\"基于第三方信息的检测\"></a>基于第三方信息的检测</h2><ul>\n<li>基于域名注册状态的检测<ul>\n<li>域名注册时间</li>\n<li>域名使用度</li>\n<li>域名审核级别</li>\n</ul>\n</li>\n<li>基于威胁情报平台提供的信息(DGA数据集等)进行检测<ul>\n<li>306netlab dga 360dga数据集  </li>\n<li>virustotal.com virustotal平台  </li>\n<li>x.threatboot.com 微步威胁情报平台  </li>\n<li>ti.360.cn 360威胁情报平台  </li>\n<li>tj-un.com 天际友盟平台</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基于信息学与统计学的检测\"><a href=\"#基于信息学与统计学的检测\" class=\"headerlink\" title=\"基于信息学与统计学的检测\"></a>基于信息学与统计学的检测</h2><ul>\n<li>基于信息熵的检测</li>\n<li>基于隐式马尔科夫模型检测</li>\n</ul>\n<p><img src=\"/post/19ce5f52/markov.png\"></p>\n<h2 id=\"基于AI的检测\"><a href=\"#基于AI的检测\" class=\"headerlink\" title=\"基于AI的检测\"></a>基于AI的检测</h2><ul>\n<li>基于深度学习<ul>\n<li>LSTM网络</li>\n<li>GAN网络</li>\n</ul>\n</li>\n</ul>\n<p>深度学习模型通过一个神经网络对已知的DGA域名和正常域名进行学习，从而获得一个鉴别DGA域名的分类器，深度学习模型解释性较低，难于调试，但是较传统模型效果更好，故而也有很多产品使用此方法。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<p><a href=\"https://data.netlab.360.com/dga/\">https://data.netlab.360.com/dga/</a><br><a href=\"https://bin.re/tag/dga/\">https://bin.re/tag/dga/</a><br><a href=\"https://blog.csdn.net/Hardworking666/article/details/123422221\">https://blog.csdn.net/Hardworking666/article/details/123422221</a><br><a href=\"https://github.com/baderj/domain_generation_algorithms\">https://github.com/baderj/domain_generation_algorithms</a><br><a href=\"https://blog.csdn.net/whatday/article/details/114690030\">https://blog.csdn.net/whatday/article/details/114690030</a></p>\n</blockquote>\n"},{"title":"Etcd 学习","abbrlink":"26cc52b5","date":"2022-09-08T03:25:32.000Z","_content":"\n# Etcd 学习\n\n> 适用于共享配置、服务发现、分布式锁、集群监控、leader选举\n\n![](./Etcd-学习/architecture.png)\n\n[下载地址](https://github.com/etcd-io/etcd/releases)\n\n[Go操作etcd](https://www.liwenzhou.com/posts/Go/go_etcd/#autoid-1-5-0)\n\n\n## Install\n\n```shell\n$  tar -zxvf etcd-v3.4.20-linux-amd64.tar.gz\n$  cd etcd-v3.4.20-linux-amd64/ \n$  cp etcd etcdctl /usr/local/bin\n```\n\n### 检查安装\n\n```shell\n$  etcd --version\netcd Version: 3.4.20\nGit SHA: 1e26823\nGo Version: go1.16.15\nGo OS/Arch: linux/amd64\n\n$  etcdctl version\netcdctl version: 3.4.20\nAPI version: 3.4\n```\n\n## 启动\n\n```shell\n$  etcd --listen-client-urls 'http://0.0.0.0:2379' --advertise-client-urls 'http://0.0.0.0:2379'\n```\n\n## 修改配置\n\n### 远程访问\n\n```shell\n# 修改/etc/etcd/etcd.conf配置：\n$  ETCD_LISTEN_CLIENT_URLS=\"http://10.103.18.41:2379,http://localhost:2379\"\n$  etcd --config-file=etcd.conf\n```\n\n## etcdctl 操作\n\n### K-V 操作\n\n```shell\n$  etcdctl put [KEY] [VALUE]\n$  etcdctl get [KEY]\n$  etcdctl del [KEY]\n```\n\n### 监听K-V变化\n\n会阻塞\n\n```shell\n$  etcdctl watch [KEY]\n```\n\n### 事务操作\n\n```shell\n$  etcdctl txn -i\ncompares:                           # 条件判断\nvalue(\"[KEY]\") = \"[VALUE]\"\ncreate(\"[KEY]\") = \"[VERSION]\"\nmod(\"[KEY]\") = \"[VERSION]\"\n...\nsuccess requests (get, put, del):   # 条件成立\nK-V 操作...\nfailure requests (get, put, del):   # 条件不成立\nK-V 操作...\n```\n\n### 租约 \n\n统一管理拥有相同TTL的K-V数据, TTL单位为秒\n\n```shell\n$  etcdctl lease grant [DURATION]\nlease 694d82dfbbb06c04 granted with TTL(30s)    # 返回租约的hash值\n$  etcdctl put [KEY] [VALUE] --lease=694d82dfbbb06c04\n```\n\n## 基于etcd实现分布式锁\n\n`go.etcd.io/etcd/clientv3/concurrency` 包在etcd之上实现并发操作，如分布式锁、屏障和选举。\n\n```go\nimport \"go.etcd.io/etcd/clientv3/concurrency\"\n\ncli, err := clientv3.New(clientv3.Config{Endpoints: endpoints})\nif err != nil {\n    log.Fatal(err)\n}\ndefer cli.Close()\n\n// 创建两个单独的会话用来演示锁竞争\ns1, err := concurrency.NewSession(cli)\nif err != nil {\n    log.Fatal(err)\n}\ndefer s1.Close()\nm1 := concurrency.NewMutex(s1, \"/my-lock/\")\n\ns2, err := concurrency.NewSession(cli)\nif err != nil {\n    log.Fatal(err)\n}\ndefer s2.Close()\nm2 := concurrency.NewMutex(s2, \"/my-lock/\")\n\n// 会话s1获取锁\nif err := m1.Lock(context.TODO()); err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"acquired lock for s1\")\n\nm2Locked := make(chan struct{})\ngo func() {\n    defer close(m2Locked)\n    // 等待直到会话s1释放了/my-lock/的锁\n    if err := m2.Lock(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}()\n\nif err := m1.Unlock(context.TODO()); err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"released lock for s1\")\n\n<-m2Locked\nfmt.Println(\"acquired lock for s2\")\n```\n\n输出：\n\n```shell\nacquired lock for s1\nreleased lock for s1\nacquired lock for s2\n```\n\n[详细文档](https://pkg.go.dev/go.etcd.io/etcd/clientv3/concurrency)\n","source":"_posts/Etcd-学习.md","raw":"---\ntitle: Etcd 学习\nabbrlink: 26cc52b5\ndate: 2022-09-08 11:25:32\ntags: \n    - 微服务\n    - 分布式\n    - Raft\ncategories: \n    - 微服务\n    - 分布式\n---\n\n# Etcd 学习\n\n> 适用于共享配置、服务发现、分布式锁、集群监控、leader选举\n\n![](./Etcd-学习/architecture.png)\n\n[下载地址](https://github.com/etcd-io/etcd/releases)\n\n[Go操作etcd](https://www.liwenzhou.com/posts/Go/go_etcd/#autoid-1-5-0)\n\n\n## Install\n\n```shell\n$  tar -zxvf etcd-v3.4.20-linux-amd64.tar.gz\n$  cd etcd-v3.4.20-linux-amd64/ \n$  cp etcd etcdctl /usr/local/bin\n```\n\n### 检查安装\n\n```shell\n$  etcd --version\netcd Version: 3.4.20\nGit SHA: 1e26823\nGo Version: go1.16.15\nGo OS/Arch: linux/amd64\n\n$  etcdctl version\netcdctl version: 3.4.20\nAPI version: 3.4\n```\n\n## 启动\n\n```shell\n$  etcd --listen-client-urls 'http://0.0.0.0:2379' --advertise-client-urls 'http://0.0.0.0:2379'\n```\n\n## 修改配置\n\n### 远程访问\n\n```shell\n# 修改/etc/etcd/etcd.conf配置：\n$  ETCD_LISTEN_CLIENT_URLS=\"http://10.103.18.41:2379,http://localhost:2379\"\n$  etcd --config-file=etcd.conf\n```\n\n## etcdctl 操作\n\n### K-V 操作\n\n```shell\n$  etcdctl put [KEY] [VALUE]\n$  etcdctl get [KEY]\n$  etcdctl del [KEY]\n```\n\n### 监听K-V变化\n\n会阻塞\n\n```shell\n$  etcdctl watch [KEY]\n```\n\n### 事务操作\n\n```shell\n$  etcdctl txn -i\ncompares:                           # 条件判断\nvalue(\"[KEY]\") = \"[VALUE]\"\ncreate(\"[KEY]\") = \"[VERSION]\"\nmod(\"[KEY]\") = \"[VERSION]\"\n...\nsuccess requests (get, put, del):   # 条件成立\nK-V 操作...\nfailure requests (get, put, del):   # 条件不成立\nK-V 操作...\n```\n\n### 租约 \n\n统一管理拥有相同TTL的K-V数据, TTL单位为秒\n\n```shell\n$  etcdctl lease grant [DURATION]\nlease 694d82dfbbb06c04 granted with TTL(30s)    # 返回租约的hash值\n$  etcdctl put [KEY] [VALUE] --lease=694d82dfbbb06c04\n```\n\n## 基于etcd实现分布式锁\n\n`go.etcd.io/etcd/clientv3/concurrency` 包在etcd之上实现并发操作，如分布式锁、屏障和选举。\n\n```go\nimport \"go.etcd.io/etcd/clientv3/concurrency\"\n\ncli, err := clientv3.New(clientv3.Config{Endpoints: endpoints})\nif err != nil {\n    log.Fatal(err)\n}\ndefer cli.Close()\n\n// 创建两个单独的会话用来演示锁竞争\ns1, err := concurrency.NewSession(cli)\nif err != nil {\n    log.Fatal(err)\n}\ndefer s1.Close()\nm1 := concurrency.NewMutex(s1, \"/my-lock/\")\n\ns2, err := concurrency.NewSession(cli)\nif err != nil {\n    log.Fatal(err)\n}\ndefer s2.Close()\nm2 := concurrency.NewMutex(s2, \"/my-lock/\")\n\n// 会话s1获取锁\nif err := m1.Lock(context.TODO()); err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"acquired lock for s1\")\n\nm2Locked := make(chan struct{})\ngo func() {\n    defer close(m2Locked)\n    // 等待直到会话s1释放了/my-lock/的锁\n    if err := m2.Lock(context.TODO()); err != nil {\n        log.Fatal(err)\n    }\n}()\n\nif err := m1.Unlock(context.TODO()); err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"released lock for s1\")\n\n<-m2Locked\nfmt.Println(\"acquired lock for s2\")\n```\n\n输出：\n\n```shell\nacquired lock for s1\nreleased lock for s1\nacquired lock for s2\n```\n\n[详细文档](https://pkg.go.dev/go.etcd.io/etcd/clientv3/concurrency)\n","slug":"Etcd-学习","published":1,"updated":"2022-09-08T05:41:11.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjf0003ecwd26x95sa3","content":"<h1 id=\"Etcd-学习\"><a href=\"#Etcd-学习\" class=\"headerlink\" title=\"Etcd 学习\"></a>Etcd 学习</h1><blockquote>\n<p>适用于共享配置、服务发现、分布式锁、集群监控、leader选举</p>\n</blockquote>\n<p><img src=\"/post/26cc52b5/architecture.png\"></p>\n<p><a href=\"https://github.com/etcd-io/etcd/releases\">下载地址</a></p>\n<p><a href=\"https://www.liwenzhou.com/posts/Go/go_etcd/#autoid-1-5-0\">Go操作etcd</a></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> tar -zxvf etcd-v3.4.20-linux-amd64.tar.gz</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> etcd-v3.4.20-linux-amd64/</span> </span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> <span class=\"built_in\">cp</span> etcd etcdctl /usr/local/bin</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检查安装\"><a href=\"#检查安装\" class=\"headerlink\" title=\"检查安装\"></a>检查安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --version</span></span><br><span class=\"line\">etcd Version: 3.4.20</span><br><span class=\"line\">Git SHA: 1e26823</span><br><span class=\"line\">Go Version: go1.16.15</span><br><span class=\"line\">Go OS/Arch: linux/amd64</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl version</span></span><br><span class=\"line\">etcdctl version: 3.4.20</span><br><span class=\"line\">API version: 3.4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --listen-client-urls <span class=\"string\">&#x27;http://0.0.0.0:2379&#x27;</span> --advertise-client-urls <span class=\"string\">&#x27;http://0.0.0.0:2379&#x27;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h2><h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">修改/etc/etcd/etcd.conf配置：</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> ETCD_LISTEN_CLIENT_URLS=<span class=\"string\">&quot;http://10.103.18.41:2379,http://localhost:2379&quot;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --config-file=etcd.conf</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"etcdctl-操作\"><a href=\"#etcdctl-操作\" class=\"headerlink\" title=\"etcdctl 操作\"></a>etcdctl 操作</h2><h3 id=\"K-V-操作\"><a href=\"#K-V-操作\" class=\"headerlink\" title=\"K-V 操作\"></a>K-V 操作</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl put [KEY] [VALUE]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl get [KEY]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl del [KEY]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听K-V变化\"><a href=\"#监听K-V变化\" class=\"headerlink\" title=\"监听K-V变化\"></a>监听K-V变化</h3><p>会阻塞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl watch [KEY]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl txn -i</span></span><br><span class=\"line\">compares:                           # 条件判断</span><br><span class=\"line\">value(&quot;[KEY]&quot;) = &quot;[VALUE]&quot;</span><br><span class=\"line\">create(&quot;[KEY]&quot;) = &quot;[VERSION]&quot;</span><br><span class=\"line\">mod(&quot;[KEY]&quot;) = &quot;[VERSION]&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">success requests (get, put, del):   # 条件成立</span><br><span class=\"line\">K-V 操作...</span><br><span class=\"line\">failure requests (get, put, del):   # 条件不成立</span><br><span class=\"line\">K-V 操作...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"租约\"><a href=\"#租约\" class=\"headerlink\" title=\"租约\"></a>租约</h3><p>统一管理拥有相同TTL的K-V数据, TTL单位为秒</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl lease grant [DURATION]</span></span><br><span class=\"line\">lease 694d82dfbbb06c04 granted with TTL(30s)    # 返回租约的hash值</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl put [KEY] [VALUE] --lease=694d82dfbbb06c04</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基于etcd实现分布式锁\"><a href=\"#基于etcd实现分布式锁\" class=\"headerlink\" title=\"基于etcd实现分布式锁\"></a>基于etcd实现分布式锁</h2><p><code>go.etcd.io/etcd/clientv3/concurrency</code> 包在etcd之上实现并发操作，如分布式锁、屏障和选举。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go.etcd.io/etcd/clientv3/concurrency&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">cli, err := clientv3.New(clientv3.Config&#123;Endpoints: endpoints&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> cli.Close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建两个单独的会话用来演示锁竞争</span></span><br><span class=\"line\">s1, err := concurrency.NewSession(cli)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> s1.Close()</span><br><span class=\"line\">m1 := concurrency.NewMutex(s1, <span class=\"string\">&quot;/my-lock/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s2, err := concurrency.NewSession(cli)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> s2.Close()</span><br><span class=\"line\">m2 := concurrency.NewMutex(s2, <span class=\"string\">&quot;/my-lock/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会话s1获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := m1.Lock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;acquired lock for s1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">m2Locked := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(m2Locked)</span><br><span class=\"line\">    <span class=\"comment\">// 等待直到会话s1释放了/my-lock/的锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := m2.Lock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := m1.Unlock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;released lock for s1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-m2Locked</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;acquired lock for s2&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acquired lock for s1</span><br><span class=\"line\">released lock for s1</span><br><span class=\"line\">acquired lock for s2</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://pkg.go.dev/go.etcd.io/etcd/clientv3/concurrency\">详细文档</a></p>\n","site":{"data":{}},"cover":"/img/c6.jpg","excerpt":"","more":"<h1 id=\"Etcd-学习\"><a href=\"#Etcd-学习\" class=\"headerlink\" title=\"Etcd 学习\"></a>Etcd 学习</h1><blockquote>\n<p>适用于共享配置、服务发现、分布式锁、集群监控、leader选举</p>\n</blockquote>\n<p><img src=\"/post/26cc52b5/architecture.png\"></p>\n<p><a href=\"https://github.com/etcd-io/etcd/releases\">下载地址</a></p>\n<p><a href=\"https://www.liwenzhou.com/posts/Go/go_etcd/#autoid-1-5-0\">Go操作etcd</a></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> tar -zxvf etcd-v3.4.20-linux-amd64.tar.gz</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> <span class=\"built_in\">cd</span> etcd-v3.4.20-linux-amd64/</span> </span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> <span class=\"built_in\">cp</span> etcd etcdctl /usr/local/bin</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"检查安装\"><a href=\"#检查安装\" class=\"headerlink\" title=\"检查安装\"></a>检查安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --version</span></span><br><span class=\"line\">etcd Version: 3.4.20</span><br><span class=\"line\">Git SHA: 1e26823</span><br><span class=\"line\">Go Version: go1.16.15</span><br><span class=\"line\">Go OS/Arch: linux/amd64</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl version</span></span><br><span class=\"line\">etcdctl version: 3.4.20</span><br><span class=\"line\">API version: 3.4</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --listen-client-urls <span class=\"string\">&#x27;http://0.0.0.0:2379&#x27;</span> --advertise-client-urls <span class=\"string\">&#x27;http://0.0.0.0:2379&#x27;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h2><h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">修改/etc/etcd/etcd.conf配置：</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> ETCD_LISTEN_CLIENT_URLS=<span class=\"string\">&quot;http://10.103.18.41:2379,http://localhost:2379&quot;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcd --config-file=etcd.conf</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"etcdctl-操作\"><a href=\"#etcdctl-操作\" class=\"headerlink\" title=\"etcdctl 操作\"></a>etcdctl 操作</h2><h3 id=\"K-V-操作\"><a href=\"#K-V-操作\" class=\"headerlink\" title=\"K-V 操作\"></a>K-V 操作</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl put [KEY] [VALUE]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl get [KEY]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl del [KEY]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听K-V变化\"><a href=\"#监听K-V变化\" class=\"headerlink\" title=\"监听K-V变化\"></a>监听K-V变化</h3><p>会阻塞</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl watch [KEY]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl txn -i</span></span><br><span class=\"line\">compares:                           # 条件判断</span><br><span class=\"line\">value(&quot;[KEY]&quot;) = &quot;[VALUE]&quot;</span><br><span class=\"line\">create(&quot;[KEY]&quot;) = &quot;[VERSION]&quot;</span><br><span class=\"line\">mod(&quot;[KEY]&quot;) = &quot;[VERSION]&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">success requests (get, put, del):   # 条件成立</span><br><span class=\"line\">K-V 操作...</span><br><span class=\"line\">failure requests (get, put, del):   # 条件不成立</span><br><span class=\"line\">K-V 操作...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"租约\"><a href=\"#租约\" class=\"headerlink\" title=\"租约\"></a>租约</h3><p>统一管理拥有相同TTL的K-V数据, TTL单位为秒</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl lease grant [DURATION]</span></span><br><span class=\"line\">lease 694d82dfbbb06c04 granted with TTL(30s)    # 返回租约的hash值</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"> etcdctl put [KEY] [VALUE] --lease=694d82dfbbb06c04</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基于etcd实现分布式锁\"><a href=\"#基于etcd实现分布式锁\" class=\"headerlink\" title=\"基于etcd实现分布式锁\"></a>基于etcd实现分布式锁</h2><p><code>go.etcd.io/etcd/clientv3/concurrency</code> 包在etcd之上实现并发操作，如分布式锁、屏障和选举。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go.etcd.io/etcd/clientv3/concurrency&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">cli, err := clientv3.New(clientv3.Config&#123;Endpoints: endpoints&#125;)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> cli.Close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建两个单独的会话用来演示锁竞争</span></span><br><span class=\"line\">s1, err := concurrency.NewSession(cli)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> s1.Close()</span><br><span class=\"line\">m1 := concurrency.NewMutex(s1, <span class=\"string\">&quot;/my-lock/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s2, err := concurrency.NewSession(cli)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">defer</span> s2.Close()</span><br><span class=\"line\">m2 := concurrency.NewMutex(s2, <span class=\"string\">&quot;/my-lock/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会话s1获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := m1.Lock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;acquired lock for s1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">m2Locked := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(m2Locked)</span><br><span class=\"line\">    <span class=\"comment\">// 等待直到会话s1释放了/my-lock/的锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := m2.Lock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := m1.Unlock(context.TODO()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;released lock for s1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-m2Locked</span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;acquired lock for s2&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acquired lock for s1</span><br><span class=\"line\">released lock for s1</span><br><span class=\"line\">acquired lock for s2</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://pkg.go.dev/go.etcd.io/etcd/clientv3/concurrency\">详细文档</a></p>\n"},{"title":"GFS-解读","abbrlink":"f2b485e3","date":"2022-09-10T02:49:33.000Z","_content":"\n# GFS 解读\n\n>   Google File System\n>\n>   GFS是为对数据敏感的大型分布式系统所设计的，可伸缩的分布式文件系统。它建立在普通商用电脑上，提供容错机制的同时也能在大量客户端接入的时候保持极高的平均性能。\n\n## 设计思想\n\n经过长期观察，GFS在设计上和传统分布式文件系统相比，有4个不同的考虑重点。\n\n1.   出错是常态。\n\n​\t\t\t\t分布式文件系统将几千台普通机器的硬盘连接到一起提供存储服务。良好的设计应该假设这些硬盘会随时出错并且不能恢复。软件bug，OS bug，操作\t失误，硬盘损坏，内存，网络出错，甚至停电都会导致整个系统瘫痪。因此，随时监控，错误检测，容错和自动恢复是分布式文件系统的核心。\n\n2.   大文件是常态，GB级的文件是主流。\n\n​\t   因此，必须在设计阶段重新考虑方案和参数，比如，IO操作的类型和块大小。GFS虽然支持小文件存储，但不需要太在意效率。\n\n3.   文件追加写是常态，而不是覆盖写。\n\n​\t   \t文件的随机写是不存在的，一旦开始写入文件，要么只能读，要么顺序写。读又分为大规模的流式读取或小规模的随机读取。流式读取主要是同一个客户端\t不间断的顺序读同一个文件，每次都读数百KB或MB级的数据。随机读取，发生在读取一个文件任意位置，每次只读几KB的数据。应用程序本身也是通过顺序\t的批量读取和排序来提升系统性能的稳定性，来回反复的去读一个文件是不可取的。写入和读取类似，主要考虑大规模的顺序写。虽然在任意位置的小规模写入\t是支持的，但效率极低。\n\n4.   文件数据追加写的性能和原子性是核心考量。\n\n​\t\t\tGFS上的文件本身经常被用作生产者-消费者队列或多路归并。因此，多客户端（生产者）并发写的同步性能是核心指标。毕竟，随时都会有其他客户\t\t（消费者）同时去读取这些最新写入的数据。\n\n5.   将文件系统和应用程序放在一起设计，以提升弹性。\n\n​\t\t\t比如，**GFS放松了对一致性的要求**，以简化应用的开发。**GFS提供原子化的追加写操作**，免去了客户端处理同步的逻辑等。**持续的高带宽并低延迟更重\t要**，应用程序更关注对数据的高速率处理，而并不关注单次读写的响应时间。\n\n6.   独到的接口设计\n\n     ​\t\t虽然GFS的API设计并不严格遵守POSIX，但大体类似。文件以目录的形式分层组织，使用路径命名。支持create，delete，open，close，read和write操作。除此之外，GFS还提供snapshot和record append功能。Snapshot可以低代价的创建一份文件或目录树的拷贝。Record append提供原子性的append操作，供多个客户端并发写而不用额外加锁。\n\n## 设计架构\n\n![](GFS-解读/arch.jpg)\n\n+   一个GFS集群包含一个单独的Master节点（译注：这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件）、多台Chunk服务器，并且同时被多个客户端访问，如上图所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。\n\n+   GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，**Master服务器会给每个Chunk分配一个不变的、全球唯一的64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。**出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。\n\n+   Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。\n\n+   Master节点还管理着系统范围内的活动，比如，Chunk租用管理、孤儿Chunk(注：orphaned chunks)的回收、以及Chunk在Chunk服务器之间的迁移。\n\n+   Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。\n\n+   无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。\n\n\n\n## 单一Master节点\n单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，**我们必须减少对Master节点的读写**，避免Master节点成为系统的瓶颈。**客户端并不通过Master节点读写文件数据**。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将**直接和Chunk服务器进行数据读写操作**。\n\n我们利用图1解释一下一次简单读取的流程。\n\n+   首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引。\n\n+   然后，它把文件名和Chunk索引发送给Master节点。\n\n+   Master节点将相应的Chunk标识和副本的位置信息发还给客户端。\n\n+   客户端用文件名和Chunk索引作为key缓存这些信息。\n\n+   之后客户端发送请求到其中的一个副本处，一般会选择最近的。\n\n+   请求信息包含了Chunk的标识和字节范围。\n\n+   在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。\n\n实际上，客户端通常会在一次请求中查询多个Chunk信息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和Master节点未来可能会发生的几次通讯。\n\n### Master节点操作\n\n+   命名空间管理\n\n      \t\t**命名空间的修改通过锁保证为原子性的。**\n      \t\n      \t\t在逻辑上，GFS 的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构\t   \t上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。采用这种锁方案的优点是支持对同一目录的并行操作，比如，每一个文件操作需\t要获取父目录读锁和目标文件写锁。目录名的读取锁防止目录被删除、 改名以及被快照。\n\n​\t\t\t**如何避免死锁？**\n\n​\t\t\t锁的获取依据全局一致的顺序，先按名字空间层次排序，同一层次按字典序排序\n\n+   副本位置分布  \n\n    \t\tGFS中chunk以多副本存储，以提高数据可靠性。一个好的副本位置定义算法满足下面特性：\n\n1.   最大化数据可靠性，例如，不能将所有副本存放在同一个磁盘或者物理机器上；\n2.   最大化网络带宽利用率，有效利用多个机架的整合带宽\n\n+   Chunk的创建、负载均衡   \n\n      \t\t当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本，需要考虑以下几个因素：\n\n1.   选择存储空间利用率最低的节点和磁盘；\n2.   选择最近一段时间内新建chunk数量较少的节点和磁盘；\n3.   将多个副本分散在不同的机架上。\n\n+   垃圾回收 \n\n      \t\t所有 Master 节点不能识别的副本都是“垃圾”。我们很容易能得到 Chunk 的所有引用: 它们都只存储在 Master 服务器上的文件到chunk的映射表中。 我们也可以得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 \n      \t\n      \t\tGFS 在文件删除后不会立刻回收可用的物理空间，空间回收采用惰性的策略，周期性的常规垃圾扫描才回收物理空间，并在 Master 节点相对空闲的时候完成。\n      \t\n      \t\t具体流程：Client提交文件删除操作，Master将删除操作记录到日志，并将对应文件名改为包含删除时间戳的隐藏文件名（改名字，并没有回收物理空间。Master周期性对名字空间做常规垃圾扫描，会在名字空间中删除3天前（时间可配置）的隐藏文件及元数据。ChunkServer在与Master的心跳信息中，得知哪些Chunk的元数据不存在了，便可实际回收其物理空间。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关元数据才会被删除，这也有效的切断了文件和它包含的所有 Chunk 的连接。  \n      \t\n      \t\t 优点：设计简单，批量执行，防误删\n      \t\n      \t\t缺点：存储的开销，阻碍用户调优存储空间使用，特别是当存储空间比较紧缺的时候。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的移除。\n\n## Chunk尺寸\nChunk的大小是关键的设计参数之一。\n\n我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。\n\n惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。选择较大的Chunk尺寸有几个重要的优点。\n\n+   **首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。**这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信息。\n+   **其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。**\n+   **第三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量**。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部放在内存中带来的额外的好处。\n\n**另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷：** 小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。\n\n在实际应用中，由于我们的程序通常是连续的读取包含多个Chunk的大文件，热点还不是主要的问题。\n\n然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。\n\n我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。**一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。**\n\n## 元数据\nMaster服务器（注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储3种主要类型的元数据，包括：\n\n+   文件和Chunk的命名空间\n+   文件和Chunk的对应关系\n+   每个Chunk副本的存放地点\n\n所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。\n\n**采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。**\n\n**<u>Master服务器不会持久保存Chunk位置信息。</u>**Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。\n\n### 元数据结构\n\n因为元数据保存在内存中，所以Master服务器的操作速度非常快。Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。\n\n并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现：\n\n+   Chunk垃圾收集\n+   在Chunk服务器失效的时重新复制数据通过Chunk的迁移实现\n+   跨Chunk服务器的负载均衡\n+   磁盘使用状况统计等功能\n\n### Chunk 位置信息\n\n**Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。**\n\n**Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。**\n\n### 日志\n\n操作日志包含了关键的元数据变更历史记录。\n\n这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线；文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。 \n\n把**日志复制到多台远程机器**，并且**只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求**。\n\n为了缩短Master启动的时间，我们必须**使日志足够小**（注：即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次**Checkpoint**，Checkpoint文件以**压缩B-树**形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。\n\n## 数据、控制流\n\n![](GFS-解读/react.jpg)\n\n+   读取流：\n    1.   client本地计算根据offset计算出chunk index，以file name+chunk index联系master，获取三个chunk副本的handle、localtion信息；\n    2.   client联系任意一个chunk，读取对应的数据；\n\n\n\n+   写入流：\n    1.   client联系master，获取到chunk的handle、localtion信息、主备身份信息；\n    2.   client将data发给任意一个chunk，该chunk将data转发给其他chunk；\n    3.   当三个chunk都成功将data写入内存，client给primary发送commit请求；\n    4.   primary将数据落到本地log中，然后发送commit请求给其他replica。\n    5.   当primary收到其他replica写入成功的回复后，返回client success。\n\n## 一致性模型\n\n<img src=\"GFS-解读/cons.png\"  />\n\n### 写入接口与文件状态\n\n+   GFS将写操作分为两种：\n    1.   write。允许用户指定offset，进行随机写。\n    2.   record append。不允许用户指定offset，只能不断往后append写。但是要注意的是这里的append与我们通常所说的在linux fs上append一个文件不同。平常所说在linux fs上append，就是指seek到文件末尾，然后将data写在末尾的下一个byte。而gfs的append，并不保证data会写到文件末尾的下一个byte中，而是由GFS内部选定一个位置写进去，然后把这个位置的offset作为返回值返回给用户。唯一能保证的是：这个GFS内部选定的位置offset，的确在末尾以后，但是可能并不直接与末尾相邻，中间可能夹杂着failed的、duplicated的数据碎片。具体原因我们在后面解释。\n\n+   GFS将文件状态分为两种：\n    1.   consistent。也就是一个chunk的多个replica，彼此之间数据一致。\n    2.   defined。不仅多个replica彼此之间数据一致（也即consistent），而且replica中的data与某一个用户写入的data保持一致。这句话比较难理解：replica中的数据怎么会跟用户写入的数据不一致呢？\n\n\n\n**无论是串行write还是并行write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent;**\n\n**对于append操作，客户端无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端，因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。对于如果append第一次失败，导致多副本在原offset的数据可能不一致，但接下来重试成功，使得在新offset之间的数据一致，因此，其状态是interspersed with inconsistent（部分不一致）。**\n\n### 租约（Lease）\n\nMaster 节点为 Chunk 的一个Replica建立一个 Lease,这个副本叫做Primary, Primary对 Chunk 的所有更改操作进行序列化,所有的副本都遵从这个序列进行修改操作。\n\n+   首先为保持Client操作时系统的一致性，Client 需要向 Master 节点询问哪一个 Chunk Server持有指定 Chunk 的 Lease以及其他副本的位置,如果没有就选择其中一个副本建一个 Lease，所有的操作必须在一个Lease 内\n+   在租约有效期内： master联系不到Primary，客户端可以联系到Primary。对于修改操作顺序都一致,并没有影响，\n+   在租约有效期内：master联系不到Primary, 客户端不可以联系到Primary。对于修改操作所有的操作全都失败，但并不会影响数据的一致性（因为没有数据写入，全部返回失败）\n+   当租约失效：master重新选择Primary, 不论客户端联不联系到Primary, 操作都不会受影响（假设联系到原先的chunk,客户端会被告知，其租约已失效，重新到master中获取新的主chunk信息，若在过期前一直联系不到Primary, 到过期后（客户端缓存过期时间）会从新从主master拉取信息）。\n\n**租约机制确保写入的顺序性，并有效的减轻了master的负担，另一方面有效避免了分布式系统中发生 <u>脑裂(split-brain)</u> 的情况**\n\n## **7、快照（snapshot）**\n\n-   快照对系统当前状态进行的一次拍照，用户可以在任意时刻回滚到快照的状态，GFS使用Copy-On-Write技术实现Snapshot。\n-   Master节点收到客户端的快照请求时，Master并没有立即对指定Chunk拷贝，而只拷贝其元数据并对指定Chunk的引用计数增1，等到Client需要修改指定Chunk时，再在本地复制，并却保新Chunk拥有租约。\n\n   具体流程是： \n\n-   收回Snapshot请求覆盖的文件chunk上的租约；\n-   操作元数据完成元数据拷贝；\n-   客户端要写入该文件的Chunk时，Master通知该Chunk所在ChunkServer进行本地拷贝，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；\n-   发放租约给拷贝Chunk；\n-   返回拷贝Chunk的位置信息，接下来客户端的更新流程与正常的没有区别。\n\n## **8、容错**\n\n#### 1）高可用性\n\n-    遵循的2个简单策略：1 快速恢复 2 复制\n\n-   快速恢复：Master或ChunkServer关闭（正常/异常），都被设计在数秒内可恢复状态并重启。Client和其他服务器发现请求超时，会重连重启的Server\n\n-   Chunk的复制：当ChunkServer关闭或Chksum校验出损坏的Chunk副本，Master都会通过复制已有Chunk副本来保障副本个数 \n\n-   Master的复制：CheckPoint文件+操作日志完成Master的恢复。此外，GFS还有些“影子”Master，在Master宕机时提供GFS的只读访问\n\n####   2）数据完整性    \n\n-   -   每个ChunkServer独立维护Checksum来校验自己副本的完整性，每个Chunk块都对应一个32位的Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。\n\n        独立维护原因：\n\n        -   跨Chunk服务器比较副本开销大；\n        -   追加操作可能造成数据的字节级别不一致，无法通过比较副本判断完整性。\n\n-   对读操作，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的checksum, 当checksum校验到数据不正确，ChunkServer会做两件事：1、返回给Client错误信息，让Client读取其他Chunk副本  2、通知Master，请求Chunk副本复制\n-   当ChunkServer空闲时，其会周期性扫描不活动的Chunk块，检验数据完整性 \n-   读操作的Checksum：只取Chunk小部分额外相关数据进行校验，客户端每次把读取操作对齐在Chunk块的边界上\n-   记录追加操作的Checksum（高度优化）：只增量更新最后一个不完整Chunk块的Checksum\n-   写操作的Checksum：先读取和校验被写操作覆盖的第一个和最后一个Chunk块，写操作完成后再重新计算和写入Chunksum\n\n","source":"_posts/GFS-解读.md","raw":"---\ntitle: GFS-解读\ntags:\n  - 分布式\n  - 文件系统\n  - 存储\ncategories:\n  - MIT 6.824\nabbrlink: f2b485e3\ndate: 2022-09-10 10:49:33\n---\n\n# GFS 解读\n\n>   Google File System\n>\n>   GFS是为对数据敏感的大型分布式系统所设计的，可伸缩的分布式文件系统。它建立在普通商用电脑上，提供容错机制的同时也能在大量客户端接入的时候保持极高的平均性能。\n\n## 设计思想\n\n经过长期观察，GFS在设计上和传统分布式文件系统相比，有4个不同的考虑重点。\n\n1.   出错是常态。\n\n​\t\t\t\t分布式文件系统将几千台普通机器的硬盘连接到一起提供存储服务。良好的设计应该假设这些硬盘会随时出错并且不能恢复。软件bug，OS bug，操作\t失误，硬盘损坏，内存，网络出错，甚至停电都会导致整个系统瘫痪。因此，随时监控，错误检测，容错和自动恢复是分布式文件系统的核心。\n\n2.   大文件是常态，GB级的文件是主流。\n\n​\t   因此，必须在设计阶段重新考虑方案和参数，比如，IO操作的类型和块大小。GFS虽然支持小文件存储，但不需要太在意效率。\n\n3.   文件追加写是常态，而不是覆盖写。\n\n​\t   \t文件的随机写是不存在的，一旦开始写入文件，要么只能读，要么顺序写。读又分为大规模的流式读取或小规模的随机读取。流式读取主要是同一个客户端\t不间断的顺序读同一个文件，每次都读数百KB或MB级的数据。随机读取，发生在读取一个文件任意位置，每次只读几KB的数据。应用程序本身也是通过顺序\t的批量读取和排序来提升系统性能的稳定性，来回反复的去读一个文件是不可取的。写入和读取类似，主要考虑大规模的顺序写。虽然在任意位置的小规模写入\t是支持的，但效率极低。\n\n4.   文件数据追加写的性能和原子性是核心考量。\n\n​\t\t\tGFS上的文件本身经常被用作生产者-消费者队列或多路归并。因此，多客户端（生产者）并发写的同步性能是核心指标。毕竟，随时都会有其他客户\t\t（消费者）同时去读取这些最新写入的数据。\n\n5.   将文件系统和应用程序放在一起设计，以提升弹性。\n\n​\t\t\t比如，**GFS放松了对一致性的要求**，以简化应用的开发。**GFS提供原子化的追加写操作**，免去了客户端处理同步的逻辑等。**持续的高带宽并低延迟更重\t要**，应用程序更关注对数据的高速率处理，而并不关注单次读写的响应时间。\n\n6.   独到的接口设计\n\n     ​\t\t虽然GFS的API设计并不严格遵守POSIX，但大体类似。文件以目录的形式分层组织，使用路径命名。支持create，delete，open，close，read和write操作。除此之外，GFS还提供snapshot和record append功能。Snapshot可以低代价的创建一份文件或目录树的拷贝。Record append提供原子性的append操作，供多个客户端并发写而不用额外加锁。\n\n## 设计架构\n\n![](GFS-解读/arch.jpg)\n\n+   一个GFS集群包含一个单独的Master节点（译注：这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件）、多台Chunk服务器，并且同时被多个客户端访问，如上图所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。\n\n+   GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，**Master服务器会给每个Chunk分配一个不变的、全球唯一的64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。**出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。\n\n+   Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。\n\n+   Master节点还管理着系统范围内的活动，比如，Chunk租用管理、孤儿Chunk(注：orphaned chunks)的回收、以及Chunk在Chunk服务器之间的迁移。\n\n+   Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。\n\n+   无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。\n\n\n\n## 单一Master节点\n单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，**我们必须减少对Master节点的读写**，避免Master节点成为系统的瓶颈。**客户端并不通过Master节点读写文件数据**。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将**直接和Chunk服务器进行数据读写操作**。\n\n我们利用图1解释一下一次简单读取的流程。\n\n+   首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引。\n\n+   然后，它把文件名和Chunk索引发送给Master节点。\n\n+   Master节点将相应的Chunk标识和副本的位置信息发还给客户端。\n\n+   客户端用文件名和Chunk索引作为key缓存这些信息。\n\n+   之后客户端发送请求到其中的一个副本处，一般会选择最近的。\n\n+   请求信息包含了Chunk的标识和字节范围。\n\n+   在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。\n\n实际上，客户端通常会在一次请求中查询多个Chunk信息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和Master节点未来可能会发生的几次通讯。\n\n### Master节点操作\n\n+   命名空间管理\n\n      \t\t**命名空间的修改通过锁保证为原子性的。**\n      \t\n      \t\t在逻辑上，GFS 的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构\t   \t上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。采用这种锁方案的优点是支持对同一目录的并行操作，比如，每一个文件操作需\t要获取父目录读锁和目标文件写锁。目录名的读取锁防止目录被删除、 改名以及被快照。\n\n​\t\t\t**如何避免死锁？**\n\n​\t\t\t锁的获取依据全局一致的顺序，先按名字空间层次排序，同一层次按字典序排序\n\n+   副本位置分布  \n\n    \t\tGFS中chunk以多副本存储，以提高数据可靠性。一个好的副本位置定义算法满足下面特性：\n\n1.   最大化数据可靠性，例如，不能将所有副本存放在同一个磁盘或者物理机器上；\n2.   最大化网络带宽利用率，有效利用多个机架的整合带宽\n\n+   Chunk的创建、负载均衡   \n\n      \t\t当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本，需要考虑以下几个因素：\n\n1.   选择存储空间利用率最低的节点和磁盘；\n2.   选择最近一段时间内新建chunk数量较少的节点和磁盘；\n3.   将多个副本分散在不同的机架上。\n\n+   垃圾回收 \n\n      \t\t所有 Master 节点不能识别的副本都是“垃圾”。我们很容易能得到 Chunk 的所有引用: 它们都只存储在 Master 服务器上的文件到chunk的映射表中。 我们也可以得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 \n      \t\n      \t\tGFS 在文件删除后不会立刻回收可用的物理空间，空间回收采用惰性的策略，周期性的常规垃圾扫描才回收物理空间，并在 Master 节点相对空闲的时候完成。\n      \t\n      \t\t具体流程：Client提交文件删除操作，Master将删除操作记录到日志，并将对应文件名改为包含删除时间戳的隐藏文件名（改名字，并没有回收物理空间。Master周期性对名字空间做常规垃圾扫描，会在名字空间中删除3天前（时间可配置）的隐藏文件及元数据。ChunkServer在与Master的心跳信息中，得知哪些Chunk的元数据不存在了，便可实际回收其物理空间。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关元数据才会被删除，这也有效的切断了文件和它包含的所有 Chunk 的连接。  \n      \t\n      \t\t 优点：设计简单，批量执行，防误删\n      \t\n      \t\t缺点：存储的开销，阻碍用户调优存储空间使用，特别是当存储空间比较紧缺的时候。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的移除。\n\n## Chunk尺寸\nChunk的大小是关键的设计参数之一。\n\n我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。\n\n惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。选择较大的Chunk尺寸有几个重要的优点。\n\n+   **首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。**这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信息。\n+   **其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。**\n+   **第三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量**。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部放在内存中带来的额外的好处。\n\n**另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷：** 小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。\n\n在实际应用中，由于我们的程序通常是连续的读取包含多个Chunk的大文件，热点还不是主要的问题。\n\n然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。\n\n我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。**一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。**\n\n## 元数据\nMaster服务器（注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储3种主要类型的元数据，包括：\n\n+   文件和Chunk的命名空间\n+   文件和Chunk的对应关系\n+   每个Chunk副本的存放地点\n\n所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。\n\n**采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。**\n\n**<u>Master服务器不会持久保存Chunk位置信息。</u>**Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。\n\n### 元数据结构\n\n因为元数据保存在内存中，所以Master服务器的操作速度非常快。Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。\n\n并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现：\n\n+   Chunk垃圾收集\n+   在Chunk服务器失效的时重新复制数据通过Chunk的迁移实现\n+   跨Chunk服务器的负载均衡\n+   磁盘使用状况统计等功能\n\n### Chunk 位置信息\n\n**Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。**\n\n**Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。**\n\n### 日志\n\n操作日志包含了关键的元数据变更历史记录。\n\n这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线；文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。 \n\n把**日志复制到多台远程机器**，并且**只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求**。\n\n为了缩短Master启动的时间，我们必须**使日志足够小**（注：即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次**Checkpoint**，Checkpoint文件以**压缩B-树**形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。\n\n## 数据、控制流\n\n![](GFS-解读/react.jpg)\n\n+   读取流：\n    1.   client本地计算根据offset计算出chunk index，以file name+chunk index联系master，获取三个chunk副本的handle、localtion信息；\n    2.   client联系任意一个chunk，读取对应的数据；\n\n\n\n+   写入流：\n    1.   client联系master，获取到chunk的handle、localtion信息、主备身份信息；\n    2.   client将data发给任意一个chunk，该chunk将data转发给其他chunk；\n    3.   当三个chunk都成功将data写入内存，client给primary发送commit请求；\n    4.   primary将数据落到本地log中，然后发送commit请求给其他replica。\n    5.   当primary收到其他replica写入成功的回复后，返回client success。\n\n## 一致性模型\n\n<img src=\"GFS-解读/cons.png\"  />\n\n### 写入接口与文件状态\n\n+   GFS将写操作分为两种：\n    1.   write。允许用户指定offset，进行随机写。\n    2.   record append。不允许用户指定offset，只能不断往后append写。但是要注意的是这里的append与我们通常所说的在linux fs上append一个文件不同。平常所说在linux fs上append，就是指seek到文件末尾，然后将data写在末尾的下一个byte。而gfs的append，并不保证data会写到文件末尾的下一个byte中，而是由GFS内部选定一个位置写进去，然后把这个位置的offset作为返回值返回给用户。唯一能保证的是：这个GFS内部选定的位置offset，的确在末尾以后，但是可能并不直接与末尾相邻，中间可能夹杂着failed的、duplicated的数据碎片。具体原因我们在后面解释。\n\n+   GFS将文件状态分为两种：\n    1.   consistent。也就是一个chunk的多个replica，彼此之间数据一致。\n    2.   defined。不仅多个replica彼此之间数据一致（也即consistent），而且replica中的data与某一个用户写入的data保持一致。这句话比较难理解：replica中的数据怎么会跟用户写入的数据不一致呢？\n\n\n\n**无论是串行write还是并行write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent;**\n\n**对于append操作，客户端无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端，因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。对于如果append第一次失败，导致多副本在原offset的数据可能不一致，但接下来重试成功，使得在新offset之间的数据一致，因此，其状态是interspersed with inconsistent（部分不一致）。**\n\n### 租约（Lease）\n\nMaster 节点为 Chunk 的一个Replica建立一个 Lease,这个副本叫做Primary, Primary对 Chunk 的所有更改操作进行序列化,所有的副本都遵从这个序列进行修改操作。\n\n+   首先为保持Client操作时系统的一致性，Client 需要向 Master 节点询问哪一个 Chunk Server持有指定 Chunk 的 Lease以及其他副本的位置,如果没有就选择其中一个副本建一个 Lease，所有的操作必须在一个Lease 内\n+   在租约有效期内： master联系不到Primary，客户端可以联系到Primary。对于修改操作顺序都一致,并没有影响，\n+   在租约有效期内：master联系不到Primary, 客户端不可以联系到Primary。对于修改操作所有的操作全都失败，但并不会影响数据的一致性（因为没有数据写入，全部返回失败）\n+   当租约失效：master重新选择Primary, 不论客户端联不联系到Primary, 操作都不会受影响（假设联系到原先的chunk,客户端会被告知，其租约已失效，重新到master中获取新的主chunk信息，若在过期前一直联系不到Primary, 到过期后（客户端缓存过期时间）会从新从主master拉取信息）。\n\n**租约机制确保写入的顺序性，并有效的减轻了master的负担，另一方面有效避免了分布式系统中发生 <u>脑裂(split-brain)</u> 的情况**\n\n## **7、快照（snapshot）**\n\n-   快照对系统当前状态进行的一次拍照，用户可以在任意时刻回滚到快照的状态，GFS使用Copy-On-Write技术实现Snapshot。\n-   Master节点收到客户端的快照请求时，Master并没有立即对指定Chunk拷贝，而只拷贝其元数据并对指定Chunk的引用计数增1，等到Client需要修改指定Chunk时，再在本地复制，并却保新Chunk拥有租约。\n\n   具体流程是： \n\n-   收回Snapshot请求覆盖的文件chunk上的租约；\n-   操作元数据完成元数据拷贝；\n-   客户端要写入该文件的Chunk时，Master通知该Chunk所在ChunkServer进行本地拷贝，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；\n-   发放租约给拷贝Chunk；\n-   返回拷贝Chunk的位置信息，接下来客户端的更新流程与正常的没有区别。\n\n## **8、容错**\n\n#### 1）高可用性\n\n-    遵循的2个简单策略：1 快速恢复 2 复制\n\n-   快速恢复：Master或ChunkServer关闭（正常/异常），都被设计在数秒内可恢复状态并重启。Client和其他服务器发现请求超时，会重连重启的Server\n\n-   Chunk的复制：当ChunkServer关闭或Chksum校验出损坏的Chunk副本，Master都会通过复制已有Chunk副本来保障副本个数 \n\n-   Master的复制：CheckPoint文件+操作日志完成Master的恢复。此外，GFS还有些“影子”Master，在Master宕机时提供GFS的只读访问\n\n####   2）数据完整性    \n\n-   -   每个ChunkServer独立维护Checksum来校验自己副本的完整性，每个Chunk块都对应一个32位的Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。\n\n        独立维护原因：\n\n        -   跨Chunk服务器比较副本开销大；\n        -   追加操作可能造成数据的字节级别不一致，无法通过比较副本判断完整性。\n\n-   对读操作，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的checksum, 当checksum校验到数据不正确，ChunkServer会做两件事：1、返回给Client错误信息，让Client读取其他Chunk副本  2、通知Master，请求Chunk副本复制\n-   当ChunkServer空闲时，其会周期性扫描不活动的Chunk块，检验数据完整性 \n-   读操作的Checksum：只取Chunk小部分额外相关数据进行校验，客户端每次把读取操作对齐在Chunk块的边界上\n-   记录追加操作的Checksum（高度优化）：只增量更新最后一个不完整Chunk块的Checksum\n-   写操作的Checksum：先读取和校验被写操作覆盖的第一个和最后一个Chunk块，写操作完成后再重新计算和写入Chunksum\n\n","slug":"GFS-解读","published":1,"updated":"2022-09-11T07:40:36.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xji0007ecwdas5463aw","content":"<h1 id=\"GFS-解读\"><a href=\"#GFS-解读\" class=\"headerlink\" title=\"GFS 解读\"></a>GFS 解读</h1><blockquote>\n<p>  Google File System</p>\n<p>  GFS是为对数据敏感的大型分布式系统所设计的，可伸缩的分布式文件系统。它建立在普通商用电脑上，提供容错机制的同时也能在大量客户端接入的时候保持极高的平均性能。</p>\n</blockquote>\n<h2 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h2><p>经过长期观察，GFS在设计上和传统分布式文件系统相比，有4个不同的考虑重点。</p>\n<ol>\n<li>  出错是常态。</li>\n</ol>\n<p>​                分布式文件系统将几千台普通机器的硬盘连接到一起提供存储服务。良好的设计应该假设这些硬盘会随时出错并且不能恢复。软件bug，OS bug，操作    失误，硬盘损坏，内存，网络出错，甚至停电都会导致整个系统瘫痪。因此，随时监控，错误检测，容错和自动恢复是分布式文件系统的核心。</p>\n<ol start=\"2\">\n<li>  大文件是常态，GB级的文件是主流。</li>\n</ol>\n<p>​       因此，必须在设计阶段重新考虑方案和参数，比如，IO操作的类型和块大小。GFS虽然支持小文件存储，但不需要太在意效率。</p>\n<ol start=\"3\">\n<li>  文件追加写是常态，而不是覆盖写。</li>\n</ol>\n<p>​           文件的随机写是不存在的，一旦开始写入文件，要么只能读，要么顺序写。读又分为大规模的流式读取或小规模的随机读取。流式读取主要是同一个客户端    不间断的顺序读同一个文件，每次都读数百KB或MB级的数据。随机读取，发生在读取一个文件任意位置，每次只读几KB的数据。应用程序本身也是通过顺序    的批量读取和排序来提升系统性能的稳定性，来回反复的去读一个文件是不可取的。写入和读取类似，主要考虑大规模的顺序写。虽然在任意位置的小规模写入    是支持的，但效率极低。</p>\n<ol start=\"4\">\n<li>  文件数据追加写的性能和原子性是核心考量。</li>\n</ol>\n<p>​            GFS上的文件本身经常被用作生产者-消费者队列或多路归并。因此，多客户端（生产者）并发写的同步性能是核心指标。毕竟，随时都会有其他客户        （消费者）同时去读取这些最新写入的数据。</p>\n<ol start=\"5\">\n<li>  将文件系统和应用程序放在一起设计，以提升弹性。</li>\n</ol>\n<p>​            比如，<strong>GFS放松了对一致性的要求</strong>，以简化应用的开发。<strong>GFS提供原子化的追加写操作</strong>，免去了客户端处理同步的逻辑等。<strong>持续的高带宽并低延迟更重    要</strong>，应用程序更关注对数据的高速率处理，而并不关注单次读写的响应时间。</p>\n<ol start=\"6\">\n<li><p>独到的接口设计</p>\n<p>  ​        虽然GFS的API设计并不严格遵守POSIX，但大体类似。文件以目录的形式分层组织，使用路径命名。支持create，delete，open，close，read和write操作。除此之外，GFS还提供snapshot和record append功能。Snapshot可以低代价的创建一份文件或目录树的拷贝。Record append提供原子性的append操作，供多个客户端并发写而不用额外加锁。</p>\n</li>\n</ol>\n<h2 id=\"设计架构\"><a href=\"#设计架构\" class=\"headerlink\" title=\"设计架构\"></a>设计架构</h2><p><img src=\"/post/f2b485e3/arch.jpg\"></p>\n<ul>\n<li><p>  一个GFS集群包含一个单独的Master节点（译注：这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件）、多台Chunk服务器，并且同时被多个客户端访问，如上图所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。</p>\n</li>\n<li><p>  GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，<strong>Master服务器会给每个Chunk分配一个不变的、全球唯一的64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。</strong>出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>\n</li>\n<li><p>  Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。</p>\n</li>\n<li><p>  Master节点还管理着系统范围内的活动，比如，Chunk租用管理、孤儿Chunk(注：orphaned chunks)的回收、以及Chunk在Chunk服务器之间的迁移。</p>\n</li>\n<li><p>  Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p>\n</li>\n<li><p>  无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p>\n</li>\n</ul>\n<h2 id=\"单一Master节点\"><a href=\"#单一Master节点\" class=\"headerlink\" title=\"单一Master节点\"></a>单一Master节点</h2><p>单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，<strong>我们必须减少对Master节点的读写</strong>，避免Master节点成为系统的瓶颈。<strong>客户端并不通过Master节点读写文件数据</strong>。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将<strong>直接和Chunk服务器进行数据读写操作</strong>。</p>\n<p>我们利用图1解释一下一次简单读取的流程。</p>\n<ul>\n<li><p>  首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引。</p>\n</li>\n<li><p>  然后，它把文件名和Chunk索引发送给Master节点。</p>\n</li>\n<li><p>  Master节点将相应的Chunk标识和副本的位置信息发还给客户端。</p>\n</li>\n<li><p>  客户端用文件名和Chunk索引作为key缓存这些信息。</p>\n</li>\n<li><p>  之后客户端发送请求到其中的一个副本处，一般会选择最近的。</p>\n</li>\n<li><p>  请求信息包含了Chunk的标识和字节范围。</p>\n</li>\n<li><p>  在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。</p>\n</li>\n</ul>\n<p>实际上，客户端通常会在一次请求中查询多个Chunk信息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和Master节点未来可能会发生的几次通讯。</p>\n<h3 id=\"Master节点操作\"><a href=\"#Master节点操作\" class=\"headerlink\" title=\"Master节点操作\"></a>Master节点操作</h3><ul>\n<li><p>命名空间管理</p>\n<pre><code>        **命名空间的修改通过锁保证为原子性的。**\n    \n        在逻辑上，GFS 的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构           上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。采用这种锁方案的优点是支持对同一目录的并行操作，比如，每一个文件操作需    要获取父目录读锁和目标文件写锁。目录名的读取锁防止目录被删除、 改名以及被快照。\n</code></pre>\n</li>\n</ul>\n<p>​            <strong>如何避免死锁？</strong></p>\n<p>​            锁的获取依据全局一致的顺序，先按名字空间层次排序，同一层次按字典序排序</p>\n<ul>\n<li><p>副本位置分布  </p>\n<pre><code>      GFS中chunk以多副本存储，以提高数据可靠性。一个好的副本位置定义算法满足下面特性：\n</code></pre>\n</li>\n</ul>\n<ol>\n<li>  最大化数据可靠性，例如，不能将所有副本存放在同一个磁盘或者物理机器上；</li>\n<li>  最大化网络带宽利用率，有效利用多个机架的整合带宽</li>\n</ol>\n<ul>\n<li><p>Chunk的创建、负载均衡   </p>\n<pre><code>        当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本，需要考虑以下几个因素：\n</code></pre>\n</li>\n</ul>\n<ol>\n<li>  选择存储空间利用率最低的节点和磁盘；</li>\n<li>  选择最近一段时间内新建chunk数量较少的节点和磁盘；</li>\n<li>  将多个副本分散在不同的机架上。</li>\n</ol>\n<ul>\n<li><p>垃圾回收 </p>\n<pre><code>        所有 Master 节点不能识别的副本都是“垃圾”。我们很容易能得到 Chunk 的所有引用: 它们都只存储在 Master 服务器上的文件到chunk的映射表中。 我们也可以得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 \n    \n        GFS 在文件删除后不会立刻回收可用的物理空间，空间回收采用惰性的策略，周期性的常规垃圾扫描才回收物理空间，并在 Master 节点相对空闲的时候完成。\n    \n        具体流程：Client提交文件删除操作，Master将删除操作记录到日志，并将对应文件名改为包含删除时间戳的隐藏文件名（改名字，并没有回收物理空间。Master周期性对名字空间做常规垃圾扫描，会在名字空间中删除3天前（时间可配置）的隐藏文件及元数据。ChunkServer在与Master的心跳信息中，得知哪些Chunk的元数据不存在了，便可实际回收其物理空间。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关元数据才会被删除，这也有效的切断了文件和它包含的所有 Chunk 的连接。  \n    \n         优点：设计简单，批量执行，防误删\n    \n        缺点：存储的开销，阻碍用户调优存储空间使用，特别是当存储空间比较紧缺的时候。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的移除。\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Chunk尺寸\"><a href=\"#Chunk尺寸\" class=\"headerlink\" title=\"Chunk尺寸\"></a>Chunk尺寸</h2><p>Chunk的大小是关键的设计参数之一。</p>\n<p>我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。</p>\n<p>惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。选择较大的Chunk尺寸有几个重要的优点。</p>\n<ul>\n<li>  <strong>首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。</strong>这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信息。</li>\n<li>  <strong>其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。</strong></li>\n<li>  <strong>第三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量</strong>。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部放在内存中带来的额外的好处。</li>\n</ul>\n<p><strong>另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷：</strong> 小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。</p>\n<p>在实际应用中，由于我们的程序通常是连续的读取包含多个Chunk的大文件，热点还不是主要的问题。</p>\n<p>然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。</p>\n<p>我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。<strong>一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。</strong></p>\n<h2 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h2><p>Master服务器（注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储3种主要类型的元数据，包括：</p>\n<ul>\n<li>  文件和Chunk的命名空间</li>\n<li>  文件和Chunk的对应关系</li>\n<li>  每个Chunk副本的存放地点</li>\n</ul>\n<p>所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。</p>\n<p><strong>采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。</strong></p>\n<p>**<u>Master服务器不会持久保存Chunk位置信息。</u>**Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p>\n<h3 id=\"元数据结构\"><a href=\"#元数据结构\" class=\"headerlink\" title=\"元数据结构\"></a>元数据结构</h3><p>因为元数据保存在内存中，所以Master服务器的操作速度非常快。Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。</p>\n<p>并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现：</p>\n<ul>\n<li>  Chunk垃圾收集</li>\n<li>  在Chunk服务器失效的时重新复制数据通过Chunk的迁移实现</li>\n<li>  跨Chunk服务器的负载均衡</li>\n<li>  磁盘使用状况统计等功能</li>\n</ul>\n<h3 id=\"Chunk-位置信息\"><a href=\"#Chunk-位置信息\" class=\"headerlink\" title=\"Chunk 位置信息\"></a>Chunk 位置信息</h3><p><strong>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。</strong></p>\n<p><strong>Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。</strong></p>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><p>操作日志包含了关键的元数据变更历史记录。</p>\n<p>这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线；文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。 </p>\n<p>把<strong>日志复制到多台远程机器</strong>，并且<strong>只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求</strong>。</p>\n<p>为了缩短Master启动的时间，我们必须<strong>使日志足够小</strong>（注：即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次<strong>Checkpoint</strong>，Checkpoint文件以<strong>压缩B-树</strong>形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>\n<h2 id=\"数据、控制流\"><a href=\"#数据、控制流\" class=\"headerlink\" title=\"数据、控制流\"></a>数据、控制流</h2><p><img src=\"/post/f2b485e3/react.jpg\"></p>\n<ul>\n<li>读取流：<ol>\n<li>  client本地计算根据offset计算出chunk index，以file name+chunk index联系master，获取三个chunk副本的handle、localtion信息；</li>\n<li>  client联系任意一个chunk，读取对应的数据；</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>写入流：<ol>\n<li>  client联系master，获取到chunk的handle、localtion信息、主备身份信息；</li>\n<li>  client将data发给任意一个chunk，该chunk将data转发给其他chunk；</li>\n<li>  当三个chunk都成功将data写入内存，client给primary发送commit请求；</li>\n<li>  primary将数据落到本地log中，然后发送commit请求给其他replica。</li>\n<li>  当primary收到其他replica写入成功的回复后，返回client success。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一致性模型\"><a href=\"#一致性模型\" class=\"headerlink\" title=\"一致性模型\"></a>一致性模型</h2><img src=\"/post/f2b485e3/cons.png\">\n\n<h3 id=\"写入接口与文件状态\"><a href=\"#写入接口与文件状态\" class=\"headerlink\" title=\"写入接口与文件状态\"></a>写入接口与文件状态</h3><ul>\n<li><p>GFS将写操作分为两种：</p>\n<ol>\n<li>  write。允许用户指定offset，进行随机写。</li>\n<li>  record append。不允许用户指定offset，只能不断往后append写。但是要注意的是这里的append与我们通常所说的在linux fs上append一个文件不同。平常所说在linux fs上append，就是指seek到文件末尾，然后将data写在末尾的下一个byte。而gfs的append，并不保证data会写到文件末尾的下一个byte中，而是由GFS内部选定一个位置写进去，然后把这个位置的offset作为返回值返回给用户。唯一能保证的是：这个GFS内部选定的位置offset，的确在末尾以后，但是可能并不直接与末尾相邻，中间可能夹杂着failed的、duplicated的数据碎片。具体原因我们在后面解释。</li>\n</ol>\n</li>\n<li><p>GFS将文件状态分为两种：</p>\n<ol>\n<li>  consistent。也就是一个chunk的多个replica，彼此之间数据一致。</li>\n<li>  defined。不仅多个replica彼此之间数据一致（也即consistent），而且replica中的data与某一个用户写入的data保持一致。这句话比较难理解：replica中的数据怎么会跟用户写入的数据不一致呢？</li>\n</ol>\n</li>\n</ul>\n<p><strong>无论是串行write还是并行write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent;</strong></p>\n<p><strong>对于append操作，客户端无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端，因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。对于如果append第一次失败，导致多副本在原offset的数据可能不一致，但接下来重试成功，使得在新offset之间的数据一致，因此，其状态是interspersed with inconsistent（部分不一致）。</strong></p>\n<h3 id=\"租约（Lease）\"><a href=\"#租约（Lease）\" class=\"headerlink\" title=\"租约（Lease）\"></a>租约（Lease）</h3><p>Master 节点为 Chunk 的一个Replica建立一个 Lease,这个副本叫做Primary, Primary对 Chunk 的所有更改操作进行序列化,所有的副本都遵从这个序列进行修改操作。</p>\n<ul>\n<li>  首先为保持Client操作时系统的一致性，Client 需要向 Master 节点询问哪一个 Chunk Server持有指定 Chunk 的 Lease以及其他副本的位置,如果没有就选择其中一个副本建一个 Lease，所有的操作必须在一个Lease 内</li>\n<li>  在租约有效期内： master联系不到Primary，客户端可以联系到Primary。对于修改操作顺序都一致,并没有影响，</li>\n<li>  在租约有效期内：master联系不到Primary, 客户端不可以联系到Primary。对于修改操作所有的操作全都失败，但并不会影响数据的一致性（因为没有数据写入，全部返回失败）</li>\n<li>  当租约失效：master重新选择Primary, 不论客户端联不联系到Primary, 操作都不会受影响（假设联系到原先的chunk,客户端会被告知，其租约已失效，重新到master中获取新的主chunk信息，若在过期前一直联系不到Primary, 到过期后（客户端缓存过期时间）会从新从主master拉取信息）。</li>\n</ul>\n<p><strong>租约机制确保写入的顺序性，并有效的减轻了master的负担，另一方面有效避免了分布式系统中发生 <u>脑裂(split-brain)</u> 的情况</strong></p>\n<h2 id=\"7、快照（snapshot）\"><a href=\"#7、快照（snapshot）\" class=\"headerlink\" title=\"7、快照（snapshot）\"></a><strong>7、快照（snapshot）</strong></h2><ul>\n<li>  快照对系统当前状态进行的一次拍照，用户可以在任意时刻回滚到快照的状态，GFS使用Copy-On-Write技术实现Snapshot。</li>\n<li>  Master节点收到客户端的快照请求时，Master并没有立即对指定Chunk拷贝，而只拷贝其元数据并对指定Chunk的引用计数增1，等到Client需要修改指定Chunk时，再在本地复制，并却保新Chunk拥有租约。</li>\n</ul>\n<p>   具体流程是： </p>\n<ul>\n<li>  收回Snapshot请求覆盖的文件chunk上的租约；</li>\n<li>  操作元数据完成元数据拷贝；</li>\n<li>  客户端要写入该文件的Chunk时，Master通知该Chunk所在ChunkServer进行本地拷贝，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；</li>\n<li>  发放租约给拷贝Chunk；</li>\n<li>  返回拷贝Chunk的位置信息，接下来客户端的更新流程与正常的没有区别。</li>\n</ul>\n<h2 id=\"8、容错\"><a href=\"#8、容错\" class=\"headerlink\" title=\"8、容错\"></a><strong>8、容错</strong></h2><h4 id=\"1）高可用性\"><a href=\"#1）高可用性\" class=\"headerlink\" title=\"1）高可用性\"></a>1）高可用性</h4><ul>\n<li><p>   遵循的2个简单策略：1 快速恢复 2 复制</p>\n</li>\n<li><p>  快速恢复：Master或ChunkServer关闭（正常/异常），都被设计在数秒内可恢复状态并重启。Client和其他服务器发现请求超时，会重连重启的Server</p>\n</li>\n<li><p>  Chunk的复制：当ChunkServer关闭或Chksum校验出损坏的Chunk副本，Master都会通过复制已有Chunk副本来保障副本个数 </p>\n</li>\n<li><p>  Master的复制：CheckPoint文件+操作日志完成Master的恢复。此外，GFS还有些“影子”Master，在Master宕机时提供GFS的只读访问</p>\n</li>\n</ul>\n<h4 id=\"2）数据完整性\"><a href=\"#2）数据完整性\" class=\"headerlink\" title=\"2）数据完整性\"></a>2）数据完整性</h4><ul>\n<li><ul>\n<li><p>每个ChunkServer独立维护Checksum来校验自己副本的完整性，每个Chunk块都对应一个32位的Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>\n<pre><code>独立维护原因：\n\n-   跨Chunk服务器比较副本开销大；\n-   追加操作可能造成数据的字节级别不一致，无法通过比较副本判断完整性。\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>  对读操作，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的checksum, 当checksum校验到数据不正确，ChunkServer会做两件事：1、返回给Client错误信息，让Client读取其他Chunk副本  2、通知Master，请求Chunk副本复制</p>\n</li>\n<li><p>  当ChunkServer空闲时，其会周期性扫描不活动的Chunk块，检验数据完整性 </p>\n</li>\n<li><p>  读操作的Checksum：只取Chunk小部分额外相关数据进行校验，客户端每次把读取操作对齐在Chunk块的边界上</p>\n</li>\n<li><p>  记录追加操作的Checksum（高度优化）：只增量更新最后一个不完整Chunk块的Checksum</p>\n</li>\n<li><p>  写操作的Checksum：先读取和校验被写操作覆盖的第一个和最后一个Chunk块，写操作完成后再重新计算和写入Chunksum</p>\n</li>\n</ul>\n","site":{"data":{}},"cover":"/img/c5.jpg","excerpt":"","more":"<h1 id=\"GFS-解读\"><a href=\"#GFS-解读\" class=\"headerlink\" title=\"GFS 解读\"></a>GFS 解读</h1><blockquote>\n<p>  Google File System</p>\n<p>  GFS是为对数据敏感的大型分布式系统所设计的，可伸缩的分布式文件系统。它建立在普通商用电脑上，提供容错机制的同时也能在大量客户端接入的时候保持极高的平均性能。</p>\n</blockquote>\n<h2 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h2><p>经过长期观察，GFS在设计上和传统分布式文件系统相比，有4个不同的考虑重点。</p>\n<ol>\n<li>  出错是常态。</li>\n</ol>\n<p>​                分布式文件系统将几千台普通机器的硬盘连接到一起提供存储服务。良好的设计应该假设这些硬盘会随时出错并且不能恢复。软件bug，OS bug，操作    失误，硬盘损坏，内存，网络出错，甚至停电都会导致整个系统瘫痪。因此，随时监控，错误检测，容错和自动恢复是分布式文件系统的核心。</p>\n<ol start=\"2\">\n<li>  大文件是常态，GB级的文件是主流。</li>\n</ol>\n<p>​       因此，必须在设计阶段重新考虑方案和参数，比如，IO操作的类型和块大小。GFS虽然支持小文件存储，但不需要太在意效率。</p>\n<ol start=\"3\">\n<li>  文件追加写是常态，而不是覆盖写。</li>\n</ol>\n<p>​           文件的随机写是不存在的，一旦开始写入文件，要么只能读，要么顺序写。读又分为大规模的流式读取或小规模的随机读取。流式读取主要是同一个客户端    不间断的顺序读同一个文件，每次都读数百KB或MB级的数据。随机读取，发生在读取一个文件任意位置，每次只读几KB的数据。应用程序本身也是通过顺序    的批量读取和排序来提升系统性能的稳定性，来回反复的去读一个文件是不可取的。写入和读取类似，主要考虑大规模的顺序写。虽然在任意位置的小规模写入    是支持的，但效率极低。</p>\n<ol start=\"4\">\n<li>  文件数据追加写的性能和原子性是核心考量。</li>\n</ol>\n<p>​            GFS上的文件本身经常被用作生产者-消费者队列或多路归并。因此，多客户端（生产者）并发写的同步性能是核心指标。毕竟，随时都会有其他客户        （消费者）同时去读取这些最新写入的数据。</p>\n<ol start=\"5\">\n<li>  将文件系统和应用程序放在一起设计，以提升弹性。</li>\n</ol>\n<p>​            比如，<strong>GFS放松了对一致性的要求</strong>，以简化应用的开发。<strong>GFS提供原子化的追加写操作</strong>，免去了客户端处理同步的逻辑等。<strong>持续的高带宽并低延迟更重    要</strong>，应用程序更关注对数据的高速率处理，而并不关注单次读写的响应时间。</p>\n<ol start=\"6\">\n<li><p>独到的接口设计</p>\n<p>  ​        虽然GFS的API设计并不严格遵守POSIX，但大体类似。文件以目录的形式分层组织，使用路径命名。支持create，delete，open，close，read和write操作。除此之外，GFS还提供snapshot和record append功能。Snapshot可以低代价的创建一份文件或目录树的拷贝。Record append提供原子性的append操作，供多个客户端并发写而不用额外加锁。</p>\n</li>\n</ol>\n<h2 id=\"设计架构\"><a href=\"#设计架构\" class=\"headerlink\" title=\"设计架构\"></a>设计架构</h2><p><img src=\"/post/f2b485e3/arch.jpg\"></p>\n<ul>\n<li><p>  一个GFS集群包含一个单独的Master节点（译注：这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件）、多台Chunk服务器，并且同时被多个客户端访问，如上图所示。所有的这些机器通常都是普通的Linux机器，运行着用户级别(user-level)的服务进程。我们可以很容易的把Chunk服务器和客户端都放在同一台机器上，前提是机器资源允许，并且我们能够接受不可靠的应用程序代码带来的稳定性降低的风险。</p>\n</li>\n<li><p>  GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，<strong>Master服务器会给每个Chunk分配一个不变的、全球唯一的64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。</strong>出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用3个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>\n</li>\n<li><p>  Master节点管理所有的文件系统元数据。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。</p>\n</li>\n<li><p>  Master节点还管理着系统范围内的活动，比如，Chunk租用管理、孤儿Chunk(注：orphaned chunks)的回收、以及Chunk在Chunk服务器之间的迁移。</p>\n</li>\n<li><p>  Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p>\n</li>\n<li><p>  无论是客户端还是Chunk服务器都不需要缓存文件数据。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p>\n</li>\n</ul>\n<h2 id=\"单一Master节点\"><a href=\"#单一Master节点\" class=\"headerlink\" title=\"单一Master节点\"></a>单一Master节点</h2><p>单一的Master节点的策略大大简化了我们的设计。单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，<strong>我们必须减少对Master节点的读写</strong>，避免Master节点成为系统的瓶颈。<strong>客户端并不通过Master节点读写文件数据</strong>。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将<strong>直接和Chunk服务器进行数据读写操作</strong>。</p>\n<p>我们利用图1解释一下一次简单读取的流程。</p>\n<ul>\n<li><p>  首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引。</p>\n</li>\n<li><p>  然后，它把文件名和Chunk索引发送给Master节点。</p>\n</li>\n<li><p>  Master节点将相应的Chunk标识和副本的位置信息发还给客户端。</p>\n</li>\n<li><p>  客户端用文件名和Chunk索引作为key缓存这些信息。</p>\n</li>\n<li><p>  之后客户端发送请求到其中的一个副本处，一般会选择最近的。</p>\n</li>\n<li><p>  请求信息包含了Chunk的标识和字节范围。</p>\n</li>\n<li><p>  在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。</p>\n</li>\n</ul>\n<p>实际上，客户端通常会在一次请求中查询多个Chunk信息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息在没有任何代价的情况下，避免了客户端和Master节点未来可能会发生的几次通讯。</p>\n<h3 id=\"Master节点操作\"><a href=\"#Master节点操作\" class=\"headerlink\" title=\"Master节点操作\"></a>Master节点操作</h3><ul>\n<li><p>命名空间管理</p>\n<pre><code>        **命名空间的修改通过锁保证为原子性的。**\n    \n        在逻辑上，GFS 的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构           上，每个节点(绝对路径的文件名或绝对路径的目录名)都有一个关联的读写锁。采用这种锁方案的优点是支持对同一目录的并行操作，比如，每一个文件操作需    要获取父目录读锁和目标文件写锁。目录名的读取锁防止目录被删除、 改名以及被快照。\n</code></pre>\n</li>\n</ul>\n<p>​            <strong>如何避免死锁？</strong></p>\n<p>​            锁的获取依据全局一致的顺序，先按名字空间层次排序，同一层次按字典序排序</p>\n<ul>\n<li><p>副本位置分布  </p>\n<pre><code>      GFS中chunk以多副本存储，以提高数据可靠性。一个好的副本位置定义算法满足下面特性：\n</code></pre>\n</li>\n</ul>\n<ol>\n<li>  最大化数据可靠性，例如，不能将所有副本存放在同一个磁盘或者物理机器上；</li>\n<li>  最大化网络带宽利用率，有效利用多个机架的整合带宽</li>\n</ol>\n<ul>\n<li><p>Chunk的创建、负载均衡   </p>\n<pre><code>        当 Master 节点创建一个 Chunk 时，它会选择在哪里放置初始的空的副本，需要考虑以下几个因素：\n</code></pre>\n</li>\n</ul>\n<ol>\n<li>  选择存储空间利用率最低的节点和磁盘；</li>\n<li>  选择最近一段时间内新建chunk数量较少的节点和磁盘；</li>\n<li>  将多个副本分散在不同的机架上。</li>\n</ol>\n<ul>\n<li><p>垃圾回收 </p>\n<pre><code>        所有 Master 节点不能识别的副本都是“垃圾”。我们很容易能得到 Chunk 的所有引用: 它们都只存储在 Master 服务器上的文件到chunk的映射表中。 我们也可以得到所有 Chunk 的副本:它们都以 Linux 文件的形式存储在 Chunk 服务器的指定目录下。 \n    \n        GFS 在文件删除后不会立刻回收可用的物理空间，空间回收采用惰性的策略，周期性的常规垃圾扫描才回收物理空间，并在 Master 节点相对空闲的时候完成。\n    \n        具体流程：Client提交文件删除操作，Master将删除操作记录到日志，并将对应文件名改为包含删除时间戳的隐藏文件名（改名字，并没有回收物理空间。Master周期性对名字空间做常规垃圾扫描，会在名字空间中删除3天前（时间可配置）的隐藏文件及元数据。ChunkServer在与Master的心跳信息中，得知哪些Chunk的元数据不存在了，便可实际回收其物理空间。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master 服务器内存中保存的这个文件的相关元数据才会被删除，这也有效的切断了文件和它包含的所有 Chunk 的连接。  \n    \n         优点：设计简单，批量执行，防误删\n    \n        缺点：存储的开销，阻碍用户调优存储空间使用，特别是当存储空间比较紧缺的时候。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的移除。\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Chunk尺寸\"><a href=\"#Chunk尺寸\" class=\"headerlink\" title=\"Chunk尺寸\"></a>Chunk尺寸</h2><p>Chunk的大小是关键的设计参数之一。</p>\n<p>我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。</p>\n<p>惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议一点。选择较大的Chunk尺寸有几个重要的优点。</p>\n<ul>\n<li>  <strong>首先，它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。</strong>这种方式对降低我们的工作负载来说效果显著，因为我们的应用程序通常是连续读写大文件。即使是小规模的随机读取，采用较大的Chunk尺寸也带来明显的好处，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信息。</li>\n<li>  <strong>其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。</strong></li>\n<li>  <strong>第三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量</strong>。这就允许我们把元数据全部放在内存中，在2.6.1节我们会讨论元数据全部放在内存中带来的额外的好处。</li>\n</ul>\n<p><strong>另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷：</strong> 小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。</p>\n<p>在实际应用中，由于我们的程序通常是连续的读取包含多个Chunk的大文件，热点还不是主要的问题。</p>\n<p>然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。</p>\n<p>我们通过使用更大的复制参数来保存可执行文件，以及错开批处理队列系统程序的启动时间的方法解决了这个问题。<strong>一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。</strong></p>\n<h2 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h2><p>Master服务器（注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称）存储3种主要类型的元数据，包括：</p>\n<ul>\n<li>  文件和Chunk的命名空间</li>\n<li>  文件和Chunk的对应关系</li>\n<li>  每个Chunk副本的存放地点</li>\n</ul>\n<p>所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。</p>\n<p><strong>采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。</strong></p>\n<p>**<u>Master服务器不会持久保存Chunk位置信息。</u>**Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p>\n<h3 id=\"元数据结构\"><a href=\"#元数据结构\" class=\"headerlink\" title=\"元数据结构\"></a>元数据结构</h3><p>因为元数据保存在内存中，所以Master服务器的操作速度非常快。Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。</p>\n<p>并且，Master服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现：</p>\n<ul>\n<li>  Chunk垃圾收集</li>\n<li>  在Chunk服务器失效的时重新复制数据通过Chunk的迁移实现</li>\n<li>  跨Chunk服务器的负载均衡</li>\n<li>  磁盘使用状况统计等功能</li>\n</ul>\n<h3 id=\"Chunk-位置信息\"><a href=\"#Chunk-位置信息\" class=\"headerlink\" title=\"Chunk 位置信息\"></a>Chunk 位置信息</h3><p><strong>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。</strong></p>\n<p><strong>Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。</strong></p>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><p>操作日志包含了关键的元数据变更历史记录。</p>\n<p>这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线；文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。 </p>\n<p>把<strong>日志复制到多台远程机器</strong>，并且<strong>只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求</strong>。</p>\n<p>为了缩短Master启动的时间，我们必须<strong>使日志足够小</strong>（注：即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次<strong>Checkpoint</strong>，Checkpoint文件以<strong>压缩B-树</strong>形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>\n<h2 id=\"数据、控制流\"><a href=\"#数据、控制流\" class=\"headerlink\" title=\"数据、控制流\"></a>数据、控制流</h2><p><img src=\"/post/f2b485e3/react.jpg\"></p>\n<ul>\n<li>读取流：<ol>\n<li>  client本地计算根据offset计算出chunk index，以file name+chunk index联系master，获取三个chunk副本的handle、localtion信息；</li>\n<li>  client联系任意一个chunk，读取对应的数据；</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>写入流：<ol>\n<li>  client联系master，获取到chunk的handle、localtion信息、主备身份信息；</li>\n<li>  client将data发给任意一个chunk，该chunk将data转发给其他chunk；</li>\n<li>  当三个chunk都成功将data写入内存，client给primary发送commit请求；</li>\n<li>  primary将数据落到本地log中，然后发送commit请求给其他replica。</li>\n<li>  当primary收到其他replica写入成功的回复后，返回client success。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一致性模型\"><a href=\"#一致性模型\" class=\"headerlink\" title=\"一致性模型\"></a>一致性模型</h2><img src=\"/post/f2b485e3/cons.png\">\n\n<h3 id=\"写入接口与文件状态\"><a href=\"#写入接口与文件状态\" class=\"headerlink\" title=\"写入接口与文件状态\"></a>写入接口与文件状态</h3><ul>\n<li><p>GFS将写操作分为两种：</p>\n<ol>\n<li>  write。允许用户指定offset，进行随机写。</li>\n<li>  record append。不允许用户指定offset，只能不断往后append写。但是要注意的是这里的append与我们通常所说的在linux fs上append一个文件不同。平常所说在linux fs上append，就是指seek到文件末尾，然后将data写在末尾的下一个byte。而gfs的append，并不保证data会写到文件末尾的下一个byte中，而是由GFS内部选定一个位置写进去，然后把这个位置的offset作为返回值返回给用户。唯一能保证的是：这个GFS内部选定的位置offset，的确在末尾以后，但是可能并不直接与末尾相邻，中间可能夹杂着failed的、duplicated的数据碎片。具体原因我们在后面解释。</li>\n</ol>\n</li>\n<li><p>GFS将文件状态分为两种：</p>\n<ol>\n<li>  consistent。也就是一个chunk的多个replica，彼此之间数据一致。</li>\n<li>  defined。不仅多个replica彼此之间数据一致（也即consistent），而且replica中的data与某一个用户写入的data保持一致。这句话比较难理解：replica中的数据怎么会跟用户写入的数据不一致呢？</li>\n</ol>\n</li>\n</ul>\n<p><strong>无论是串行write还是并行write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent;</strong></p>\n<p><strong>对于append操作，客户端无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端，因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。对于如果append第一次失败，导致多副本在原offset的数据可能不一致，但接下来重试成功，使得在新offset之间的数据一致，因此，其状态是interspersed with inconsistent（部分不一致）。</strong></p>\n<h3 id=\"租约（Lease）\"><a href=\"#租约（Lease）\" class=\"headerlink\" title=\"租约（Lease）\"></a>租约（Lease）</h3><p>Master 节点为 Chunk 的一个Replica建立一个 Lease,这个副本叫做Primary, Primary对 Chunk 的所有更改操作进行序列化,所有的副本都遵从这个序列进行修改操作。</p>\n<ul>\n<li>  首先为保持Client操作时系统的一致性，Client 需要向 Master 节点询问哪一个 Chunk Server持有指定 Chunk 的 Lease以及其他副本的位置,如果没有就选择其中一个副本建一个 Lease，所有的操作必须在一个Lease 内</li>\n<li>  在租约有效期内： master联系不到Primary，客户端可以联系到Primary。对于修改操作顺序都一致,并没有影响，</li>\n<li>  在租约有效期内：master联系不到Primary, 客户端不可以联系到Primary。对于修改操作所有的操作全都失败，但并不会影响数据的一致性（因为没有数据写入，全部返回失败）</li>\n<li>  当租约失效：master重新选择Primary, 不论客户端联不联系到Primary, 操作都不会受影响（假设联系到原先的chunk,客户端会被告知，其租约已失效，重新到master中获取新的主chunk信息，若在过期前一直联系不到Primary, 到过期后（客户端缓存过期时间）会从新从主master拉取信息）。</li>\n</ul>\n<p><strong>租约机制确保写入的顺序性，并有效的减轻了master的负担，另一方面有效避免了分布式系统中发生 <u>脑裂(split-brain)</u> 的情况</strong></p>\n<h2 id=\"7、快照（snapshot）\"><a href=\"#7、快照（snapshot）\" class=\"headerlink\" title=\"7、快照（snapshot）\"></a><strong>7、快照（snapshot）</strong></h2><ul>\n<li>  快照对系统当前状态进行的一次拍照，用户可以在任意时刻回滚到快照的状态，GFS使用Copy-On-Write技术实现Snapshot。</li>\n<li>  Master节点收到客户端的快照请求时，Master并没有立即对指定Chunk拷贝，而只拷贝其元数据并对指定Chunk的引用计数增1，等到Client需要修改指定Chunk时，再在本地复制，并却保新Chunk拥有租约。</li>\n</ul>\n<p>   具体流程是： </p>\n<ul>\n<li>  收回Snapshot请求覆盖的文件chunk上的租约；</li>\n<li>  操作元数据完成元数据拷贝；</li>\n<li>  客户端要写入该文件的Chunk时，Master通知该Chunk所在ChunkServer进行本地拷贝，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；</li>\n<li>  发放租约给拷贝Chunk；</li>\n<li>  返回拷贝Chunk的位置信息，接下来客户端的更新流程与正常的没有区别。</li>\n</ul>\n<h2 id=\"8、容错\"><a href=\"#8、容错\" class=\"headerlink\" title=\"8、容错\"></a><strong>8、容错</strong></h2><h4 id=\"1）高可用性\"><a href=\"#1）高可用性\" class=\"headerlink\" title=\"1）高可用性\"></a>1）高可用性</h4><ul>\n<li><p>   遵循的2个简单策略：1 快速恢复 2 复制</p>\n</li>\n<li><p>  快速恢复：Master或ChunkServer关闭（正常/异常），都被设计在数秒内可恢复状态并重启。Client和其他服务器发现请求超时，会重连重启的Server</p>\n</li>\n<li><p>  Chunk的复制：当ChunkServer关闭或Chksum校验出损坏的Chunk副本，Master都会通过复制已有Chunk副本来保障副本个数 </p>\n</li>\n<li><p>  Master的复制：CheckPoint文件+操作日志完成Master的恢复。此外，GFS还有些“影子”Master，在Master宕机时提供GFS的只读访问</p>\n</li>\n</ul>\n<h4 id=\"2）数据完整性\"><a href=\"#2）数据完整性\" class=\"headerlink\" title=\"2）数据完整性\"></a>2）数据完整性</h4><ul>\n<li><ul>\n<li><p>每个ChunkServer独立维护Checksum来校验自己副本的完整性，每个Chunk块都对应一个32位的Checksum。和其它元数据一样， Checksum 与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>\n<pre><code>独立维护原因：\n\n-   跨Chunk服务器比较副本开销大；\n-   追加操作可能造成数据的字节级别不一致，无法通过比较副本判断完整性。\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>  对读操作，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的checksum, 当checksum校验到数据不正确，ChunkServer会做两件事：1、返回给Client错误信息，让Client读取其他Chunk副本  2、通知Master，请求Chunk副本复制</p>\n</li>\n<li><p>  当ChunkServer空闲时，其会周期性扫描不活动的Chunk块，检验数据完整性 </p>\n</li>\n<li><p>  读操作的Checksum：只取Chunk小部分额外相关数据进行校验，客户端每次把读取操作对齐在Chunk块的边界上</p>\n</li>\n<li><p>  记录追加操作的Checksum（高度优化）：只增量更新最后一个不完整Chunk块的Checksum</p>\n</li>\n<li><p>  写操作的Checksum：先读取和校验被写操作覆盖的第一个和最后一个Chunk块，写操作完成后再重新计算和写入Chunksum</p>\n</li>\n</ul>\n"},{"title":"Go-zero框架学习","abbrlink":"0","_content":"# go-zero-study\nJust for studying go-zero framework\n\n## 安装 go-zero & goctl Cli\n```shell\n# Run the following command under your project:\n    go get -u github.com/zeromicro/go-zero\n\n# for Go 1.16 and later\n    go install github.com/zeromicro/go-zero/tools/goctl@latest\n```\n\n\n## API & RPC 语法\n[官方API语法](https://go-zero.dev/cn/docs/design/grammar)\n\n[Protobuf语法1](https://www.jianshu.com/p/4e7f861020d8)<br>\n[Protobuf语法2](https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/#autoid-0-1-0)\n\n## 生成api业务代码 ， 进入\"服务/cmd/api/desc\"目录下，执行下面命令\n```shell\ngoctl api go -api *.api -dir ../  --style=goZero\n```\n> 已存在的文件将不再生成，不会造成原文件被覆盖的问题，若需重新生成，须先删除原文件\n\n### 目录结构\n```shell\nuser_api:\n│  user.go   # 启动文件\n│\n├─api\n│      user.api    # API 源文件\n│\n├─etc\n│      user-api.yaml    # 配置文件\n│\n└─internal\n    ├─config\n    │      config.go    # 配置管理\n    │\n    ├─handler\n    │      loginHandler.go\n    │      routes.go    # 路由\n    │\n    ├─logic\n    │      loginLogic.go   # 业务逻辑\n    │\n    ├─svc\n    │      serviceContext.go    # 相关依赖注入 \n    │\n    └─types\n            types.go\n```\n\n## 生成rpc业务代码\n> 需要安装下面3个插件\n       protoc >= 3.13.0 ， 如果没安装请先安装 https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中\n+ protoc-gen-go ，如果没有安装请先安装 \n\n```shell\n    go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n+ protoc-gen-go-grpc ，如果没有安装请先安装\n\n``` shell\n    go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n```\n+ 如果有要使用grpc-gateway，也请安装如下两个插件 , 没有使用就忽略下面2个插件\n\n```shell\n    go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest  \n     \n    go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest\n```\n1. goctl >= 1.3 进入\"服务/cmd/rpc/pb\"目录下，执行下面命令\n```shell\n    goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../  --zrpc_out=../ --style=goZero\n   \n# 去除proto中的json的omitempty\n# mac: \n    sed -i \"\" 's/,omitempty//g' *.pb.go\n# linux: \n    sed -i 's/,omitempty//g' *.pb.go\n```\n2. goctl < 1.3 进入\"服务/cmd\"目录下，执行下面命令\n```shell\n   goctl rpc proto -src rpc/pb/*.proto -dir ./rpc --style=goZero\n\n# 去除proto中的json的omitempty\n# mac: \n   sed -i \"\" 's/,omitempty//g'  ./rpc/pb/*.pb.go\n# linux: \n   sed -i 's/,omitempty//g'  ./rpc/pb/*.pb.go\n```\n### 目录结构\n```shell\nuser_rpc:\n│  user.go              # 启动文件\n│  \n├─etc\n│      user.yaml        # 配置文件\n│\n├─internal\n│  ├─config              # 配置管理\n│  │      config.go\n│  │\n│  ├─logic\n│  │      getUserLogic.go         # 业务逻辑\n│  │\n│  ├─server\n│  │      userServer.go           # 自动实现 gRPC-Server 接口的子类\n│  │\n│  └─svc\n│          serviceContext.go        # 依赖注入\n│\n├─pb\n│      user.pb.go               # proto -> go\n│      user.proto               # Protobuf3 文件\n│      user_grpc.pb.go          # go-gRPC \n│\n└─user\n        user.go                 # 客户端调用接口\n```\n### RPC调试\n**Go gRPC 调试工具**： [gRPC UI](https://github.com/fullstorydev/grpcui)\n+ 需要以开发者模式启动服务，在`/etc/xx.yaml`配置文件中添加：\n    ```yaml\n    Mode: dev # 启动模式：开发模式\n    ```\n+ 使用如下命令，以开启调试界面\n    ```shell\n    grpcui -plaintext localhost:8082\n    ```\n\n## API 调用 RPC\n+ 修改yaml配置文件，配置etcd地址，与服务名\n+ 修改config.go文件，在Config结构体中添加RPC配置信息字段\n+ 在ServerContext结构体中添加goctl生成rpc服务时生成的相关rpcClient\n+ 在业务逻辑中调用相关rpc接口 \n\n## 创建kafka的topic\n```shell\n kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic {topic}\n```\n1. 查看消费者组情况\n```shell\n kafka-consumer-groups.sh --bootstrap-server kafka:9092 --describe --group {group}\n```\n2. 命令行消费\n```shell\n ./kafka-console-consumer.sh  --bootstrap-server kafka:9092  --topic looklook-log   --from-beginning\n```\n3. 命令生产\n```shell\n ./kafka-console-producer.sh --bootstrap-server kafka:9092 --topic second\n```","source":"_posts/Go-zero框架学习.md","raw":"---\ntitle: Go-zero框架学习\nabbrlink: '0'\ntags: \n    - 微服务\n    - web\n    - RPC\ncategories: \n    - 微服务\n    - RPC\n---\n# go-zero-study\nJust for studying go-zero framework\n\n## 安装 go-zero & goctl Cli\n```shell\n# Run the following command under your project:\n    go get -u github.com/zeromicro/go-zero\n\n# for Go 1.16 and later\n    go install github.com/zeromicro/go-zero/tools/goctl@latest\n```\n\n\n## API & RPC 语法\n[官方API语法](https://go-zero.dev/cn/docs/design/grammar)\n\n[Protobuf语法1](https://www.jianshu.com/p/4e7f861020d8)<br>\n[Protobuf语法2](https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/#autoid-0-1-0)\n\n## 生成api业务代码 ， 进入\"服务/cmd/api/desc\"目录下，执行下面命令\n```shell\ngoctl api go -api *.api -dir ../  --style=goZero\n```\n> 已存在的文件将不再生成，不会造成原文件被覆盖的问题，若需重新生成，须先删除原文件\n\n### 目录结构\n```shell\nuser_api:\n│  user.go   # 启动文件\n│\n├─api\n│      user.api    # API 源文件\n│\n├─etc\n│      user-api.yaml    # 配置文件\n│\n└─internal\n    ├─config\n    │      config.go    # 配置管理\n    │\n    ├─handler\n    │      loginHandler.go\n    │      routes.go    # 路由\n    │\n    ├─logic\n    │      loginLogic.go   # 业务逻辑\n    │\n    ├─svc\n    │      serviceContext.go    # 相关依赖注入 \n    │\n    └─types\n            types.go\n```\n\n## 生成rpc业务代码\n> 需要安装下面3个插件\n       protoc >= 3.13.0 ， 如果没安装请先安装 https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中\n+ protoc-gen-go ，如果没有安装请先安装 \n\n```shell\n    go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n+ protoc-gen-go-grpc ，如果没有安装请先安装\n\n``` shell\n    go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n```\n+ 如果有要使用grpc-gateway，也请安装如下两个插件 , 没有使用就忽略下面2个插件\n\n```shell\n    go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest  \n     \n    go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest\n```\n1. goctl >= 1.3 进入\"服务/cmd/rpc/pb\"目录下，执行下面命令\n```shell\n    goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../  --zrpc_out=../ --style=goZero\n   \n# 去除proto中的json的omitempty\n# mac: \n    sed -i \"\" 's/,omitempty//g' *.pb.go\n# linux: \n    sed -i 's/,omitempty//g' *.pb.go\n```\n2. goctl < 1.3 进入\"服务/cmd\"目录下，执行下面命令\n```shell\n   goctl rpc proto -src rpc/pb/*.proto -dir ./rpc --style=goZero\n\n# 去除proto中的json的omitempty\n# mac: \n   sed -i \"\" 's/,omitempty//g'  ./rpc/pb/*.pb.go\n# linux: \n   sed -i 's/,omitempty//g'  ./rpc/pb/*.pb.go\n```\n### 目录结构\n```shell\nuser_rpc:\n│  user.go              # 启动文件\n│  \n├─etc\n│      user.yaml        # 配置文件\n│\n├─internal\n│  ├─config              # 配置管理\n│  │      config.go\n│  │\n│  ├─logic\n│  │      getUserLogic.go         # 业务逻辑\n│  │\n│  ├─server\n│  │      userServer.go           # 自动实现 gRPC-Server 接口的子类\n│  │\n│  └─svc\n│          serviceContext.go        # 依赖注入\n│\n├─pb\n│      user.pb.go               # proto -> go\n│      user.proto               # Protobuf3 文件\n│      user_grpc.pb.go          # go-gRPC \n│\n└─user\n        user.go                 # 客户端调用接口\n```\n### RPC调试\n**Go gRPC 调试工具**： [gRPC UI](https://github.com/fullstorydev/grpcui)\n+ 需要以开发者模式启动服务，在`/etc/xx.yaml`配置文件中添加：\n    ```yaml\n    Mode: dev # 启动模式：开发模式\n    ```\n+ 使用如下命令，以开启调试界面\n    ```shell\n    grpcui -plaintext localhost:8082\n    ```\n\n## API 调用 RPC\n+ 修改yaml配置文件，配置etcd地址，与服务名\n+ 修改config.go文件，在Config结构体中添加RPC配置信息字段\n+ 在ServerContext结构体中添加goctl生成rpc服务时生成的相关rpcClient\n+ 在业务逻辑中调用相关rpc接口 \n\n## 创建kafka的topic\n```shell\n kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic {topic}\n```\n1. 查看消费者组情况\n```shell\n kafka-consumer-groups.sh --bootstrap-server kafka:9092 --describe --group {group}\n```\n2. 命令行消费\n```shell\n ./kafka-console-consumer.sh  --bootstrap-server kafka:9092  --topic looklook-log   --from-beginning\n```\n3. 命令生产\n```shell\n ./kafka-console-producer.sh --bootstrap-server kafka:9092 --topic second\n```","slug":"Go-zero框架学习","published":1,"date":"2022-09-07T14:10:18.203Z","updated":"2022-09-08T05:40:19.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjk0009ecwdg8784zqo","content":"<h1 id=\"go-zero-study\"><a href=\"#go-zero-study\" class=\"headerlink\" title=\"go-zero-study\"></a>go-zero-study</h1><p>Just for studying go-zero framework</p>\n<h2 id=\"安装-go-zero-amp-goctl-Cli\"><a href=\"#安装-go-zero-amp-goctl-Cli\" class=\"headerlink\" title=\"安装 go-zero &amp; goctl Cli\"></a>安装 go-zero &amp; goctl Cli</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Run the following <span class=\"built_in\">command</span> under your project:</span></span><br><span class=\"line\">    go get -u github.com/zeromicro/go-zero</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> Go 1.16 and later</span></span><br><span class=\"line\">    go install github.com/zeromicro/go-zero/tools/goctl@latest</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"API-amp-RPC-语法\"><a href=\"#API-amp-RPC-语法\" class=\"headerlink\" title=\"API &amp; RPC 语法\"></a>API &amp; RPC 语法</h2><p><a href=\"https://go-zero.dev/cn/docs/design/grammar\">官方API语法</a></p>\n<p><a href=\"https://www.jianshu.com/p/4e7f861020d8\">Protobuf语法1</a><br><br><a href=\"https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/#autoid-0-1-0\">Protobuf语法2</a></p>\n<h2 id=\"生成api业务代码-，-进入”服务-cmd-api-desc”目录下，执行下面命令\"><a href=\"#生成api业务代码-，-进入”服务-cmd-api-desc”目录下，执行下面命令\" class=\"headerlink\" title=\"生成api业务代码 ， 进入”服务/cmd/api/desc”目录下，执行下面命令\"></a>生成api业务代码 ， 进入”服务/cmd/api/desc”目录下，执行下面命令</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">goctl api go -api *.api -dir ../  --style=goZero</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>已存在的文件将不再生成，不会造成原文件被覆盖的问题，若需重新生成，须先删除原文件</p>\n</blockquote>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_api:</span><br><span class=\"line\">│  user.go   # 启动文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─api</span><br><span class=\"line\">│      user.api    # API 源文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─etc</span><br><span class=\"line\">│      user-api.yaml    # 配置文件</span><br><span class=\"line\">│</span><br><span class=\"line\">└─internal</span><br><span class=\"line\">    ├─config</span><br><span class=\"line\">    │      config.go    # 配置管理</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─handler</span><br><span class=\"line\">    │      loginHandler.go</span><br><span class=\"line\">    │      routes.go    # 路由</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─logic</span><br><span class=\"line\">    │      loginLogic.go   # 业务逻辑</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─svc</span><br><span class=\"line\">    │      serviceContext.go    # 相关依赖注入 </span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─types</span><br><span class=\"line\">            types.go</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成rpc业务代码\"><a href=\"#生成rpc业务代码\" class=\"headerlink\" title=\"生成rpc业务代码\"></a>生成rpc业务代码</h2><blockquote>\n<p>需要安装下面3个插件<br>       protoc &gt;= 3.13.0 ， 如果没安装请先安装 <a href=\"https://github.com/protocolbuffers/protobuf%EF%BC%8C%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%8E%8B%E5%88%B0$GOPATH/bin%E4%B8%8B%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%89%8D%E6%8F%90%E6%98%AF$GOPATH/bin%E5%B7%B2%E7%BB%8F%E5%8A%A0%E5%85%A5$PATH%E4%B8%AD\">https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中</a></p>\n</blockquote>\n<ul>\n<li>protoc-gen-go ，如果没有安装请先安装 </li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>\n<ul>\n<li>protoc-gen-go-grpc ，如果没有安装请先安装</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果有要使用grpc-gateway，也请安装如下两个插件 , 没有使用就忽略下面2个插件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest  </span><br><span class=\"line\"> </span><br><span class=\"line\">go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest</span><br></pre></td></tr></table></figure>\n<ol>\n<li>goctl &gt;= 1.3 进入”服务/cmd/rpc/pb”目录下，执行下面命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../  --zrpc_out=../ --style=goZero</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">去除proto中的json的omitempty</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">mac:</span> </span><br><span class=\"line\">    sed -i &quot;&quot; &#x27;s/,omitempty//g&#x27; *.pb.go</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">linux:</span> </span><br><span class=\"line\">    sed -i &#x27;s/,omitempty//g&#x27; *.pb.go</span><br></pre></td></tr></table></figure></li>\n<li>goctl &lt; 1.3 进入”服务/cmd”目录下，执行下面命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   goctl rpc proto -src rpc/pb/*.proto -dir ./rpc --style=goZero</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">去除proto中的json的omitempty</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">mac:</span> </span><br><span class=\"line\">   sed -i &quot;&quot; &#x27;s/,omitempty//g&#x27;  ./rpc/pb/*.pb.go</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">linux:</span> </span><br><span class=\"line\">   sed -i &#x27;s/,omitempty//g&#x27;  ./rpc/pb/*.pb.go</span><br></pre></td></tr></table></figure>\n<h3 id=\"目录结构-1\"><a href=\"#目录结构-1\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_rpc:</span><br><span class=\"line\">│  user.go              # 启动文件</span><br><span class=\"line\">│  </span><br><span class=\"line\">├─etc</span><br><span class=\"line\">│      user.yaml        # 配置文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─internal</span><br><span class=\"line\">│  ├─config              # 配置管理</span><br><span class=\"line\">│  │      config.go</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─logic</span><br><span class=\"line\">│  │      getUserLogic.go         # 业务逻辑</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─server</span><br><span class=\"line\">│  │      userServer.go           # 自动实现 gRPC-Server 接口的子类</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─svc</span><br><span class=\"line\">│          serviceContext.go        # 依赖注入</span><br><span class=\"line\">│</span><br><span class=\"line\">├─pb</span><br><span class=\"line\">│      user.pb.go               # proto -&gt; go</span><br><span class=\"line\">│      user.proto               # Protobuf3 文件</span><br><span class=\"line\">│      user_grpc.pb.go          # go-gRPC </span><br><span class=\"line\">│</span><br><span class=\"line\">└─user</span><br><span class=\"line\">        user.go                 # 客户端调用接口</span><br></pre></td></tr></table></figure>\n<h3 id=\"RPC调试\"><a href=\"#RPC调试\" class=\"headerlink\" title=\"RPC调试\"></a>RPC调试</h3></li>\n</ol>\n<p><strong>Go gRPC 调试工具</strong>： <a href=\"https://github.com/fullstorydev/grpcui\">gRPC UI</a></p>\n<ul>\n<li>需要以开发者模式启动服务，在<code>/etc/xx.yaml</code>配置文件中添加：  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Mode:</span> <span class=\"string\">dev</span> <span class=\"comment\"># 启动模式：开发模式</span></span><br></pre></td></tr></table></figure></li>\n<li>使用如下命令，以开启调试界面  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grpcui -plaintext localhost:8082</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"API-调用-RPC\"><a href=\"#API-调用-RPC\" class=\"headerlink\" title=\"API 调用 RPC\"></a>API 调用 RPC</h2><ul>\n<li>修改yaml配置文件，配置etcd地址，与服务名</li>\n<li>修改config.go文件，在Config结构体中添加RPC配置信息字段</li>\n<li>在ServerContext结构体中添加goctl生成rpc服务时生成的相关rpcClient</li>\n<li>在业务逻辑中调用相关rpc接口 </li>\n</ul>\n<h2 id=\"创建kafka的topic\"><a href=\"#创建kafka的topic\" class=\"headerlink\" title=\"创建kafka的topic\"></a>创建kafka的topic</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic &#123;topic&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>查看消费者组情况<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server kafka:9092 --describe --group &#123;group&#125;</span><br></pre></td></tr></table></figure></li>\n<li>命令行消费<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh  --bootstrap-server kafka:9092  --topic looklook-log   --from-beginning</span><br></pre></td></tr></table></figure></li>\n<li>命令生产<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --bootstrap-server kafka:9092 --topic second</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"cover":"/img/c2.jpg","excerpt":"","more":"<h1 id=\"go-zero-study\"><a href=\"#go-zero-study\" class=\"headerlink\" title=\"go-zero-study\"></a>go-zero-study</h1><p>Just for studying go-zero framework</p>\n<h2 id=\"安装-go-zero-amp-goctl-Cli\"><a href=\"#安装-go-zero-amp-goctl-Cli\" class=\"headerlink\" title=\"安装 go-zero &amp; goctl Cli\"></a>安装 go-zero &amp; goctl Cli</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Run the following <span class=\"built_in\">command</span> under your project:</span></span><br><span class=\"line\">    go get -u github.com/zeromicro/go-zero</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> Go 1.16 and later</span></span><br><span class=\"line\">    go install github.com/zeromicro/go-zero/tools/goctl@latest</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"API-amp-RPC-语法\"><a href=\"#API-amp-RPC-语法\" class=\"headerlink\" title=\"API &amp; RPC 语法\"></a>API &amp; RPC 语法</h2><p><a href=\"https://go-zero.dev/cn/docs/design/grammar\">官方API语法</a></p>\n<p><a href=\"https://www.jianshu.com/p/4e7f861020d8\">Protobuf语法1</a><br><br><a href=\"https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/#autoid-0-1-0\">Protobuf语法2</a></p>\n<h2 id=\"生成api业务代码-，-进入”服务-cmd-api-desc”目录下，执行下面命令\"><a href=\"#生成api业务代码-，-进入”服务-cmd-api-desc”目录下，执行下面命令\" class=\"headerlink\" title=\"生成api业务代码 ， 进入”服务/cmd/api/desc”目录下，执行下面命令\"></a>生成api业务代码 ， 进入”服务/cmd/api/desc”目录下，执行下面命令</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">goctl api go -api *.api -dir ../  --style=goZero</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>已存在的文件将不再生成，不会造成原文件被覆盖的问题，若需重新生成，须先删除原文件</p>\n</blockquote>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_api:</span><br><span class=\"line\">│  user.go   # 启动文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─api</span><br><span class=\"line\">│      user.api    # API 源文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─etc</span><br><span class=\"line\">│      user-api.yaml    # 配置文件</span><br><span class=\"line\">│</span><br><span class=\"line\">└─internal</span><br><span class=\"line\">    ├─config</span><br><span class=\"line\">    │      config.go    # 配置管理</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─handler</span><br><span class=\"line\">    │      loginHandler.go</span><br><span class=\"line\">    │      routes.go    # 路由</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─logic</span><br><span class=\"line\">    │      loginLogic.go   # 业务逻辑</span><br><span class=\"line\">    │</span><br><span class=\"line\">    ├─svc</span><br><span class=\"line\">    │      serviceContext.go    # 相关依赖注入 </span><br><span class=\"line\">    │</span><br><span class=\"line\">    └─types</span><br><span class=\"line\">            types.go</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成rpc业务代码\"><a href=\"#生成rpc业务代码\" class=\"headerlink\" title=\"生成rpc业务代码\"></a>生成rpc业务代码</h2><blockquote>\n<p>需要安装下面3个插件<br>       protoc &gt;= 3.13.0 ， 如果没安装请先安装 <a href=\"https://github.com/protocolbuffers/protobuf%EF%BC%8C%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%8E%8B%E5%88%B0$GOPATH/bin%E4%B8%8B%E5%8D%B3%E5%8F%AF%EF%BC%8C%E5%89%8D%E6%8F%90%E6%98%AF$GOPATH/bin%E5%B7%B2%E7%BB%8F%E5%8A%A0%E5%85%A5$PATH%E4%B8%AD\">https://github.com/protocolbuffers/protobuf，下载解压到$GOPATH/bin下即可，前提是$GOPATH/bin已经加入$PATH中</a></p>\n</blockquote>\n<ul>\n<li>protoc-gen-go ，如果没有安装请先安装 </li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>\n<ul>\n<li>protoc-gen-go-grpc ，如果没有安装请先安装</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果有要使用grpc-gateway，也请安装如下两个插件 , 没有使用就忽略下面2个插件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest  </span><br><span class=\"line\"> </span><br><span class=\"line\">go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest</span><br></pre></td></tr></table></figure>\n<ol>\n<li>goctl &gt;= 1.3 进入”服务/cmd/rpc/pb”目录下，执行下面命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    goctl rpc protoc *.proto --go_out=../ --go-grpc_out=../  --zrpc_out=../ --style=goZero</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">去除proto中的json的omitempty</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">mac:</span> </span><br><span class=\"line\">    sed -i &quot;&quot; &#x27;s/,omitempty//g&#x27; *.pb.go</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">linux:</span> </span><br><span class=\"line\">    sed -i &#x27;s/,omitempty//g&#x27; *.pb.go</span><br></pre></td></tr></table></figure></li>\n<li>goctl &lt; 1.3 进入”服务/cmd”目录下，执行下面命令<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   goctl rpc proto -src rpc/pb/*.proto -dir ./rpc --style=goZero</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">去除proto中的json的omitempty</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">mac:</span> </span><br><span class=\"line\">   sed -i &quot;&quot; &#x27;s/,omitempty//g&#x27;  ./rpc/pb/*.pb.go</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">linux:</span> </span><br><span class=\"line\">   sed -i &#x27;s/,omitempty//g&#x27;  ./rpc/pb/*.pb.go</span><br></pre></td></tr></table></figure>\n<h3 id=\"目录结构-1\"><a href=\"#目录结构-1\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user_rpc:</span><br><span class=\"line\">│  user.go              # 启动文件</span><br><span class=\"line\">│  </span><br><span class=\"line\">├─etc</span><br><span class=\"line\">│      user.yaml        # 配置文件</span><br><span class=\"line\">│</span><br><span class=\"line\">├─internal</span><br><span class=\"line\">│  ├─config              # 配置管理</span><br><span class=\"line\">│  │      config.go</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─logic</span><br><span class=\"line\">│  │      getUserLogic.go         # 业务逻辑</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─server</span><br><span class=\"line\">│  │      userServer.go           # 自动实现 gRPC-Server 接口的子类</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─svc</span><br><span class=\"line\">│          serviceContext.go        # 依赖注入</span><br><span class=\"line\">│</span><br><span class=\"line\">├─pb</span><br><span class=\"line\">│      user.pb.go               # proto -&gt; go</span><br><span class=\"line\">│      user.proto               # Protobuf3 文件</span><br><span class=\"line\">│      user_grpc.pb.go          # go-gRPC </span><br><span class=\"line\">│</span><br><span class=\"line\">└─user</span><br><span class=\"line\">        user.go                 # 客户端调用接口</span><br></pre></td></tr></table></figure>\n<h3 id=\"RPC调试\"><a href=\"#RPC调试\" class=\"headerlink\" title=\"RPC调试\"></a>RPC调试</h3></li>\n</ol>\n<p><strong>Go gRPC 调试工具</strong>： <a href=\"https://github.com/fullstorydev/grpcui\">gRPC UI</a></p>\n<ul>\n<li>需要以开发者模式启动服务，在<code>/etc/xx.yaml</code>配置文件中添加：  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Mode:</span> <span class=\"string\">dev</span> <span class=\"comment\"># 启动模式：开发模式</span></span><br></pre></td></tr></table></figure></li>\n<li>使用如下命令，以开启调试界面  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grpcui -plaintext localhost:8082</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"API-调用-RPC\"><a href=\"#API-调用-RPC\" class=\"headerlink\" title=\"API 调用 RPC\"></a>API 调用 RPC</h2><ul>\n<li>修改yaml配置文件，配置etcd地址，与服务名</li>\n<li>修改config.go文件，在Config结构体中添加RPC配置信息字段</li>\n<li>在ServerContext结构体中添加goctl生成rpc服务时生成的相关rpcClient</li>\n<li>在业务逻辑中调用相关rpc接口 </li>\n</ul>\n<h2 id=\"创建kafka的topic\"><a href=\"#创建kafka的topic\" class=\"headerlink\" title=\"创建kafka的topic\"></a>创建kafka的topic</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic &#123;topic&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>查看消费者组情况<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-consumer-groups.sh --bootstrap-server kafka:9092 --describe --group &#123;group&#125;</span><br></pre></td></tr></table></figure></li>\n<li>命令行消费<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-consumer.sh  --bootstrap-server kafka:9092  --topic looklook-log   --from-beginning</span><br></pre></td></tr></table></figure></li>\n<li>命令生产<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./kafka-console-producer.sh --bootstrap-server kafka:9092 --topic second</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Go-OpenGL","abbrlink":"7264fd3f","date":"2022-09-14T09:11:24.000Z","_content":"\n## Intro\n\nOpenGL 是当今最广泛的开源图形库，提供了用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。对于图形学基础初学者来说，该库确实是让编程人员与显卡直接交互的最好桥梁。由于本人C++水平不堪，又反感于弱类型的脚本语言，只好退而求其次选择各方面封账都较为完善的Go语言库——`https://github.com/go-gl/gl` 及 `https://github.com/go-gl/glfw`。\n\n![](https://pic1.zhimg.com/v2-d315ea26866b2ea204e06f3f73787dc5_qhd.jpg?source=57bbeac9)\n\n## Installation\n\n```bash\n# 安装OpenGL\n$ go install github.com/go-gl/gl/v4.1-core/gl@latest\n# 安装GLFW应用框架\n$ go install github.com/go-gl/glfw/v3.3/glfw@latest\n```\n\n>   GLFW 主要用来处理特定操作系统下的特定任务，例如 OpenGL 窗口管理、分辨率切换、键盘、鼠标以及游戏手柄、定时器输入、线程创建等等。\n\n### OpenGL ES\n\n针对手机、PDA和游戏主机等嵌入式设备而设计。\n\nIf your target system only provides an OpenGL ES implementation (true for some ARM boards), you need to link against that implementation. You do this by defining the appropriate build tags, e.g.\n\n```\ngo get -u -tags=gles2 github.com/go-gl/glfw/v3.3/glfw\n```\n\n\n\n## Sample\n\n[简单样例](https://linux.cn/article-8933-1.html)     [Github](https://github.com/KyleBanks/conways-gol)\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/rand\"\n    \"runtime\"\n    \"strings\"\n    \"time\"\n    \"github.com/go-gl/gl/v4.1-core/gl\" // OR: github.com/go-gl/gl/v2.1/gl\n    \"github.com/go-gl/glfw/v3.3/glfw\"\n)\nconst (\n    width  = 500\n    height = 500\n    vertexShaderSource = `\n        #version 410\n        in vec3 vp;\n        void main() {\n            gl_Position = vec4(vp, 1.0);\n        }\n    ` + \"\\x00\"\n    fragmentShaderSource = `\n        #version 410\n        out vec4 frag_colour;\n        void main() {\n            frag_colour = vec4(1, 1, 1, 1.0);\n        }\n    ` + \"\\x00\"\n    rows    = 100\n    columns = 100\n    threshold = 0.15\n    fps       = 10\n)\nvar (\n    square = []float32{\n        -0.5, 0.5, 0,\n        -0.5, -0.5, 0,\n        0.5, -0.5, 0,\n        -0.5, 0.5, 0,\n        0.5, 0.5, 0,\n        0.5, -0.5, 0,\n    }\n)\ntype cell struct {\n    drawable uint32\n    alive     bool\n    aliveNext bool\n    x int\n    y int\n}\nfunc main() {\n    runtime.LockOSThread()\n    window := initGlfw()\n    defer glfw.Terminate()\n    program := initOpenGL()\n    cells := makeCells()\n    for !window.ShouldClose() {\n        t := time.Now()\n        for x := range cells {\n            for _, c := range cells[x] {\n                c.checkState(cells)\n            }\n        }\n        draw(cells, window, program)\n        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))\n    }\n}\nfunc draw(cells [][]*cell, window *glfw.Window, program uint32) {\n    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.UseProgram(program)\n    for x := range cells {\n        for _, c := range cells[x] {\n            c.draw()\n        }\n    }\n    glfw.PollEvents()\n    window.SwapBuffers()\n}\nfunc makeCells() [][]*cell {\n    rand.Seed(time.Now().UnixNano())\n    cells := make([][]*cell, rows, rows)\n    for x := 0; x < rows; x++ {\n        for y := 0; y < columns; y++ {\n            c := newCell(x, y)\n            c.alive = rand.Float64() < threshold\n            c.aliveNext = c.alive\n            cells[x] = append(cells[x], c)\n        }\n    }\n    return cells\n}\nfunc newCell(x, y int) *cell {\n    points := make([]float32, len(square), len(square))\n    copy(points, square)\n    for i := 0; i < len(points); i++ {\n        var position float32\n        var size float32\n        switch i % 3 {\n        case 0:\n            size = 1.0 / float32(columns)\n            position = float32(x) * size\n        case 1:\n            size = 1.0 / float32(rows)\n            position = float32(y) * size\n        default:\n            continue\n        }\n        if points[i] < 0 {\n            points[i] = (position * 2) - 1\n        } else {\n            points[i] = ((position + size) * 2) - 1\n        }\n    }\n    return &cell{\n        drawable: makeVao(points),\n        x: x,\n        y: y,\n    }\n}\nfunc (c *cell) draw() {\n    if !c.alive {\n        return\n    }\n    gl.BindVertexArray(c.drawable)\n    gl.DrawArrays(gl.TRIANGLES, 0, int32(len(square)/3))\n}\n// checkState 函数决定下一次游戏循环时的 cell 状态\nfunc (c *cell) checkState(cells [][]*cell) {\n    c.alive = c.aliveNext\n    c.aliveNext = c.alive\n    liveCount := c.liveNeighbors(cells)\n    if c.alive {\n        // 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样\n        if liveCount < 2 {\n            c.aliveNext = false\n        }\n        // 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。\n        if liveCount == 2 || liveCount == 3 {\n            c.aliveNext = true\n        }\n        // 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样\n        if liveCount > 3 {\n            c.aliveNext = false\n        }\n    } else {\n        // 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。\n        if liveCount == 3 {\n            c.aliveNext = true\n        }\n    }\n}\n// liveNeighbors 函数返回当前 cell 附近存活的 cell 数\nfunc (c *cell) liveNeighbors(cells [][]*cell) int {\n    var liveCount int\n    add := func(x, y int) {\n        // If we're at an edge, check the other side of the board.\n        if x == len(cells) {\n            x = 0\n        } else if x == -1 {\n            x = len(cells) - 1\n        }\n        if y == len(cells[x]) {\n            y = 0\n        } else if y == -1 {\n            y = len(cells[x]) - 1\n        }\n        if cells[x][y].alive {\n            liveCount++\n        }\n    }\n    add(c.x-1, c.y)   // To the left\n    add(c.x+1, c.y)   // To the right\n    add(c.x, c.y+1)   // up\n    add(c.x, c.y-1)   // down\n    add(c.x-1, c.y+1) // top-left\n    add(c.x+1, c.y+1) // top-right\n    add(c.x-1, c.y-1) // bottom-left\n    add(c.x+1, c.y-1) // bottom-right\n    return liveCount\n}\n// initGlfw 初始化 glfw，返回一个可用的 Window\nfunc initGlfw() *glfw.Window {\n    if err := glfw.Init(); err != nil {\n        panic(err)\n    }\n    glfw.WindowHint(glfw.Resizable, glfw.False)\n    glfw.WindowHint(glfw.ContextVersionMajor, 4)\n    glfw.WindowHint(glfw.ContextVersionMinor, 1)\n    glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)\n    glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)\n    window, err := glfw.CreateWindow(width, height, \"Conway's Game of Life\", nil, nil)\n    if err != nil {\n        panic(err)\n    }\n    window.MakeContextCurrent()\n    return window\n}\n// initOpenGL 初始化 OpenGL 并返回一个已经编译好的着色器程序\nfunc initOpenGL() uint32 {\n    if err := gl.Init(); err != nil {\n        panic(err)\n    }\n    version := gl.GoStr(gl.GetString(gl.VERSION))\n    log.Println(\"OpenGL version\", version)\n    vertexShader, err := compileShader(vertexShaderSource, gl.VERTEX_SHADER)\n    if err != nil {\n        panic(err)\n    }\n    fragmentShader, err := compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER)\n    if err != nil {\n        panic(err)\n    }\n    prog := gl.CreateProgram()\n    gl.AttachShader(prog, vertexShader)\n    gl.AttachShader(prog, fragmentShader)\n    gl.LinkProgram(prog)\n    return prog\n}\n// makeVao 初始化并从提供的点里面返回一个顶点数组\nfunc makeVao(points []float32) uint32 {\n    var vbo uint32\n    gl.GenBuffers(1, &vbo)\n    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)\n    gl.BufferData(gl.ARRAY_BUFFER, 4*len(points), gl.Ptr(points), gl.STATIC_DRAW)\n    var vao uint32\n    gl.GenVertexArrays(1, &vao)\n    gl.BindVertexArray(vao)\n    gl.EnableVertexAttribArray(0)\n    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)\n    gl.VertexAttribPointer(0, 3, gl.FLOAT, false, 0, nil)\n    return vao\n}\nfunc compileShader(source string, shaderType uint32) (uint32, error) {\n    shader := gl.CreateShader(shaderType)\n    csources, free := gl.Strs(source)\n    gl.ShaderSource(shader, 1, csources, nil)\n    free()\n    gl.CompileShader(shader)\n    var status int32\n    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &status)\n    if status == gl.FALSE {\n        var logLength int32\n        gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &logLength)\n        log := strings.Repeat(\"\\x00\", int(logLength+1))\n        gl.GetShaderInfoLog(shader, logLength, nil, gl.Str(log))\n        return 0, fmt.Errorf(\"failed to compile %v: %v\", source, log)\n    }\n    return shader, nil\n}\n```\n\n","source":"_posts/Go-OpenGL.md","raw":"---\ntitle: Go-OpenGL\ntags:\n  - OpenGL\n  - 图形学\ncategories:\n  - 图形学\nabbrlink: 7264fd3f\ndate: 2022-09-14 17:11:24\n---\n\n## Intro\n\nOpenGL 是当今最广泛的开源图形库，提供了用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。对于图形学基础初学者来说，该库确实是让编程人员与显卡直接交互的最好桥梁。由于本人C++水平不堪，又反感于弱类型的脚本语言，只好退而求其次选择各方面封账都较为完善的Go语言库——`https://github.com/go-gl/gl` 及 `https://github.com/go-gl/glfw`。\n\n![](https://pic1.zhimg.com/v2-d315ea26866b2ea204e06f3f73787dc5_qhd.jpg?source=57bbeac9)\n\n## Installation\n\n```bash\n# 安装OpenGL\n$ go install github.com/go-gl/gl/v4.1-core/gl@latest\n# 安装GLFW应用框架\n$ go install github.com/go-gl/glfw/v3.3/glfw@latest\n```\n\n>   GLFW 主要用来处理特定操作系统下的特定任务，例如 OpenGL 窗口管理、分辨率切换、键盘、鼠标以及游戏手柄、定时器输入、线程创建等等。\n\n### OpenGL ES\n\n针对手机、PDA和游戏主机等嵌入式设备而设计。\n\nIf your target system only provides an OpenGL ES implementation (true for some ARM boards), you need to link against that implementation. You do this by defining the appropriate build tags, e.g.\n\n```\ngo get -u -tags=gles2 github.com/go-gl/glfw/v3.3/glfw\n```\n\n\n\n## Sample\n\n[简单样例](https://linux.cn/article-8933-1.html)     [Github](https://github.com/KyleBanks/conways-gol)\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/rand\"\n    \"runtime\"\n    \"strings\"\n    \"time\"\n    \"github.com/go-gl/gl/v4.1-core/gl\" // OR: github.com/go-gl/gl/v2.1/gl\n    \"github.com/go-gl/glfw/v3.3/glfw\"\n)\nconst (\n    width  = 500\n    height = 500\n    vertexShaderSource = `\n        #version 410\n        in vec3 vp;\n        void main() {\n            gl_Position = vec4(vp, 1.0);\n        }\n    ` + \"\\x00\"\n    fragmentShaderSource = `\n        #version 410\n        out vec4 frag_colour;\n        void main() {\n            frag_colour = vec4(1, 1, 1, 1.0);\n        }\n    ` + \"\\x00\"\n    rows    = 100\n    columns = 100\n    threshold = 0.15\n    fps       = 10\n)\nvar (\n    square = []float32{\n        -0.5, 0.5, 0,\n        -0.5, -0.5, 0,\n        0.5, -0.5, 0,\n        -0.5, 0.5, 0,\n        0.5, 0.5, 0,\n        0.5, -0.5, 0,\n    }\n)\ntype cell struct {\n    drawable uint32\n    alive     bool\n    aliveNext bool\n    x int\n    y int\n}\nfunc main() {\n    runtime.LockOSThread()\n    window := initGlfw()\n    defer glfw.Terminate()\n    program := initOpenGL()\n    cells := makeCells()\n    for !window.ShouldClose() {\n        t := time.Now()\n        for x := range cells {\n            for _, c := range cells[x] {\n                c.checkState(cells)\n            }\n        }\n        draw(cells, window, program)\n        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))\n    }\n}\nfunc draw(cells [][]*cell, window *glfw.Window, program uint32) {\n    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n    gl.UseProgram(program)\n    for x := range cells {\n        for _, c := range cells[x] {\n            c.draw()\n        }\n    }\n    glfw.PollEvents()\n    window.SwapBuffers()\n}\nfunc makeCells() [][]*cell {\n    rand.Seed(time.Now().UnixNano())\n    cells := make([][]*cell, rows, rows)\n    for x := 0; x < rows; x++ {\n        for y := 0; y < columns; y++ {\n            c := newCell(x, y)\n            c.alive = rand.Float64() < threshold\n            c.aliveNext = c.alive\n            cells[x] = append(cells[x], c)\n        }\n    }\n    return cells\n}\nfunc newCell(x, y int) *cell {\n    points := make([]float32, len(square), len(square))\n    copy(points, square)\n    for i := 0; i < len(points); i++ {\n        var position float32\n        var size float32\n        switch i % 3 {\n        case 0:\n            size = 1.0 / float32(columns)\n            position = float32(x) * size\n        case 1:\n            size = 1.0 / float32(rows)\n            position = float32(y) * size\n        default:\n            continue\n        }\n        if points[i] < 0 {\n            points[i] = (position * 2) - 1\n        } else {\n            points[i] = ((position + size) * 2) - 1\n        }\n    }\n    return &cell{\n        drawable: makeVao(points),\n        x: x,\n        y: y,\n    }\n}\nfunc (c *cell) draw() {\n    if !c.alive {\n        return\n    }\n    gl.BindVertexArray(c.drawable)\n    gl.DrawArrays(gl.TRIANGLES, 0, int32(len(square)/3))\n}\n// checkState 函数决定下一次游戏循环时的 cell 状态\nfunc (c *cell) checkState(cells [][]*cell) {\n    c.alive = c.aliveNext\n    c.aliveNext = c.alive\n    liveCount := c.liveNeighbors(cells)\n    if c.alive {\n        // 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样\n        if liveCount < 2 {\n            c.aliveNext = false\n        }\n        // 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。\n        if liveCount == 2 || liveCount == 3 {\n            c.aliveNext = true\n        }\n        // 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样\n        if liveCount > 3 {\n            c.aliveNext = false\n        }\n    } else {\n        // 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。\n        if liveCount == 3 {\n            c.aliveNext = true\n        }\n    }\n}\n// liveNeighbors 函数返回当前 cell 附近存活的 cell 数\nfunc (c *cell) liveNeighbors(cells [][]*cell) int {\n    var liveCount int\n    add := func(x, y int) {\n        // If we're at an edge, check the other side of the board.\n        if x == len(cells) {\n            x = 0\n        } else if x == -1 {\n            x = len(cells) - 1\n        }\n        if y == len(cells[x]) {\n            y = 0\n        } else if y == -1 {\n            y = len(cells[x]) - 1\n        }\n        if cells[x][y].alive {\n            liveCount++\n        }\n    }\n    add(c.x-1, c.y)   // To the left\n    add(c.x+1, c.y)   // To the right\n    add(c.x, c.y+1)   // up\n    add(c.x, c.y-1)   // down\n    add(c.x-1, c.y+1) // top-left\n    add(c.x+1, c.y+1) // top-right\n    add(c.x-1, c.y-1) // bottom-left\n    add(c.x+1, c.y-1) // bottom-right\n    return liveCount\n}\n// initGlfw 初始化 glfw，返回一个可用的 Window\nfunc initGlfw() *glfw.Window {\n    if err := glfw.Init(); err != nil {\n        panic(err)\n    }\n    glfw.WindowHint(glfw.Resizable, glfw.False)\n    glfw.WindowHint(glfw.ContextVersionMajor, 4)\n    glfw.WindowHint(glfw.ContextVersionMinor, 1)\n    glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)\n    glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)\n    window, err := glfw.CreateWindow(width, height, \"Conway's Game of Life\", nil, nil)\n    if err != nil {\n        panic(err)\n    }\n    window.MakeContextCurrent()\n    return window\n}\n// initOpenGL 初始化 OpenGL 并返回一个已经编译好的着色器程序\nfunc initOpenGL() uint32 {\n    if err := gl.Init(); err != nil {\n        panic(err)\n    }\n    version := gl.GoStr(gl.GetString(gl.VERSION))\n    log.Println(\"OpenGL version\", version)\n    vertexShader, err := compileShader(vertexShaderSource, gl.VERTEX_SHADER)\n    if err != nil {\n        panic(err)\n    }\n    fragmentShader, err := compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER)\n    if err != nil {\n        panic(err)\n    }\n    prog := gl.CreateProgram()\n    gl.AttachShader(prog, vertexShader)\n    gl.AttachShader(prog, fragmentShader)\n    gl.LinkProgram(prog)\n    return prog\n}\n// makeVao 初始化并从提供的点里面返回一个顶点数组\nfunc makeVao(points []float32) uint32 {\n    var vbo uint32\n    gl.GenBuffers(1, &vbo)\n    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)\n    gl.BufferData(gl.ARRAY_BUFFER, 4*len(points), gl.Ptr(points), gl.STATIC_DRAW)\n    var vao uint32\n    gl.GenVertexArrays(1, &vao)\n    gl.BindVertexArray(vao)\n    gl.EnableVertexAttribArray(0)\n    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)\n    gl.VertexAttribPointer(0, 3, gl.FLOAT, false, 0, nil)\n    return vao\n}\nfunc compileShader(source string, shaderType uint32) (uint32, error) {\n    shader := gl.CreateShader(shaderType)\n    csources, free := gl.Strs(source)\n    gl.ShaderSource(shader, 1, csources, nil)\n    free()\n    gl.CompileShader(shader)\n    var status int32\n    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &status)\n    if status == gl.FALSE {\n        var logLength int32\n        gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &logLength)\n        log := strings.Repeat(\"\\x00\", int(logLength+1))\n        gl.GetShaderInfoLog(shader, logLength, nil, gl.Str(log))\n        return 0, fmt.Errorf(\"failed to compile %v: %v\", source, log)\n    }\n    return shader, nil\n}\n```\n\n","slug":"Go-OpenGL","published":1,"updated":"2022-09-15T15:30:02.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjk000aecwd79dq7n92","content":"<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><p>OpenGL 是当今最广泛的开源图形库，提供了用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。对于图形学基础初学者来说，该库确实是让编程人员与显卡直接交互的最好桥梁。由于本人C++水平不堪，又反感于弱类型的脚本语言，只好退而求其次选择各方面封账都较为完善的Go语言库——<code>https://github.com/go-gl/gl</code> 及 <code>https://github.com/go-gl/glfw</code>。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-d315ea26866b2ea204e06f3f73787dc5_qhd.jpg?source=57bbeac9\"></p>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装OpenGL</span></span><br><span class=\"line\">$ go install github.com/go-gl/gl/v4.1-core/gl@latest</span><br><span class=\"line\"><span class=\"comment\"># 安装GLFW应用框架</span></span><br><span class=\"line\">$ go install github.com/go-gl/glfw/v3.3/glfw@latest</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  GLFW 主要用来处理特定操作系统下的特定任务，例如 OpenGL 窗口管理、分辨率切换、键盘、鼠标以及游戏手柄、定时器输入、线程创建等等。</p>\n</blockquote>\n<h3 id=\"OpenGL-ES\"><a href=\"#OpenGL-ES\" class=\"headerlink\" title=\"OpenGL ES\"></a>OpenGL ES</h3><p>针对手机、PDA和游戏主机等嵌入式设备而设计。</p>\n<p>If your target system only provides an OpenGL ES implementation (true for some ARM boards), you need to link against that implementation. You do this by defining the appropriate build tags, e.g.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u -tags=gles2 github.com/go-gl/glfw/v3.3/glfw</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Sample\"><a href=\"#Sample\" class=\"headerlink\" title=\"Sample\"></a>Sample</h2><p><a href=\"https://linux.cn/article-8933-1.html\">简单样例</a>     <a href=\"https://github.com/KyleBanks/conways-gol\">Github</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;runtime&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-gl/gl/v4.1-core/gl&quot;</span> <span class=\"comment\">// OR: github.com/go-gl/gl/v2.1/gl</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-gl/glfw/v3.3/glfw&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    width  = <span class=\"number\">500</span></span><br><span class=\"line\">    height = <span class=\"number\">500</span></span><br><span class=\"line\">    vertexShaderSource = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        #version 410</span></span><br><span class=\"line\"><span class=\"string\">        in vec3 vp;</span></span><br><span class=\"line\"><span class=\"string\">        void main() &#123;</span></span><br><span class=\"line\"><span class=\"string\">            gl_Position = vec4(vp, 1.0);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span> + <span class=\"string\">&quot;\\x00&quot;</span></span><br><span class=\"line\">    fragmentShaderSource = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        #version 410</span></span><br><span class=\"line\"><span class=\"string\">        out vec4 frag_colour;</span></span><br><span class=\"line\"><span class=\"string\">        void main() &#123;</span></span><br><span class=\"line\"><span class=\"string\">            frag_colour = vec4(1, 1, 1, 1.0);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span> + <span class=\"string\">&quot;\\x00&quot;</span></span><br><span class=\"line\">    rows    = <span class=\"number\">100</span></span><br><span class=\"line\">    columns = <span class=\"number\">100</span></span><br><span class=\"line\">    threshold = <span class=\"number\">0.15</span></span><br><span class=\"line\">    fps       = <span class=\"number\">10</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    square = []<span class=\"type\">float32</span>&#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">type</span> cell <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    drawable <span class=\"type\">uint32</span></span><br><span class=\"line\">    alive     <span class=\"type\">bool</span></span><br><span class=\"line\">    aliveNext <span class=\"type\">bool</span></span><br><span class=\"line\">    x <span class=\"type\">int</span></span><br><span class=\"line\">    y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime.LockOSThread()</span><br><span class=\"line\">    window := initGlfw()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> glfw.Terminate()</span><br><span class=\"line\">    program := initOpenGL()</span><br><span class=\"line\">    cells := makeCells()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> !window.ShouldClose() &#123;</span><br><span class=\"line\">        t := time.Now()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> cells &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cells[x] &#123;</span><br><span class=\"line\">                c.checkState(cells)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        draw(cells, window, program)</span><br><span class=\"line\">        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">draw</span><span class=\"params\">(cells [][]*cell, window *glfw.Window, program <span class=\"type\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)</span><br><span class=\"line\">    gl.UseProgram(program)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> cells &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cells[x] &#123;</span><br><span class=\"line\">            c.draw()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfw.PollEvents()</span><br><span class=\"line\">    window.SwapBuffers()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCells</span><span class=\"params\">()</span></span> [][]*cell &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\">    cells := <span class=\"built_in\">make</span>([][]*cell, rows, rows)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; rows; x++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> y := <span class=\"number\">0</span>; y &lt; columns; y++ &#123;</span><br><span class=\"line\">            c := newCell(x, y)</span><br><span class=\"line\">            c.alive = rand.Float64() &lt; threshold</span><br><span class=\"line\">            c.aliveNext = c.alive</span><br><span class=\"line\">            cells[x] = <span class=\"built_in\">append</span>(cells[x], c)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cells</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCell</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> *cell &#123;</span><br><span class=\"line\">    points := <span class=\"built_in\">make</span>([]<span class=\"type\">float32</span>, <span class=\"built_in\">len</span>(square), <span class=\"built_in\">len</span>(square))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(points, square)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(points); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> position <span class=\"type\">float32</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> size <span class=\"type\">float32</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> i % <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            size = <span class=\"number\">1.0</span> / <span class=\"type\">float32</span>(columns)</span><br><span class=\"line\">            position = <span class=\"type\">float32</span>(x) * size</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            size = <span class=\"number\">1.0</span> / <span class=\"type\">float32</span>(rows)</span><br><span class=\"line\">            position = <span class=\"type\">float32</span>(y) * size</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> points[i] &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            points[i] = (position * <span class=\"number\">2</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            points[i] = ((position + size) * <span class=\"number\">2</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;cell&#123;</span><br><span class=\"line\">        drawable: makeVao(points),</span><br><span class=\"line\">        x: x,</span><br><span class=\"line\">        y: y,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> draw() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !c.alive &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gl.BindVertexArray(c.drawable)</span><br><span class=\"line\">    gl.DrawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"type\">int32</span>(<span class=\"built_in\">len</span>(square)/<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// checkState 函数决定下一次游戏循环时的 cell 状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> checkState(cells [][]*cell) &#123;</span><br><span class=\"line\">    c.alive = c.aliveNext</span><br><span class=\"line\">    c.aliveNext = c.alive</span><br><span class=\"line\">    liveCount := c.liveNeighbors(cells)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c.alive &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount == <span class=\"number\">2</span> || liveCount == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount &gt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// liveNeighbors 函数返回当前 cell 附近存活的 cell 数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> liveNeighbors(cells [][]*cell) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> liveCount <span class=\"type\">int</span></span><br><span class=\"line\">    add := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we&#x27;re at an edge, check the other side of the board.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"built_in\">len</span>(cells) &#123;</span><br><span class=\"line\">            x = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            x = <span class=\"built_in\">len</span>(cells) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> y == <span class=\"built_in\">len</span>(cells[x]) &#123;</span><br><span class=\"line\">            y = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            y = <span class=\"built_in\">len</span>(cells[x]) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cells[x][y].alive &#123;</span><br><span class=\"line\">            liveCount++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y)   <span class=\"comment\">// To the left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y)   <span class=\"comment\">// To the right</span></span><br><span class=\"line\">    add(c.x, c.y+<span class=\"number\">1</span>)   <span class=\"comment\">// up</span></span><br><span class=\"line\">    add(c.x, c.y<span class=\"number\">-1</span>)   <span class=\"comment\">// down</span></span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y+<span class=\"number\">1</span>) <span class=\"comment\">// top-left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y+<span class=\"number\">1</span>) <span class=\"comment\">// top-right</span></span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y<span class=\"number\">-1</span>) <span class=\"comment\">// bottom-left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y<span class=\"number\">-1</span>) <span class=\"comment\">// bottom-right</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveCount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// initGlfw 初始化 glfw，返回一个可用的 Window</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initGlfw</span><span class=\"params\">()</span></span> *glfw.Window &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := glfw.Init(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfw.WindowHint(glfw.Resizable, glfw.False)</span><br><span class=\"line\">    glfw.WindowHint(glfw.ContextVersionMajor, <span class=\"number\">4</span>)</span><br><span class=\"line\">    glfw.WindowHint(glfw.ContextVersionMinor, <span class=\"number\">1</span>)</span><br><span class=\"line\">    glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)</span><br><span class=\"line\">    glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)</span><br><span class=\"line\">    window, err := glfw.CreateWindow(width, height, <span class=\"string\">&quot;Conway&#x27;s Game of Life&quot;</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.MakeContextCurrent()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// initOpenGL 初始化 OpenGL 并返回一个已经编译好的着色器程序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initOpenGL</span><span class=\"params\">()</span></span> <span class=\"type\">uint32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := gl.Init(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    version := gl.GoStr(gl.GetString(gl.VERSION))</span><br><span class=\"line\">    log.Println(<span class=\"string\">&quot;OpenGL version&quot;</span>, version)</span><br><span class=\"line\">    vertexShader, err := compileShader(vertexShaderSource, gl.VERTEX_SHADER)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragmentShader, err := compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prog := gl.CreateProgram()</span><br><span class=\"line\">    gl.AttachShader(prog, vertexShader)</span><br><span class=\"line\">    gl.AttachShader(prog, fragmentShader)</span><br><span class=\"line\">    gl.LinkProgram(prog)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// makeVao 初始化并从提供的点里面返回一个顶点数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeVao</span><span class=\"params\">(points []<span class=\"type\">float32</span>)</span></span> <span class=\"type\">uint32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vbo <span class=\"type\">uint32</span></span><br><span class=\"line\">    gl.GenBuffers(<span class=\"number\">1</span>, &amp;vbo)</span><br><span class=\"line\">    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)</span><br><span class=\"line\">    gl.BufferData(gl.ARRAY_BUFFER, <span class=\"number\">4</span>*<span class=\"built_in\">len</span>(points), gl.Ptr(points), gl.STATIC_DRAW)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vao <span class=\"type\">uint32</span></span><br><span class=\"line\">    gl.GenVertexArrays(<span class=\"number\">1</span>, &amp;vao)</span><br><span class=\"line\">    gl.BindVertexArray(vao)</span><br><span class=\"line\">    gl.EnableVertexAttribArray(<span class=\"number\">0</span>)</span><br><span class=\"line\">    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)</span><br><span class=\"line\">    gl.VertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, <span class=\"number\">0</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vao</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compileShader</span><span class=\"params\">(source <span class=\"type\">string</span>, shaderType <span class=\"type\">uint32</span>)</span></span> (<span class=\"type\">uint32</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    shader := gl.CreateShader(shaderType)</span><br><span class=\"line\">    csources, free := gl.Strs(source)</span><br><span class=\"line\">    gl.ShaderSource(shader, <span class=\"number\">1</span>, csources, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    free()</span><br><span class=\"line\">    gl.CompileShader(shader)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> status <span class=\"type\">int32</span></span><br><span class=\"line\">    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &amp;status)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> status == gl.FALSE &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> logLength <span class=\"type\">int32</span></span><br><span class=\"line\">        gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &amp;logLength)</span><br><span class=\"line\">        log := strings.Repeat(<span class=\"string\">&quot;\\x00&quot;</span>, <span class=\"type\">int</span>(logLength+<span class=\"number\">1</span>))</span><br><span class=\"line\">        gl.GetShaderInfoLog(shader, logLength, <span class=\"literal\">nil</span>, gl.Str(log))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, fmt.Errorf(<span class=\"string\">&quot;failed to compile %v: %v&quot;</span>, source, log)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/img/c9.jpg","excerpt":"","more":"<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><p>OpenGL 是当今最广泛的开源图形库，提供了用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。对于图形学基础初学者来说，该库确实是让编程人员与显卡直接交互的最好桥梁。由于本人C++水平不堪，又反感于弱类型的脚本语言，只好退而求其次选择各方面封账都较为完善的Go语言库——<code>https://github.com/go-gl/gl</code> 及 <code>https://github.com/go-gl/glfw</code>。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-d315ea26866b2ea204e06f3f73787dc5_qhd.jpg?source=57bbeac9\"></p>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装OpenGL</span></span><br><span class=\"line\">$ go install github.com/go-gl/gl/v4.1-core/gl@latest</span><br><span class=\"line\"><span class=\"comment\"># 安装GLFW应用框架</span></span><br><span class=\"line\">$ go install github.com/go-gl/glfw/v3.3/glfw@latest</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>  GLFW 主要用来处理特定操作系统下的特定任务，例如 OpenGL 窗口管理、分辨率切换、键盘、鼠标以及游戏手柄、定时器输入、线程创建等等。</p>\n</blockquote>\n<h3 id=\"OpenGL-ES\"><a href=\"#OpenGL-ES\" class=\"headerlink\" title=\"OpenGL ES\"></a>OpenGL ES</h3><p>针对手机、PDA和游戏主机等嵌入式设备而设计。</p>\n<p>If your target system only provides an OpenGL ES implementation (true for some ARM boards), you need to link against that implementation. You do this by defining the appropriate build tags, e.g.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u -tags=gles2 github.com/go-gl/glfw/v3.3/glfw</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Sample\"><a href=\"#Sample\" class=\"headerlink\" title=\"Sample\"></a>Sample</h2><p><a href=\"https://linux.cn/article-8933-1.html\">简单样例</a>     <a href=\"https://github.com/KyleBanks/conways-gol\">Github</a></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;runtime&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-gl/gl/v4.1-core/gl&quot;</span> <span class=\"comment\">// OR: github.com/go-gl/gl/v2.1/gl</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-gl/glfw/v3.3/glfw&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    width  = <span class=\"number\">500</span></span><br><span class=\"line\">    height = <span class=\"number\">500</span></span><br><span class=\"line\">    vertexShaderSource = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        #version 410</span></span><br><span class=\"line\"><span class=\"string\">        in vec3 vp;</span></span><br><span class=\"line\"><span class=\"string\">        void main() &#123;</span></span><br><span class=\"line\"><span class=\"string\">            gl_Position = vec4(vp, 1.0);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span> + <span class=\"string\">&quot;\\x00&quot;</span></span><br><span class=\"line\">    fragmentShaderSource = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        #version 410</span></span><br><span class=\"line\"><span class=\"string\">        out vec4 frag_colour;</span></span><br><span class=\"line\"><span class=\"string\">        void main() &#123;</span></span><br><span class=\"line\"><span class=\"string\">            frag_colour = vec4(1, 1, 1, 1.0);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span> + <span class=\"string\">&quot;\\x00&quot;</span></span><br><span class=\"line\">    rows    = <span class=\"number\">100</span></span><br><span class=\"line\">    columns = <span class=\"number\">100</span></span><br><span class=\"line\">    threshold = <span class=\"number\">0.15</span></span><br><span class=\"line\">    fps       = <span class=\"number\">10</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    square = []<span class=\"type\">float32</span>&#123;</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">-0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">type</span> cell <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    drawable <span class=\"type\">uint32</span></span><br><span class=\"line\">    alive     <span class=\"type\">bool</span></span><br><span class=\"line\">    aliveNext <span class=\"type\">bool</span></span><br><span class=\"line\">    x <span class=\"type\">int</span></span><br><span class=\"line\">    y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime.LockOSThread()</span><br><span class=\"line\">    window := initGlfw()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> glfw.Terminate()</span><br><span class=\"line\">    program := initOpenGL()</span><br><span class=\"line\">    cells := makeCells()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> !window.ShouldClose() &#123;</span><br><span class=\"line\">        t := time.Now()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> cells &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cells[x] &#123;</span><br><span class=\"line\">                c.checkState(cells)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        draw(cells, window, program)</span><br><span class=\"line\">        time.Sleep(time.Second/time.Duration(fps) - time.Since(t))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">draw</span><span class=\"params\">(cells [][]*cell, window *glfw.Window, program <span class=\"type\">uint32</span>)</span></span> &#123;</span><br><span class=\"line\">    gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)</span><br><span class=\"line\">    gl.UseProgram(program)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x := <span class=\"keyword\">range</span> cells &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, c := <span class=\"keyword\">range</span> cells[x] &#123;</span><br><span class=\"line\">            c.draw()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfw.PollEvents()</span><br><span class=\"line\">    window.SwapBuffers()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeCells</span><span class=\"params\">()</span></span> [][]*cell &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().UnixNano())</span><br><span class=\"line\">    cells := <span class=\"built_in\">make</span>([][]*cell, rows, rows)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; rows; x++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> y := <span class=\"number\">0</span>; y &lt; columns; y++ &#123;</span><br><span class=\"line\">            c := newCell(x, y)</span><br><span class=\"line\">            c.alive = rand.Float64() &lt; threshold</span><br><span class=\"line\">            c.aliveNext = c.alive</span><br><span class=\"line\">            cells[x] = <span class=\"built_in\">append</span>(cells[x], c)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cells</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCell</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> *cell &#123;</span><br><span class=\"line\">    points := <span class=\"built_in\">make</span>([]<span class=\"type\">float32</span>, <span class=\"built_in\">len</span>(square), <span class=\"built_in\">len</span>(square))</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(points, square)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(points); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> position <span class=\"type\">float32</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> size <span class=\"type\">float32</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> i % <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            size = <span class=\"number\">1.0</span> / <span class=\"type\">float32</span>(columns)</span><br><span class=\"line\">            position = <span class=\"type\">float32</span>(x) * size</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            size = <span class=\"number\">1.0</span> / <span class=\"type\">float32</span>(rows)</span><br><span class=\"line\">            position = <span class=\"type\">float32</span>(y) * size</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> points[i] &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            points[i] = (position * <span class=\"number\">2</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            points[i] = ((position + size) * <span class=\"number\">2</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;cell&#123;</span><br><span class=\"line\">        drawable: makeVao(points),</span><br><span class=\"line\">        x: x,</span><br><span class=\"line\">        y: y,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> draw() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !c.alive &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gl.BindVertexArray(c.drawable)</span><br><span class=\"line\">    gl.DrawArrays(gl.TRIANGLES, <span class=\"number\">0</span>, <span class=\"type\">int32</span>(<span class=\"built_in\">len</span>(square)/<span class=\"number\">3</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// checkState 函数决定下一次游戏循环时的 cell 状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> checkState(cells [][]*cell) &#123;</span><br><span class=\"line\">    c.alive = c.aliveNext</span><br><span class=\"line\">    c.aliveNext = c.alive</span><br><span class=\"line\">    liveCount := c.liveNeighbors(cells)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c.alive &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 当任何一个存活的 cell 的附近少于 2 个存活的 cell 时，该 cell 将会消亡，就像人口过少所导致的结果一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 当任何一个存活的 cell 的附近有 2 至 3 个存活的 cell 时，该 cell 在下一代中仍然存活。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount == <span class=\"number\">2</span> || liveCount == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 当任何一个存活的 cell 的附近多于 3 个存活的 cell 时，该 cell 将会消亡，就像人口过多所导致的结果一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount &gt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 任何一个消亡的 cell 附近刚好有 3 个存活的 cell，该 cell 会变为存活的状态，就像重生一样。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> liveCount == <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">            c.aliveNext = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// liveNeighbors 函数返回当前 cell 附近存活的 cell 数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cell)</span></span> liveNeighbors(cells [][]*cell) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> liveCount <span class=\"type\">int</span></span><br><span class=\"line\">    add := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we&#x27;re at an edge, check the other side of the board.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x == <span class=\"built_in\">len</span>(cells) &#123;</span><br><span class=\"line\">            x = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            x = <span class=\"built_in\">len</span>(cells) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> y == <span class=\"built_in\">len</span>(cells[x]) &#123;</span><br><span class=\"line\">            y = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> y == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            y = <span class=\"built_in\">len</span>(cells[x]) - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cells[x][y].alive &#123;</span><br><span class=\"line\">            liveCount++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y)   <span class=\"comment\">// To the left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y)   <span class=\"comment\">// To the right</span></span><br><span class=\"line\">    add(c.x, c.y+<span class=\"number\">1</span>)   <span class=\"comment\">// up</span></span><br><span class=\"line\">    add(c.x, c.y<span class=\"number\">-1</span>)   <span class=\"comment\">// down</span></span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y+<span class=\"number\">1</span>) <span class=\"comment\">// top-left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y+<span class=\"number\">1</span>) <span class=\"comment\">// top-right</span></span><br><span class=\"line\">    add(c.x<span class=\"number\">-1</span>, c.y<span class=\"number\">-1</span>) <span class=\"comment\">// bottom-left</span></span><br><span class=\"line\">    add(c.x+<span class=\"number\">1</span>, c.y<span class=\"number\">-1</span>) <span class=\"comment\">// bottom-right</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> liveCount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// initGlfw 初始化 glfw，返回一个可用的 Window</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initGlfw</span><span class=\"params\">()</span></span> *glfw.Window &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := glfw.Init(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glfw.WindowHint(glfw.Resizable, glfw.False)</span><br><span class=\"line\">    glfw.WindowHint(glfw.ContextVersionMajor, <span class=\"number\">4</span>)</span><br><span class=\"line\">    glfw.WindowHint(glfw.ContextVersionMinor, <span class=\"number\">1</span>)</span><br><span class=\"line\">    glfw.WindowHint(glfw.OpenGLProfile, glfw.OpenGLCoreProfile)</span><br><span class=\"line\">    glfw.WindowHint(glfw.OpenGLForwardCompatible, glfw.True)</span><br><span class=\"line\">    window, err := glfw.CreateWindow(width, height, <span class=\"string\">&quot;Conway&#x27;s Game of Life&quot;</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.MakeContextCurrent()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// initOpenGL 初始化 OpenGL 并返回一个已经编译好的着色器程序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">initOpenGL</span><span class=\"params\">()</span></span> <span class=\"type\">uint32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := gl.Init(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    version := gl.GoStr(gl.GetString(gl.VERSION))</span><br><span class=\"line\">    log.Println(<span class=\"string\">&quot;OpenGL version&quot;</span>, version)</span><br><span class=\"line\">    vertexShader, err := compileShader(vertexShaderSource, gl.VERTEX_SHADER)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fragmentShader, err := compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    prog := gl.CreateProgram()</span><br><span class=\"line\">    gl.AttachShader(prog, vertexShader)</span><br><span class=\"line\">    gl.AttachShader(prog, fragmentShader)</span><br><span class=\"line\">    gl.LinkProgram(prog)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// makeVao 初始化并从提供的点里面返回一个顶点数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeVao</span><span class=\"params\">(points []<span class=\"type\">float32</span>)</span></span> <span class=\"type\">uint32</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vbo <span class=\"type\">uint32</span></span><br><span class=\"line\">    gl.GenBuffers(<span class=\"number\">1</span>, &amp;vbo)</span><br><span class=\"line\">    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)</span><br><span class=\"line\">    gl.BufferData(gl.ARRAY_BUFFER, <span class=\"number\">4</span>*<span class=\"built_in\">len</span>(points), gl.Ptr(points), gl.STATIC_DRAW)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> vao <span class=\"type\">uint32</span></span><br><span class=\"line\">    gl.GenVertexArrays(<span class=\"number\">1</span>, &amp;vao)</span><br><span class=\"line\">    gl.BindVertexArray(vao)</span><br><span class=\"line\">    gl.EnableVertexAttribArray(<span class=\"number\">0</span>)</span><br><span class=\"line\">    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)</span><br><span class=\"line\">    gl.VertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, gl.FLOAT, <span class=\"literal\">false</span>, <span class=\"number\">0</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vao</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compileShader</span><span class=\"params\">(source <span class=\"type\">string</span>, shaderType <span class=\"type\">uint32</span>)</span></span> (<span class=\"type\">uint32</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    shader := gl.CreateShader(shaderType)</span><br><span class=\"line\">    csources, free := gl.Strs(source)</span><br><span class=\"line\">    gl.ShaderSource(shader, <span class=\"number\">1</span>, csources, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    free()</span><br><span class=\"line\">    gl.CompileShader(shader)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> status <span class=\"type\">int32</span></span><br><span class=\"line\">    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &amp;status)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> status == gl.FALSE &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> logLength <span class=\"type\">int32</span></span><br><span class=\"line\">        gl.GetShaderiv(shader, gl.INFO_LOG_LENGTH, &amp;logLength)</span><br><span class=\"line\">        log := strings.Repeat(<span class=\"string\">&quot;\\x00&quot;</span>, <span class=\"type\">int</span>(logLength+<span class=\"number\">1</span>))</span><br><span class=\"line\">        gl.GetShaderInfoLog(shader, logLength, <span class=\"literal\">nil</span>, gl.Str(log))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, fmt.Errorf(<span class=\"string\">&quot;failed to compile %v: %v&quot;</span>, source, log)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"IPFS Windows","abbrlink":"3e9a9d51","date":"2022-10-09T14:17:50.000Z","_content":"\n\n\n# IPFS Windows\n\n>   go-IPFS 项目在v0.14及其以后版本改名为Kubo\n\n[github](https://github.com/ipfs/kubo.git)\n\n\n\n## Install\n\n[release](https://github.com/ipfs/kubo/releases)\n\n+   下载安装包解压得kubo目录\n\n![](IPFS-Windows/zip.png)\n\n+   将kubo目录添加至环境变量，以便使用 `ipfs` 命令\n\n\n\n## Config\n\n```shell\n$ ipfs init\n```\n\n此命令将会在你的用户文件夹根目录下(**C:/Users/abc/**)生成节点目录名.ipfs，接下来打开**config**，里面的是ipfs的一些基础配置数据，可以根据自己的需求修改里面的配置\n\n\n\n## Run\n\n```shell\n$ ipfs daemon\n```\n\n访问 http://localhost:5001/webui 即可界面化操作\n\n或者采用 go 语言API操作\n\n```go\npackage core\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\tshell \"github.com/ipfs/go-ipfs-api\"\n)\n\ntype FileList shell.LsLink\n\ntype API struct {\n\tsh *shell.Shell\n}\n\nfunc NewAPI() *API {\n\tsh := shell.NewShell(\"localhost:5001\")\n\treturn &API{\n\t\tsh: sh,\n\t}\n}\n\nfunc (a *API) Upload(data []byte) (string, error) {\n\thash, err := a.sh.Add(bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hash, nil\n}\n\nfunc (a *API) Download(hash string) ([]byte, error) {\n\trc, err := a.sh.Cat(hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rc.Close()\n\tb, err2 := io.ReadAll(rc)\n\tif err2 != nil {\n\t\treturn nil, err2\n\t}\n\treturn b, nil\n\n}\n\nfunc (a *API) List(hash string) ([]*FileList, error) {\n\tll, err := a.sh.List(hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres := make([]*FileList, 0, 10)\n\tfor _, v := range ll {\n\t\tl := FileList(*v)\n\t\tres = append(res, &l)\n\t}\n\treturn res, nil\n}\n\n```\n\n","source":"_posts/IPFS-Windows.md","raw":"---\ntitle: IPFS Windows\ntags:\n  - Decentralization\n  - 区块链\n  - P2P\ncategories:\n  - 大创\n  - 区块链\nabbrlink: 3e9a9d51\ndate: 2022-10-09 22:17:50\n---\n\n\n\n# IPFS Windows\n\n>   go-IPFS 项目在v0.14及其以后版本改名为Kubo\n\n[github](https://github.com/ipfs/kubo.git)\n\n\n\n## Install\n\n[release](https://github.com/ipfs/kubo/releases)\n\n+   下载安装包解压得kubo目录\n\n![](IPFS-Windows/zip.png)\n\n+   将kubo目录添加至环境变量，以便使用 `ipfs` 命令\n\n\n\n## Config\n\n```shell\n$ ipfs init\n```\n\n此命令将会在你的用户文件夹根目录下(**C:/Users/abc/**)生成节点目录名.ipfs，接下来打开**config**，里面的是ipfs的一些基础配置数据，可以根据自己的需求修改里面的配置\n\n\n\n## Run\n\n```shell\n$ ipfs daemon\n```\n\n访问 http://localhost:5001/webui 即可界面化操作\n\n或者采用 go 语言API操作\n\n```go\npackage core\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\tshell \"github.com/ipfs/go-ipfs-api\"\n)\n\ntype FileList shell.LsLink\n\ntype API struct {\n\tsh *shell.Shell\n}\n\nfunc NewAPI() *API {\n\tsh := shell.NewShell(\"localhost:5001\")\n\treturn &API{\n\t\tsh: sh,\n\t}\n}\n\nfunc (a *API) Upload(data []byte) (string, error) {\n\thash, err := a.sh.Add(bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hash, nil\n}\n\nfunc (a *API) Download(hash string) ([]byte, error) {\n\trc, err := a.sh.Cat(hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rc.Close()\n\tb, err2 := io.ReadAll(rc)\n\tif err2 != nil {\n\t\treturn nil, err2\n\t}\n\treturn b, nil\n\n}\n\nfunc (a *API) List(hash string) ([]*FileList, error) {\n\tll, err := a.sh.List(hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres := make([]*FileList, 0, 10)\n\tfor _, v := range ll {\n\t\tl := FileList(*v)\n\t\tres = append(res, &l)\n\t}\n\treturn res, nil\n}\n\n```\n\n","slug":"IPFS-Windows","published":1,"updated":"2022-10-09T15:20:06.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjm000eecwdc60e9gg1","content":"<h1 id=\"IPFS-Windows\"><a href=\"#IPFS-Windows\" class=\"headerlink\" title=\"IPFS Windows\"></a>IPFS Windows</h1><blockquote>\n<p>  go-IPFS 项目在v0.14及其以后版本改名为Kubo</p>\n</blockquote>\n<p><a href=\"https://github.com/ipfs/kubo.git\">github</a></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p><a href=\"https://github.com/ipfs/kubo/releases\">release</a></p>\n<ul>\n<li>  下载安装包解压得kubo目录</li>\n</ul>\n<p><img src=\"/post/3e9a9d51/zip.png\"></p>\n<ul>\n<li>  将kubo目录添加至环境变量，以便使用 <code>ipfs</code> 命令</li>\n</ul>\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ipfs init</span></span><br></pre></td></tr></table></figure>\n\n<p>此命令将会在你的用户文件夹根目录下(<strong>C:/Users/abc/</strong>)生成节点目录名.ipfs，接下来打开<strong>config</strong>，里面的是ipfs的一些基础配置数据，可以根据自己的需求修改里面的配置</p>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ipfs daemon</span></span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:5001/webui\">http://localhost:5001/webui</a> 即可界面化操作</p>\n<p>或者采用 go 语言API操作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tshell <span class=\"string\">&quot;github.com/ipfs/go-ipfs-api&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FileList shell.LsLink</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> API <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsh *shell.Shell</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAPI</span><span class=\"params\">()</span></span> *API &#123;</span><br><span class=\"line\">\tsh := shell.NewShell(<span class=\"string\">&quot;localhost:5001&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;API&#123;</span><br><span class=\"line\">\t\tsh: sh,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> Upload(data []<span class=\"type\">byte</span>) (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\thash, err := a.sh.Add(bytes.NewBuffer(data))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hash, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> Download(hash <span class=\"type\">string</span>) ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\trc, err := a.sh.Cat(hash)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rc.Close()</span><br><span class=\"line\">\tb, err2 := io.ReadAll(rc)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err2 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err2</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b, <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> List(hash <span class=\"type\">string</span>) ([]*FileList, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tll, err := a.sh.List(hash)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]*FileList, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> ll &#123;</span><br><span class=\"line\">\t\tl := FileList(*v)</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, &amp;l)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/img/c2.jpg","excerpt":"","more":"<h1 id=\"IPFS-Windows\"><a href=\"#IPFS-Windows\" class=\"headerlink\" title=\"IPFS Windows\"></a>IPFS Windows</h1><blockquote>\n<p>  go-IPFS 项目在v0.14及其以后版本改名为Kubo</p>\n</blockquote>\n<p><a href=\"https://github.com/ipfs/kubo.git\">github</a></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p><a href=\"https://github.com/ipfs/kubo/releases\">release</a></p>\n<ul>\n<li>  下载安装包解压得kubo目录</li>\n</ul>\n<p><img src=\"/post/3e9a9d51/zip.png\"></p>\n<ul>\n<li>  将kubo目录添加至环境变量，以便使用 <code>ipfs</code> 命令</li>\n</ul>\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ipfs init</span></span><br></pre></td></tr></table></figure>\n\n<p>此命令将会在你的用户文件夹根目录下(<strong>C:/Users/abc/</strong>)生成节点目录名.ipfs，接下来打开<strong>config</strong>，里面的是ipfs的一些基础配置数据，可以根据自己的需求修改里面的配置</p>\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ipfs daemon</span></span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:5001/webui\">http://localhost:5001/webui</a> 即可界面化操作</p>\n<p>或者采用 go 语言API操作</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> core</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tshell <span class=\"string\">&quot;github.com/ipfs/go-ipfs-api&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> FileList shell.LsLink</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> API <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsh *shell.Shell</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewAPI</span><span class=\"params\">()</span></span> *API &#123;</span><br><span class=\"line\">\tsh := shell.NewShell(<span class=\"string\">&quot;localhost:5001&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;API&#123;</span><br><span class=\"line\">\t\tsh: sh,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> Upload(data []<span class=\"type\">byte</span>) (<span class=\"type\">string</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\thash, err := a.sh.Add(bytes.NewBuffer(data))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hash, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> Download(hash <span class=\"type\">string</span>) ([]<span class=\"type\">byte</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\trc, err := a.sh.Cat(hash)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rc.Close()</span><br><span class=\"line\">\tb, err2 := io.ReadAll(rc)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err2 != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err2</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b, <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *API)</span></span> List(hash <span class=\"type\">string</span>) ([]*FileList, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tll, err := a.sh.List(hash)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]*FileList, <span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> ll &#123;</span><br><span class=\"line\">\t\tl := FileList(*v)</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, &amp;l)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"K8s(1)","abbrlink":"8e372fbf","_content":"\n# 主机网络模式探究\n\n> Pod为Host网络模式，即直接使用宿主机的网络，不进行网络虚拟化隔离。这样一来，Pod中的所有容器就直接暴露在宿主机的网络环境中，这时候，Pod的PodIP就是其所在Node的IP。\n> 从原理上来说，当设定Pod的网络为Host时，是设定了Pod中pod-infrastructure（或pause）容器的网络为Host，Pod内部其他容器的网络指向该容器。\n\n## Yaml\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: nginx\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: nginx\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: mynginx\n        imagePullPolicy: IfNotPresent # 宿主机不存在则拉取远程\n        image: nginx\n      hostNetwork: true\n```\n\n## k8s pod镜像拉取策略\n+ Always：每次创建pod时重新远程拉取镜像\n+ IfNotPresent：宿主机不存在则拉取远程\n+ Never：只使用宿主机上存在的，永不拉取\n\n## Command\n```bash\n# 根据yaml配置文件创建资源\nkubectl create -f xxx.yml\n\n# 资源本不存在: 创建新资源。\n# 资源已存在: 使配置在已存在的资源上生效\nkubectl apply -f xxx.yml\n\n# 获取某类资源列表信息\nkubectl get pod/deployment/...\n# 删除某类资源\nkubectl delete pod/deployment/...\n# 详细信息\nkubectl describe pod\n# 打印日志\nkubectl logs\n\n```\n\n## 常见错误\n\n![](./K8s(1)/err0.png)\n+ ImagePullBackOff：远程镜像拉取失败\n+ ErrImageNeverPull：当策略为Never且部署节点上不存在该镜像；从节点上要有这个镜像。**准确的说是调度到哪个节点，那个节点上就要有这个镜像**，否则会报错；*当使用本地镜像时需要注意该问题！*\n\n![](./K8s(1)/err1.png)\n![](./K8s(1)/err2.png)\n已pod形式启动了一个镜像，执行kubectl get pod 查看状态，发现pod一直重启。查看具体的报错信息，发现报错内容为：Back-off restarting failed container\n+ 原因：镜像启动容器后，**容器内部没有常驻进程，导致容器启动成功后即退出**，从而进行了持续的重启。\n+ 解决：只需要给容器加上一个常驻的进程就可以要使Pod持续运行，就必须指定一个永远不会完成的任务。\n因此在yaml文件中指定一个启动命令，完整内容如下:\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: nginx\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: nginx\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: mynginx\n        imagePullPolicy: IfNotPresent # 宿主机不存在则拉取远程\n        image: nginx\n        command: [\"/bin/bash\", \"-ce\", \"tail -f /dev/null\"]\n      hostNetwork: true\n```\n\n\n# K8s防护调研\n\n## KubeArmor\n\n>KubeArmor是一个支持[容器](https://cloud.tencent.com/product/tke?from=20065&from_column=20065)的运行时安全实施系统，它可以从系统级别限制容器的行为（如进程执行、文件访问、网络操作和资源利用率）。\n\n[官网](https://kubearmor.io/)\n[git](https://github.com/kubearmor/KubeArmor) \n\n该工具可通过规则配置，对容器指定资源与行为进行监控和拦截，例如：\n```yaml\napiVersion: security.kubearmor.com/v1\nkind: KubeArmorPolicy\nmetadata:\n  name: ksp-group-1-proc-path-block\n  namespace: multiubuntu\nspec:\n  selector:\n    matchLabels:\n      group: group-1\n  process:\n    matchPaths:\n    - path: /bin/sleep\n  action:\n    Block\n```\n说明：此策略的目的是阻止在带有“group-1”标签的容器中执行“/bin/sleep”。 为此，我们在 selector -> matchLabels 中定义 'group-1' 标签，在 process -> matchPaths 中定义特定路径（'/bin/sleep'）。 此外，我们将“阻止”作为此策略的操作。\n通过不同的规则配置可达到不同的拦截效果，下面列举出部分：\n+ Block a specific executable\n+ Block all executables in a specific directory\n+ Block all executables in a specific directory and its subdirectories\n+ Allow specific executables to access certain files only\n+ .....\n\n## NeuVector\n\n>NeuVector提供实时深入的容器网络可视化、东西向容器网络监控、主动隔离和保护、容器主机安全以及容器内部安全。\n>NeuVector并非某个组件或者安全工具，而是一套完整的容器安全平台。\n\n[Install](https://www.cnblogs.com/panlifeng/p/16326578.html)\n\n### Install\n创建 namespace\n\n```cpp\nkubectl create namespace neuvector\n```\n\n部署 CRD (Kubernetes 1.19+ 版本)\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/crd-k8s-1.19.yaml\n```\n\n部署 CRD (Kubernetes 1.18 或更低版本)\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/crd-k8s-1.16.yaml\n```\n\n配置 RBAC\n\n```sql\nkubectl create clusterrole neuvector-binding-app --verb=get,list,watch,update --resource=nodes,pods,services,namespaces\nkubectl create clusterrole neuvector-binding-rbac --verb=get,list,watch --resource=rolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,clusterroles.rbac.authorization.k8s.io\nkubectl create clusterrolebinding neuvector-binding-app --clusterrole=neuvector-binding-app --serviceaccount=neuvector:default\nkubectl create clusterrolebinding neuvector-binding-rbac --clusterrole=neuvector-binding-rbac --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-admission --verb=get,list,watch,create,update,delete --resource=validatingwebhookconfigurations,mutatingwebhookconfigurations\nkubectl create clusterrolebinding neuvector-binding-admission --clusterrole=neuvector-binding-admission --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-customresourcedefinition --verb=watch,create,get --resource=customresourcedefinitions\nkubectl create clusterrolebinding  neuvector-binding-customresourcedefinition --clusterrole=neuvector-binding-customresourcedefinition --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-nvsecurityrules --verb=list,delete --resource=nvsecurityrules,nvclustersecurityrules\nkubectl create clusterrolebinding neuvector-binding-nvsecurityrules --clusterrole=neuvector-binding-nvsecurityrules --serviceaccount=neuvector:default\nkubectl create clusterrolebinding neuvector-binding-view --clusterrole=view --serviceaccount=neuvector:default\nkubectl create rolebinding neuvector-admin --clusterrole=admin --serviceaccount=neuvector:default -n neuvector\n```\n\n检查是否有以下 RBAC 对象\n\n```bash\nkubectl get clusterrolebinding  | grep neuvector\n\nneuvector-binding-admission                            ClusterRole/neuvector-binding-admission                            44h\nneuvector-binding-app                                  ClusterRole/neuvector-binding-app                                  44h\nneuvector-binding-customresourcedefinition             ClusterRole/neuvector-binding-customresourcedefinition             44h\nneuvector-binding-nvadmissioncontrolsecurityrules      ClusterRole/neuvector-binding-nvadmissioncontrolsecurityrules      44h\nneuvector-binding-nvsecurityrules                      ClusterRole/neuvector-binding-nvsecurityrules                      44h\nneuvector-binding-nvwafsecurityrules                   ClusterRole/neuvector-binding-nvwafsecurityrules                   44h\nneuvector-binding-rbac                                 ClusterRole/neuvector-binding-rbac                                 44h\nneuvector-binding-view                                 ClusterRole/view                                                   44h\n```\n\n```bash\nkubectl get rolebinding -n neuvector | grep neuvector\n\nneuvector-admin         ClusterRole/admin            44h\nneuvector-binding-psp   Role/neuvector-binding-psp   44h\n```\n\n部署 NeuVector\n\n底层 Runtime 为 Docker\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml\n```\n\n底层 Runtime 为 Containerd（对于 k3s 和 rke2 可以使用此 yaml 文件）\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-containerd-k8s.yaml\n```\n\n1.21 以下的 Kubernetes 版本会提示以下错误，将 yaml 文件下载将 batch/v1 修改为 batch/v1beta1\n\n```less\nerror: unable to recognize \"https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml\": no matches for kind \"CronJob\" in version \"batch/v1\"\n```\n\n1.20.x cronjob 还处于 beta 阶段，1.21 版本开始 cronjob 才正式 GA 。\n\n默认部署 web-ui 使用的是 loadblance 类型的 Service，为了方便访问修改为 NodePort，也可以通过 Ingress 对外提供服务\n\n```makefile\nkubectl patch  svc neuvector-service-webui  -n neuvector --type='json' -p '[{\"op\":\"replace\",\"path\":\"/spec/type\",\"value\":\"NodePort\"},{\"op\":\"add\",\"path\":\"/spec/ports/0/nodePort\",\"value\":30888}]'\n```\n\n### 遇到的问题与解决\nNeuVector 安装部署需要在k8s集群中部署包括controller，enforcer，manager，scanner在内的若干个pod，通过官方的yaml文件进行部署时，出现了上述的镜像拉取失败而导致的pod启动失败的问题。\n\n![](./K8s(1)/err5.png)\n![](./K8s(1)/err6.png)\n\n如上图所示，多数pod启动失败，原因皆为镜像拉取失败导致的，查看官方提供的yaml文件，得知所有镜像的默认拉取策略为`Always`，尝试将其改为`IfNotPresent`，并提前手动拉取镜像(`docker pull`)到node节点本地来提高pod的部署与启动速度。\n\n出现网络问题，这个应该就是之前镜像拉取失败的主要原因：\n![](./K8s(1)/err3.png)\n尝试配置DNS解析，并重启docker服务后解决：\n![](./K8s(1)/err4.png)\n所有的镜像均手动拉取下来后，重启之前启动失败的pod\n![](./K8s(1)/succ0.png)\n访问 `https://node-ip:30888`，使用 admin/admin登录\n![](./K8s(1)/succ1.png)\n\n### Trial\n+ 查看容器存在的中高危漏洞情况\n![](./K8s(1)/use0.png)\n+ 查看容器内存使用与网络通信情况\n![](./K8s(1)/use1.png)\n+ 配置容器应用分组的相关进程规则，文件访问规则等\n![](./K8s(1)/use2.png)\n+ 配置集群与容器的网络规则\n![](./K8s(1)/use3.png)\n![](./K8s(1)/use5.png)\n+ 查看集群中的安全事件\n![](./K8s(1)/use4.png)\n+ ...\n","source":"_posts/K8s(1).md","raw":"---\ntitle: K8s(1)\ntags:\n  - docker\n  - 容器\ncategories:\n  - 云计算\n  - K8s\nabbrlink: 8e372fbf\n---\n\n# 主机网络模式探究\n\n> Pod为Host网络模式，即直接使用宿主机的网络，不进行网络虚拟化隔离。这样一来，Pod中的所有容器就直接暴露在宿主机的网络环境中，这时候，Pod的PodIP就是其所在Node的IP。\n> 从原理上来说，当设定Pod的网络为Host时，是设定了Pod中pod-infrastructure（或pause）容器的网络为Host，Pod内部其他容器的网络指向该容器。\n\n## Yaml\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: nginx\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: nginx\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: mynginx\n        imagePullPolicy: IfNotPresent # 宿主机不存在则拉取远程\n        image: nginx\n      hostNetwork: true\n```\n\n## k8s pod镜像拉取策略\n+ Always：每次创建pod时重新远程拉取镜像\n+ IfNotPresent：宿主机不存在则拉取远程\n+ Never：只使用宿主机上存在的，永不拉取\n\n## Command\n```bash\n# 根据yaml配置文件创建资源\nkubectl create -f xxx.yml\n\n# 资源本不存在: 创建新资源。\n# 资源已存在: 使配置在已存在的资源上生效\nkubectl apply -f xxx.yml\n\n# 获取某类资源列表信息\nkubectl get pod/deployment/...\n# 删除某类资源\nkubectl delete pod/deployment/...\n# 详细信息\nkubectl describe pod\n# 打印日志\nkubectl logs\n\n```\n\n## 常见错误\n\n![](./K8s(1)/err0.png)\n+ ImagePullBackOff：远程镜像拉取失败\n+ ErrImageNeverPull：当策略为Never且部署节点上不存在该镜像；从节点上要有这个镜像。**准确的说是调度到哪个节点，那个节点上就要有这个镜像**，否则会报错；*当使用本地镜像时需要注意该问题！*\n\n![](./K8s(1)/err1.png)\n![](./K8s(1)/err2.png)\n已pod形式启动了一个镜像，执行kubectl get pod 查看状态，发现pod一直重启。查看具体的报错信息，发现报错内容为：Back-off restarting failed container\n+ 原因：镜像启动容器后，**容器内部没有常驻进程，导致容器启动成功后即退出**，从而进行了持续的重启。\n+ 解决：只需要给容器加上一个常驻的进程就可以要使Pod持续运行，就必须指定一个永远不会完成的任务。\n因此在yaml文件中指定一个启动命令，完整内容如下:\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: nginx\nspec:\n  replicas: 1\n  template:\n    metadata:\n      name: nginx\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: mynginx\n        imagePullPolicy: IfNotPresent # 宿主机不存在则拉取远程\n        image: nginx\n        command: [\"/bin/bash\", \"-ce\", \"tail -f /dev/null\"]\n      hostNetwork: true\n```\n\n\n# K8s防护调研\n\n## KubeArmor\n\n>KubeArmor是一个支持[容器](https://cloud.tencent.com/product/tke?from=20065&from_column=20065)的运行时安全实施系统，它可以从系统级别限制容器的行为（如进程执行、文件访问、网络操作和资源利用率）。\n\n[官网](https://kubearmor.io/)\n[git](https://github.com/kubearmor/KubeArmor) \n\n该工具可通过规则配置，对容器指定资源与行为进行监控和拦截，例如：\n```yaml\napiVersion: security.kubearmor.com/v1\nkind: KubeArmorPolicy\nmetadata:\n  name: ksp-group-1-proc-path-block\n  namespace: multiubuntu\nspec:\n  selector:\n    matchLabels:\n      group: group-1\n  process:\n    matchPaths:\n    - path: /bin/sleep\n  action:\n    Block\n```\n说明：此策略的目的是阻止在带有“group-1”标签的容器中执行“/bin/sleep”。 为此，我们在 selector -> matchLabels 中定义 'group-1' 标签，在 process -> matchPaths 中定义特定路径（'/bin/sleep'）。 此外，我们将“阻止”作为此策略的操作。\n通过不同的规则配置可达到不同的拦截效果，下面列举出部分：\n+ Block a specific executable\n+ Block all executables in a specific directory\n+ Block all executables in a specific directory and its subdirectories\n+ Allow specific executables to access certain files only\n+ .....\n\n## NeuVector\n\n>NeuVector提供实时深入的容器网络可视化、东西向容器网络监控、主动隔离和保护、容器主机安全以及容器内部安全。\n>NeuVector并非某个组件或者安全工具，而是一套完整的容器安全平台。\n\n[Install](https://www.cnblogs.com/panlifeng/p/16326578.html)\n\n### Install\n创建 namespace\n\n```cpp\nkubectl create namespace neuvector\n```\n\n部署 CRD (Kubernetes 1.19+ 版本)\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/crd-k8s-1.19.yaml\n```\n\n部署 CRD (Kubernetes 1.18 或更低版本)\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/crd-k8s-1.16.yaml\n```\n\n配置 RBAC\n\n```sql\nkubectl create clusterrole neuvector-binding-app --verb=get,list,watch,update --resource=nodes,pods,services,namespaces\nkubectl create clusterrole neuvector-binding-rbac --verb=get,list,watch --resource=rolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,clusterroles.rbac.authorization.k8s.io\nkubectl create clusterrolebinding neuvector-binding-app --clusterrole=neuvector-binding-app --serviceaccount=neuvector:default\nkubectl create clusterrolebinding neuvector-binding-rbac --clusterrole=neuvector-binding-rbac --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-admission --verb=get,list,watch,create,update,delete --resource=validatingwebhookconfigurations,mutatingwebhookconfigurations\nkubectl create clusterrolebinding neuvector-binding-admission --clusterrole=neuvector-binding-admission --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-customresourcedefinition --verb=watch,create,get --resource=customresourcedefinitions\nkubectl create clusterrolebinding  neuvector-binding-customresourcedefinition --clusterrole=neuvector-binding-customresourcedefinition --serviceaccount=neuvector:default\nkubectl create clusterrole neuvector-binding-nvsecurityrules --verb=list,delete --resource=nvsecurityrules,nvclustersecurityrules\nkubectl create clusterrolebinding neuvector-binding-nvsecurityrules --clusterrole=neuvector-binding-nvsecurityrules --serviceaccount=neuvector:default\nkubectl create clusterrolebinding neuvector-binding-view --clusterrole=view --serviceaccount=neuvector:default\nkubectl create rolebinding neuvector-admin --clusterrole=admin --serviceaccount=neuvector:default -n neuvector\n```\n\n检查是否有以下 RBAC 对象\n\n```bash\nkubectl get clusterrolebinding  | grep neuvector\n\nneuvector-binding-admission                            ClusterRole/neuvector-binding-admission                            44h\nneuvector-binding-app                                  ClusterRole/neuvector-binding-app                                  44h\nneuvector-binding-customresourcedefinition             ClusterRole/neuvector-binding-customresourcedefinition             44h\nneuvector-binding-nvadmissioncontrolsecurityrules      ClusterRole/neuvector-binding-nvadmissioncontrolsecurityrules      44h\nneuvector-binding-nvsecurityrules                      ClusterRole/neuvector-binding-nvsecurityrules                      44h\nneuvector-binding-nvwafsecurityrules                   ClusterRole/neuvector-binding-nvwafsecurityrules                   44h\nneuvector-binding-rbac                                 ClusterRole/neuvector-binding-rbac                                 44h\nneuvector-binding-view                                 ClusterRole/view                                                   44h\n```\n\n```bash\nkubectl get rolebinding -n neuvector | grep neuvector\n\nneuvector-admin         ClusterRole/admin            44h\nneuvector-binding-psp   Role/neuvector-binding-psp   44h\n```\n\n部署 NeuVector\n\n底层 Runtime 为 Docker\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml\n```\n\n底层 Runtime 为 Containerd（对于 k3s 和 rke2 可以使用此 yaml 文件）\n\n```ruby\nkubectl apply -f https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-containerd-k8s.yaml\n```\n\n1.21 以下的 Kubernetes 版本会提示以下错误，将 yaml 文件下载将 batch/v1 修改为 batch/v1beta1\n\n```less\nerror: unable to recognize \"https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml\": no matches for kind \"CronJob\" in version \"batch/v1\"\n```\n\n1.20.x cronjob 还处于 beta 阶段，1.21 版本开始 cronjob 才正式 GA 。\n\n默认部署 web-ui 使用的是 loadblance 类型的 Service，为了方便访问修改为 NodePort，也可以通过 Ingress 对外提供服务\n\n```makefile\nkubectl patch  svc neuvector-service-webui  -n neuvector --type='json' -p '[{\"op\":\"replace\",\"path\":\"/spec/type\",\"value\":\"NodePort\"},{\"op\":\"add\",\"path\":\"/spec/ports/0/nodePort\",\"value\":30888}]'\n```\n\n### 遇到的问题与解决\nNeuVector 安装部署需要在k8s集群中部署包括controller，enforcer，manager，scanner在内的若干个pod，通过官方的yaml文件进行部署时，出现了上述的镜像拉取失败而导致的pod启动失败的问题。\n\n![](./K8s(1)/err5.png)\n![](./K8s(1)/err6.png)\n\n如上图所示，多数pod启动失败，原因皆为镜像拉取失败导致的，查看官方提供的yaml文件，得知所有镜像的默认拉取策略为`Always`，尝试将其改为`IfNotPresent`，并提前手动拉取镜像(`docker pull`)到node节点本地来提高pod的部署与启动速度。\n\n出现网络问题，这个应该就是之前镜像拉取失败的主要原因：\n![](./K8s(1)/err3.png)\n尝试配置DNS解析，并重启docker服务后解决：\n![](./K8s(1)/err4.png)\n所有的镜像均手动拉取下来后，重启之前启动失败的pod\n![](./K8s(1)/succ0.png)\n访问 `https://node-ip:30888`，使用 admin/admin登录\n![](./K8s(1)/succ1.png)\n\n### Trial\n+ 查看容器存在的中高危漏洞情况\n![](./K8s(1)/use0.png)\n+ 查看容器内存使用与网络通信情况\n![](./K8s(1)/use1.png)\n+ 配置容器应用分组的相关进程规则，文件访问规则等\n![](./K8s(1)/use2.png)\n+ 配置集群与容器的网络规则\n![](./K8s(1)/use3.png)\n![](./K8s(1)/use5.png)\n+ 查看集群中的安全事件\n![](./K8s(1)/use4.png)\n+ ...\n","slug":"K8s(1)","published":1,"date":"2023-03-27T14:32:35.961Z","updated":"2023-04-04T14:23:48.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjm000fecwdf3efblgb","content":"<h1 id=\"主机网络模式探究\"><a href=\"#主机网络模式探究\" class=\"headerlink\" title=\"主机网络模式探究\"></a>主机网络模式探究</h1><blockquote>\n<p>Pod为Host网络模式，即直接使用宿主机的网络，不进行网络虚拟化隔离。这样一来，Pod中的所有容器就直接暴露在宿主机的网络环境中，这时候，Pod的PodIP就是其所在Node的IP。<br>从原理上来说，当设定Pod的网络为Host时，是设定了Pod中pod-infrastructure（或pause）容器的网络为Host，Pod内部其他容器的网络指向该容器。</p>\n</blockquote>\n<h2 id=\"Yaml\"><a href=\"#Yaml\" class=\"headerlink\" title=\"Yaml\"></a>Yaml</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mynginx</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># 宿主机不存在则拉取远程</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">hostNetwork:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"k8s-pod镜像拉取策略\"><a href=\"#k8s-pod镜像拉取策略\" class=\"headerlink\" title=\"k8s pod镜像拉取策略\"></a>k8s pod镜像拉取策略</h2><ul>\n<li>Always：每次创建pod时重新远程拉取镜像</li>\n<li>IfNotPresent：宿主机不存在则拉取远程</li>\n<li>Never：只使用宿主机上存在的，永不拉取</li>\n</ul>\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根据yaml配置文件创建资源</span></span><br><span class=\"line\">kubectl create -f xxx.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 资源本不存在: 创建新资源。</span></span><br><span class=\"line\"><span class=\"comment\"># 资源已存在: 使配置在已存在的资源上生效</span></span><br><span class=\"line\">kubectl apply -f xxx.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取某类资源列表信息</span></span><br><span class=\"line\">kubectl get pod/deployment/...</span><br><span class=\"line\"><span class=\"comment\"># 删除某类资源</span></span><br><span class=\"line\">kubectl delete pod/deployment/...</span><br><span class=\"line\"><span class=\"comment\"># 详细信息</span></span><br><span class=\"line\">kubectl describe pod</span><br><span class=\"line\"><span class=\"comment\"># 打印日志</span></span><br><span class=\"line\">kubectl logs</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p><img src=\"/post/8e372fbf/err0.png\"></p>\n<ul>\n<li>ImagePullBackOff：远程镜像拉取失败</li>\n<li>ErrImageNeverPull：当策略为Never且部署节点上不存在该镜像；从节点上要有这个镜像。<strong>准确的说是调度到哪个节点，那个节点上就要有这个镜像</strong>，否则会报错；<em>当使用本地镜像时需要注意该问题！</em></li>\n</ul>\n<p><img src=\"/post/8e372fbf/err1.png\"><br><img src=\"/post/8e372fbf/err2.png\"><br>已pod形式启动了一个镜像，执行kubectl get pod 查看状态，发现pod一直重启。查看具体的报错信息，发现报错内容为：Back-off restarting failed container</p>\n<ul>\n<li>原因：镜像启动容器后，<strong>容器内部没有常驻进程，导致容器启动成功后即退出</strong>，从而进行了持续的重启。</li>\n<li>解决：只需要给容器加上一个常驻的进程就可以要使Pod持续运行，就必须指定一个永远不会完成的任务。<br>因此在yaml文件中指定一个启动命令，完整内容如下:<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mynginx</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># 宿主机不存在则拉取远程</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-ce&quot;</span>, <span class=\"string\">&quot;tail -f /dev/null&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">hostNetwork:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"K8s防护调研\"><a href=\"#K8s防护调研\" class=\"headerlink\" title=\"K8s防护调研\"></a>K8s防护调研</h1><h2 id=\"KubeArmor\"><a href=\"#KubeArmor\" class=\"headerlink\" title=\"KubeArmor\"></a>KubeArmor</h2><blockquote>\n<p>KubeArmor是一个支持<a href=\"https://cloud.tencent.com/product/tke?from=20065&from_column=20065\">容器</a>的运行时安全实施系统，它可以从系统级别限制容器的行为（如进程执行、文件访问、网络操作和资源利用率）。</p>\n</blockquote>\n<p><a href=\"https://kubearmor.io/\">官网</a><br><a href=\"https://github.com/kubearmor/KubeArmor\">git</a> </p>\n<p>该工具可通过规则配置，对容器指定资源与行为进行监控和拦截，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">security.kubearmor.com/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">KubeArmorPolicy</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">ksp-group-1-proc-path-block</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">multiubuntu</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">group:</span> <span class=\"string\">group-1</span></span><br><span class=\"line\">  <span class=\"attr\">process:</span></span><br><span class=\"line\">    <span class=\"attr\">matchPaths:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/bin/sleep</span></span><br><span class=\"line\">  <span class=\"attr\">action:</span></span><br><span class=\"line\">    <span class=\"string\">Block</span></span><br></pre></td></tr></table></figure>\n<p>说明：此策略的目的是阻止在带有“group-1”标签的容器中执行“/bin/sleep”。 为此，我们在 selector -&gt; matchLabels 中定义 ‘group-1’ 标签，在 process -&gt; matchPaths 中定义特定路径（’/bin/sleep’）。 此外，我们将“阻止”作为此策略的操作。<br>通过不同的规则配置可达到不同的拦截效果，下面列举出部分：</p>\n<ul>\n<li>Block a specific executable</li>\n<li>Block all executables in a specific directory</li>\n<li>Block all executables in a specific directory and its subdirectories</li>\n<li>Allow specific executables to access certain files only</li>\n<li>…..</li>\n</ul>\n<h2 id=\"NeuVector\"><a href=\"#NeuVector\" class=\"headerlink\" title=\"NeuVector\"></a>NeuVector</h2><blockquote>\n<p>NeuVector提供实时深入的容器网络可视化、东西向容器网络监控、主动隔离和保护、容器主机安全以及容器内部安全。<br>NeuVector并非某个组件或者安全工具，而是一套完整的容器安全平台。</p>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/panlifeng/p/16326578.html\">Install</a></p>\n<h3 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h3><p>创建 namespace</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create <span class=\"keyword\">namespace</span> neuvector</span><br></pre></td></tr></table></figure>\n\n<p>部署 CRD (Kubernetes 1.19+ 版本)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/crd</span>-k8s-<span class=\"number\">1.19</span>.yaml</span><br></pre></td></tr></table></figure>\n\n<p>部署 CRD (Kubernetes 1.18 或更低版本)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/crd</span>-k8s-<span class=\"number\">1.16</span>.yaml</span><br></pre></td></tr></table></figure>\n\n<p>配置 RBAC</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>app <span class=\"comment\">--verb=get,list,watch,update --resource=nodes,pods,services,namespaces</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>rbac <span class=\"comment\">--verb=get,list,watch --resource=rolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,clusterroles.rbac.authorization.k8s.io</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>app <span class=\"comment\">--clusterrole=neuvector-binding-app --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>rbac <span class=\"comment\">--clusterrole=neuvector-binding-rbac --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>admission <span class=\"comment\">--verb=get,list,watch,create,update,delete --resource=validatingwebhookconfigurations,mutatingwebhookconfigurations</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>admission <span class=\"comment\">--clusterrole=neuvector-binding-admission --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>customresourcedefinition <span class=\"comment\">--verb=watch,create,get --resource=customresourcedefinitions</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding  neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>customresourcedefinition <span class=\"comment\">--clusterrole=neuvector-binding-customresourcedefinition --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>nvsecurityrules <span class=\"comment\">--verb=list,delete --resource=nvsecurityrules,nvclustersecurityrules</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>nvsecurityrules <span class=\"comment\">--clusterrole=neuvector-binding-nvsecurityrules --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span><span class=\"keyword\">view</span> <span class=\"comment\">--clusterrole=view --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> rolebinding neuvector<span class=\"operator\">-</span>admin <span class=\"comment\">--clusterrole=admin --serviceaccount=neuvector:default -n neuvector</span></span><br></pre></td></tr></table></figure>\n\n<p>检查是否有以下 RBAC 对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get clusterrolebinding  | grep neuvector</span><br><span class=\"line\"></span><br><span class=\"line\">neuvector-binding-admission                            ClusterRole/neuvector-binding-admission                            44h</span><br><span class=\"line\">neuvector-binding-app                                  ClusterRole/neuvector-binding-app                                  44h</span><br><span class=\"line\">neuvector-binding-customresourcedefinition             ClusterRole/neuvector-binding-customresourcedefinition             44h</span><br><span class=\"line\">neuvector-binding-nvadmissioncontrolsecurityrules      ClusterRole/neuvector-binding-nvadmissioncontrolsecurityrules      44h</span><br><span class=\"line\">neuvector-binding-nvsecurityrules                      ClusterRole/neuvector-binding-nvsecurityrules                      44h</span><br><span class=\"line\">neuvector-binding-nvwafsecurityrules                   ClusterRole/neuvector-binding-nvwafsecurityrules                   44h</span><br><span class=\"line\">neuvector-binding-rbac                                 ClusterRole/neuvector-binding-rbac                                 44h</span><br><span class=\"line\">neuvector-binding-view                                 ClusterRole/view                                                   44h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get rolebinding -n neuvector | grep neuvector</span><br><span class=\"line\"></span><br><span class=\"line\">neuvector-admin         ClusterRole/admin            44h</span><br><span class=\"line\">neuvector-binding-psp   Role/neuvector-binding-psp   44h</span><br></pre></td></tr></table></figure>\n\n<p>部署 NeuVector</p>\n<p>底层 Runtime 为 Docker</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/</span><span class=\"number\">5.0</span>.<span class=\"number\">0</span>/neuvector-docker-k8s.yaml</span><br></pre></td></tr></table></figure>\n\n<p>底层 Runtime 为 Containerd（对于 k3s 和 rke2 可以使用此 yaml 文件）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/</span><span class=\"number\">5.0</span>.<span class=\"number\">0</span>/neuvector-containerd-k8s.yaml</span><br></pre></td></tr></table></figure>\n\n<p>1.21 以下的 Kubernetes 版本会提示以下错误，将 yaml 文件下载将 batch/v1 修改为 batch/v1beta1</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: unable to recognize &quot;https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml&quot;: no matches for kind &quot;CronJob&quot; in version &quot;batch/v1&quot;</span><br></pre></td></tr></table></figure>\n\n<p>1.20.x cronjob 还处于 beta 阶段，1.21 版本开始 cronjob 才正式 GA 。</p>\n<p>默认部署 web-ui 使用的是 loadblance 类型的 Service，为了方便访问修改为 NodePort，也可以通过 Ingress 对外提供服务</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl patch  svc neuvector-service-webui  -n neuvector --type=&#x27;json&#x27; -p &#x27;[&#123;<span class=\"string\">&quot;op&quot;</span>:<span class=\"string\">&quot;replace&quot;</span>,<span class=\"string\">&quot;path&quot;</span>:<span class=\"string\">&quot;/spec/type&quot;</span>,<span class=\"string\">&quot;value&quot;</span>:<span class=\"string\">&quot;NodePort&quot;</span>&#125;,&#123;<span class=\"string\">&quot;op&quot;</span>:<span class=\"string\">&quot;add&quot;</span>,<span class=\"string\">&quot;path&quot;</span>:<span class=\"string\">&quot;/spec/ports/0/nodePort&quot;</span>,<span class=\"string\">&quot;value&quot;</span>:30888&#125;]&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遇到的问题与解决\"><a href=\"#遇到的问题与解决\" class=\"headerlink\" title=\"遇到的问题与解决\"></a>遇到的问题与解决</h3><p>NeuVector 安装部署需要在k8s集群中部署包括controller，enforcer，manager，scanner在内的若干个pod，通过官方的yaml文件进行部署时，出现了上述的镜像拉取失败而导致的pod启动失败的问题。</p>\n<p><img src=\"/post/8e372fbf/err5.png\"><br><img src=\"/post/8e372fbf/err6.png\"></p>\n<p>如上图所示，多数pod启动失败，原因皆为镜像拉取失败导致的，查看官方提供的yaml文件，得知所有镜像的默认拉取策略为<code>Always</code>，尝试将其改为<code>IfNotPresent</code>，并提前手动拉取镜像(<code>docker pull</code>)到node节点本地来提高pod的部署与启动速度。</p>\n<p>出现网络问题，这个应该就是之前镜像拉取失败的主要原因：<br><img src=\"/post/8e372fbf/err3.png\"><br>尝试配置DNS解析，并重启docker服务后解决：<br><img src=\"/post/8e372fbf/err4.png\"><br>所有的镜像均手动拉取下来后，重启之前启动失败的pod<br><img src=\"/post/8e372fbf/succ0.png\"><br>访问 <code>https://node-ip:30888</code>，使用 admin/admin登录<br><img src=\"/post/8e372fbf/succ1.png\"></p>\n<h3 id=\"Trial\"><a href=\"#Trial\" class=\"headerlink\" title=\"Trial\"></a>Trial</h3><ul>\n<li>查看容器存在的中高危漏洞情况<br><img src=\"/post/8e372fbf/use0.png\"></li>\n<li>查看容器内存使用与网络通信情况<br><img src=\"/post/8e372fbf/use1.png\"></li>\n<li>配置容器应用分组的相关进程规则，文件访问规则等<br><img src=\"/post/8e372fbf/use2.png\"></li>\n<li>配置集群与容器的网络规则<br><img src=\"/post/8e372fbf/use3.png\"><br><img src=\"/post/8e372fbf/use5.png\"></li>\n<li>查看集群中的安全事件<br><img src=\"/post/8e372fbf/use4.png\"></li>\n<li>…</li>\n</ul>\n","site":{"data":{}},"cover":"/img/c6.jpg","excerpt":"","more":"<h1 id=\"主机网络模式探究\"><a href=\"#主机网络模式探究\" class=\"headerlink\" title=\"主机网络模式探究\"></a>主机网络模式探究</h1><blockquote>\n<p>Pod为Host网络模式，即直接使用宿主机的网络，不进行网络虚拟化隔离。这样一来，Pod中的所有容器就直接暴露在宿主机的网络环境中，这时候，Pod的PodIP就是其所在Node的IP。<br>从原理上来说，当设定Pod的网络为Host时，是设定了Pod中pod-infrastructure（或pause）容器的网络为Host，Pod内部其他容器的网络指向该容器。</p>\n</blockquote>\n<h2 id=\"Yaml\"><a href=\"#Yaml\" class=\"headerlink\" title=\"Yaml\"></a>Yaml</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mynginx</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># 宿主机不存在则拉取远程</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">hostNetwork:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"k8s-pod镜像拉取策略\"><a href=\"#k8s-pod镜像拉取策略\" class=\"headerlink\" title=\"k8s pod镜像拉取策略\"></a>k8s pod镜像拉取策略</h2><ul>\n<li>Always：每次创建pod时重新远程拉取镜像</li>\n<li>IfNotPresent：宿主机不存在则拉取远程</li>\n<li>Never：只使用宿主机上存在的，永不拉取</li>\n</ul>\n<h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 根据yaml配置文件创建资源</span></span><br><span class=\"line\">kubectl create -f xxx.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 资源本不存在: 创建新资源。</span></span><br><span class=\"line\"><span class=\"comment\"># 资源已存在: 使配置在已存在的资源上生效</span></span><br><span class=\"line\">kubectl apply -f xxx.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取某类资源列表信息</span></span><br><span class=\"line\">kubectl get pod/deployment/...</span><br><span class=\"line\"><span class=\"comment\"># 删除某类资源</span></span><br><span class=\"line\">kubectl delete pod/deployment/...</span><br><span class=\"line\"><span class=\"comment\"># 详细信息</span></span><br><span class=\"line\">kubectl describe pod</span><br><span class=\"line\"><span class=\"comment\"># 打印日志</span></span><br><span class=\"line\">kubectl logs</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p><img src=\"/post/8e372fbf/err0.png\"></p>\n<ul>\n<li>ImagePullBackOff：远程镜像拉取失败</li>\n<li>ErrImageNeverPull：当策略为Never且部署节点上不存在该镜像；从节点上要有这个镜像。<strong>准确的说是调度到哪个节点，那个节点上就要有这个镜像</strong>，否则会报错；<em>当使用本地镜像时需要注意该问题！</em></li>\n</ul>\n<p><img src=\"/post/8e372fbf/err1.png\"><br><img src=\"/post/8e372fbf/err2.png\"><br>已pod形式启动了一个镜像，执行kubectl get pod 查看状态，发现pod一直重启。查看具体的报错信息，发现报错内容为：Back-off restarting failed container</p>\n<ul>\n<li>原因：镜像启动容器后，<strong>容器内部没有常驻进程，导致容器启动成功后即退出</strong>，从而进行了持续的重启。</li>\n<li>解决：只需要给容器加上一个常驻的进程就可以要使Pod持续运行，就必须指定一个永远不会完成的任务。<br>因此在yaml文件中指定一个启动命令，完整内容如下:<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mynginx</span></span><br><span class=\"line\">        <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span> <span class=\"comment\"># 宿主机不存在则拉取远程</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">command:</span> [<span class=\"string\">&quot;/bin/bash&quot;</span>, <span class=\"string\">&quot;-ce&quot;</span>, <span class=\"string\">&quot;tail -f /dev/null&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">hostNetwork:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"K8s防护调研\"><a href=\"#K8s防护调研\" class=\"headerlink\" title=\"K8s防护调研\"></a>K8s防护调研</h1><h2 id=\"KubeArmor\"><a href=\"#KubeArmor\" class=\"headerlink\" title=\"KubeArmor\"></a>KubeArmor</h2><blockquote>\n<p>KubeArmor是一个支持<a href=\"https://cloud.tencent.com/product/tke?from=20065&from_column=20065\">容器</a>的运行时安全实施系统，它可以从系统级别限制容器的行为（如进程执行、文件访问、网络操作和资源利用率）。</p>\n</blockquote>\n<p><a href=\"https://kubearmor.io/\">官网</a><br><a href=\"https://github.com/kubearmor/KubeArmor\">git</a> </p>\n<p>该工具可通过规则配置，对容器指定资源与行为进行监控和拦截，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">security.kubearmor.com/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">KubeArmorPolicy</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">ksp-group-1-proc-path-block</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">multiubuntu</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">group:</span> <span class=\"string\">group-1</span></span><br><span class=\"line\">  <span class=\"attr\">process:</span></span><br><span class=\"line\">    <span class=\"attr\">matchPaths:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">path:</span> <span class=\"string\">/bin/sleep</span></span><br><span class=\"line\">  <span class=\"attr\">action:</span></span><br><span class=\"line\">    <span class=\"string\">Block</span></span><br></pre></td></tr></table></figure>\n<p>说明：此策略的目的是阻止在带有“group-1”标签的容器中执行“/bin/sleep”。 为此，我们在 selector -&gt; matchLabels 中定义 ‘group-1’ 标签，在 process -&gt; matchPaths 中定义特定路径（’/bin/sleep’）。 此外，我们将“阻止”作为此策略的操作。<br>通过不同的规则配置可达到不同的拦截效果，下面列举出部分：</p>\n<ul>\n<li>Block a specific executable</li>\n<li>Block all executables in a specific directory</li>\n<li>Block all executables in a specific directory and its subdirectories</li>\n<li>Allow specific executables to access certain files only</li>\n<li>…..</li>\n</ul>\n<h2 id=\"NeuVector\"><a href=\"#NeuVector\" class=\"headerlink\" title=\"NeuVector\"></a>NeuVector</h2><blockquote>\n<p>NeuVector提供实时深入的容器网络可视化、东西向容器网络监控、主动隔离和保护、容器主机安全以及容器内部安全。<br>NeuVector并非某个组件或者安全工具，而是一套完整的容器安全平台。</p>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/panlifeng/p/16326578.html\">Install</a></p>\n<h3 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h3><p>创建 namespace</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create <span class=\"keyword\">namespace</span> neuvector</span><br></pre></td></tr></table></figure>\n\n<p>部署 CRD (Kubernetes 1.19+ 版本)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/crd</span>-k8s-<span class=\"number\">1.19</span>.yaml</span><br></pre></td></tr></table></figure>\n\n<p>部署 CRD (Kubernetes 1.18 或更低版本)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/crd</span>-k8s-<span class=\"number\">1.16</span>.yaml</span><br></pre></td></tr></table></figure>\n\n<p>配置 RBAC</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>app <span class=\"comment\">--verb=get,list,watch,update --resource=nodes,pods,services,namespaces</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>rbac <span class=\"comment\">--verb=get,list,watch --resource=rolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,clusterroles.rbac.authorization.k8s.io</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>app <span class=\"comment\">--clusterrole=neuvector-binding-app --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>rbac <span class=\"comment\">--clusterrole=neuvector-binding-rbac --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>admission <span class=\"comment\">--verb=get,list,watch,create,update,delete --resource=validatingwebhookconfigurations,mutatingwebhookconfigurations</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>admission <span class=\"comment\">--clusterrole=neuvector-binding-admission --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>customresourcedefinition <span class=\"comment\">--verb=watch,create,get --resource=customresourcedefinitions</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding  neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>customresourcedefinition <span class=\"comment\">--clusterrole=neuvector-binding-customresourcedefinition --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrole neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>nvsecurityrules <span class=\"comment\">--verb=list,delete --resource=nvsecurityrules,nvclustersecurityrules</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span>nvsecurityrules <span class=\"comment\">--clusterrole=neuvector-binding-nvsecurityrules --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> clusterrolebinding neuvector<span class=\"operator\">-</span>binding<span class=\"operator\">-</span><span class=\"keyword\">view</span> <span class=\"comment\">--clusterrole=view --serviceaccount=neuvector:default</span></span><br><span class=\"line\">kubectl <span class=\"keyword\">create</span> rolebinding neuvector<span class=\"operator\">-</span>admin <span class=\"comment\">--clusterrole=admin --serviceaccount=neuvector:default -n neuvector</span></span><br></pre></td></tr></table></figure>\n\n<p>检查是否有以下 RBAC 对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get clusterrolebinding  | grep neuvector</span><br><span class=\"line\"></span><br><span class=\"line\">neuvector-binding-admission                            ClusterRole/neuvector-binding-admission                            44h</span><br><span class=\"line\">neuvector-binding-app                                  ClusterRole/neuvector-binding-app                                  44h</span><br><span class=\"line\">neuvector-binding-customresourcedefinition             ClusterRole/neuvector-binding-customresourcedefinition             44h</span><br><span class=\"line\">neuvector-binding-nvadmissioncontrolsecurityrules      ClusterRole/neuvector-binding-nvadmissioncontrolsecurityrules      44h</span><br><span class=\"line\">neuvector-binding-nvsecurityrules                      ClusterRole/neuvector-binding-nvsecurityrules                      44h</span><br><span class=\"line\">neuvector-binding-nvwafsecurityrules                   ClusterRole/neuvector-binding-nvwafsecurityrules                   44h</span><br><span class=\"line\">neuvector-binding-rbac                                 ClusterRole/neuvector-binding-rbac                                 44h</span><br><span class=\"line\">neuvector-binding-view                                 ClusterRole/view                                                   44h</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get rolebinding -n neuvector | grep neuvector</span><br><span class=\"line\"></span><br><span class=\"line\">neuvector-admin         ClusterRole/admin            44h</span><br><span class=\"line\">neuvector-binding-psp   Role/neuvector-binding-psp   44h</span><br></pre></td></tr></table></figure>\n\n<p>部署 NeuVector</p>\n<p>底层 Runtime 为 Docker</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/</span><span class=\"number\">5.0</span>.<span class=\"number\">0</span>/neuvector-docker-k8s.yaml</span><br></pre></td></tr></table></figure>\n\n<p>底层 Runtime 为 Containerd（对于 k3s 和 rke2 可以使用此 yaml 文件）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f <span class=\"symbol\">https:</span>/<span class=\"regexp\">/raw.githubusercontent.com/neuvector</span><span class=\"regexp\">/manifests/main</span><span class=\"regexp\">/kubernetes/</span><span class=\"number\">5.0</span>.<span class=\"number\">0</span>/neuvector-containerd-k8s.yaml</span><br></pre></td></tr></table></figure>\n\n<p>1.21 以下的 Kubernetes 版本会提示以下错误，将 yaml 文件下载将 batch/v1 修改为 batch/v1beta1</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: unable to recognize &quot;https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml&quot;: no matches for kind &quot;CronJob&quot; in version &quot;batch/v1&quot;</span><br></pre></td></tr></table></figure>\n\n<p>1.20.x cronjob 还处于 beta 阶段，1.21 版本开始 cronjob 才正式 GA 。</p>\n<p>默认部署 web-ui 使用的是 loadblance 类型的 Service，为了方便访问修改为 NodePort，也可以通过 Ingress 对外提供服务</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl patch  svc neuvector-service-webui  -n neuvector --type=&#x27;json&#x27; -p &#x27;[&#123;<span class=\"string\">&quot;op&quot;</span>:<span class=\"string\">&quot;replace&quot;</span>,<span class=\"string\">&quot;path&quot;</span>:<span class=\"string\">&quot;/spec/type&quot;</span>,<span class=\"string\">&quot;value&quot;</span>:<span class=\"string\">&quot;NodePort&quot;</span>&#125;,&#123;<span class=\"string\">&quot;op&quot;</span>:<span class=\"string\">&quot;add&quot;</span>,<span class=\"string\">&quot;path&quot;</span>:<span class=\"string\">&quot;/spec/ports/0/nodePort&quot;</span>,<span class=\"string\">&quot;value&quot;</span>:30888&#125;]&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遇到的问题与解决\"><a href=\"#遇到的问题与解决\" class=\"headerlink\" title=\"遇到的问题与解决\"></a>遇到的问题与解决</h3><p>NeuVector 安装部署需要在k8s集群中部署包括controller，enforcer，manager，scanner在内的若干个pod，通过官方的yaml文件进行部署时，出现了上述的镜像拉取失败而导致的pod启动失败的问题。</p>\n<p><img src=\"/post/8e372fbf/err5.png\"><br><img src=\"/post/8e372fbf/err6.png\"></p>\n<p>如上图所示，多数pod启动失败，原因皆为镜像拉取失败导致的，查看官方提供的yaml文件，得知所有镜像的默认拉取策略为<code>Always</code>，尝试将其改为<code>IfNotPresent</code>，并提前手动拉取镜像(<code>docker pull</code>)到node节点本地来提高pod的部署与启动速度。</p>\n<p>出现网络问题，这个应该就是之前镜像拉取失败的主要原因：<br><img src=\"/post/8e372fbf/err3.png\"><br>尝试配置DNS解析，并重启docker服务后解决：<br><img src=\"/post/8e372fbf/err4.png\"><br>所有的镜像均手动拉取下来后，重启之前启动失败的pod<br><img src=\"/post/8e372fbf/succ0.png\"><br>访问 <code>https://node-ip:30888</code>，使用 admin/admin登录<br><img src=\"/post/8e372fbf/succ1.png\"></p>\n<h3 id=\"Trial\"><a href=\"#Trial\" class=\"headerlink\" title=\"Trial\"></a>Trial</h3><ul>\n<li>查看容器存在的中高危漏洞情况<br><img src=\"/post/8e372fbf/use0.png\"></li>\n<li>查看容器内存使用与网络通信情况<br><img src=\"/post/8e372fbf/use1.png\"></li>\n<li>配置容器应用分组的相关进程规则，文件访问规则等<br><img src=\"/post/8e372fbf/use2.png\"></li>\n<li>配置集群与容器的网络规则<br><img src=\"/post/8e372fbf/use3.png\"><br><img src=\"/post/8e372fbf/use5.png\"></li>\n<li>查看集群中的安全事件<br><img src=\"/post/8e372fbf/use4.png\"></li>\n<li>…</li>\n</ul>\n"},{"title":"Raft算法","abbrlink":"1df31392","date":"2022-09-13T06:28:59.000Z","_content":"\n# Raft\n\n>   Raft 算法是一种分布式共识算法，旨在使用简单的、易于理解的机制来构建具有较好一致性的分布式系统。为了强调可理解性，Raft将一致性算法分解为几个关键流程（模块），例如选主，安全性，日志复制，通过将分布式一致性这个复杂的问题转化为一系列的小问题进而各个击破的方式来解决问题。\n\n## Raft 特点\n\n解决集群容错，尽可能避免脑裂问题的发生\n\n+   强 leader：Raft 使用比其他共识算法更强的领导形式，例如日志条目（log entries）仅从 leader 流向其他服务器，这简化了复制日志的管理，使 Raft 更容易理解。\n+   Leader 选举：Raft 使用随机计时器(randomized timers)来选举 leaders，这仅为任何共识算法已经需要的心跳增加了少量机制，同时简单快速地解决了冲突。\n+   Membershipchanges：Raft使用了一个新机制joint consensus允许集群动态在线扩容，保障Raft的可持续服务能力。\n\n## 复制状态机\n\n所谓的复制状态机，即一个集群中的节点服务器通过复制集群 leader 中的操作日志，进而计算出完全一致的存储数据副本，使得整个集群内的节点服务器存储的数据达到一致。如图所示，每个服务器节点存储包含一系列命令的日志，节点状态机按顺序执行这些命令。由于状态机是确定性的，每个状态机都计算相同的状态和相同的输出序列。因此，集群leader通过对日志信息的控制保证对整个集群服务器的控制，而这种控制就是通过共识算法实现。\n\n![](Raft算法/fm.png)\n\n\n\n## Raft 节点\n\n### 节点状态(Role)\n\n+   Leader\n    +   负责与客户端交互\n    +   负责整个系统的日志管理与同步\n    +   向各个节点发送心跳包（heartbeat），并携带通信信息\n+   Follower\n    +   响应来自Leader的日志同步请求\n    +   响应来自Candidate的拉票请求\n    +   转发来自客户端的请求给Leader\n+   Candidate\n    +   发送拉票请求\n    +   准备成为Leader\n\n![](Raft算法/role.jpg)\n\n### 节点任期(Term)\n\n**Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。**\n\n+   Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n+   服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。\n\n### 节点通信(RPC)\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPC），并且基本的一致性算法只需要两种类型的 RPC，为了在服务器之间传输快照增加了第三种 RPC：\n\n>   （1）RequestVote RPC：候选人在选举期间发起。\n>   （2）AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。\n>   （3）InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。\n\n\n\n## Leader Election\n\nRaft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。\n\n每一个follower都有一个时钟，是一个随机的值，表示的是follower等待成为leader的时间，在一个时钟内收到来自Leader的心跳包，则重置时钟，谁的时钟先跑完，则发起leader选举。\n\nFollower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：\n\n1.   **赢得选举**：如果一个 candidate 在同一个任期内从这个集群中的大多数服务获得选票，那么它就赢得了选举。每个服务器将在给定的任期内以先到先得的方式投票给至多一名候选者（注意：第 5.4 节增加了对投票的额外限制）。多数规则确保最多一名 candidate 可以赢得特定任期的选举，一旦一个 candidate 赢得了选举它就会成为 leader，然后它向所有其它服务器发送心跳消息以建立其权限并阻止新的选举。\n\n2.   **输掉选举**：在等待投票时， candidte 可能会收到来自另一台声称是 leader 服务的 AppendEntries RPC。如果该 leader 的任期（包含在其 RPC 中）大于等于 candidate 当前任期，则 candidate 将 leader 视为合法并返回 follower 状态。否则将拒绝 RPC 并继续处于 candidate 。\n\n     <img src=\"Raft算法/voting.png\" style=\"zoom:80%;\" />\n\n3.   **无人胜出**：第三种可能的结果是这次选举candidate既没赢也没输：如果同时有多个 follower 成为 candidate ，可能会分裂选票，导致没有 candidate 获得多数票，发生这种情况时，每个 candidate 将超时并通过增加其任期并启动另一轮 RequestVote RPC 来开始新的选举。然而如果没有额外的措施，分裂选票可能会无限期地重复。\n\n     <img src=\"Raft算法\\votin_fail.png\" style=\"zoom:80%;\" />\n\n\n\n## Log Replication\n\n当Leader被选举出来后，用户的每一个提交的操作都会被Leader追加到本地日志中，根据与客户端的交互的情况实施长期周期性的日志复制操作，Leader 必须确保新增条目被安全复制且持久化（**AppendEntries RPC**）后，才会将该条目交给状态机来执行，然后返回执行结果。\n\n如何界定新增条目的安全持久化？\n\n### Commited 状态\n\n当某新增条目（Entry）被**<u>过半</u>**的Follower都安全的接收并持久化新增条目时，则称该条目Commited，该状态的条目能够确保能被可用的状态机执行。\n\n### Raft日志特性\n\n-   如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。\n-   如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。\n\n1.   **第一个特性**：leader在给定的term和index上只能创建一个entry，而且entry不被允许修改位置。\n\n2.   **第二个特性**：通过**<u>AppendEntries</u>**执行的简单一致性来保证。\n\n     首先从leader发出的AppendEntries中有两个比较重要的参数：\n\n     1.   prevLogIndex ：新entry对应的前一个entry对应的LogIndex（也就是leader当前日志中最后一个entry对应的log index）\n     2.   prevLogTerm : 新entry对应的前一个entry对应的term（也就是leader当前日志中最后一个entry对应的log term）\n\nfollower收到AppendEntries请求后，查看自己的log当中有没有prevLogIndex、prevLogTerm对应的entry。followed发现自己日志没有的话，就说明自己的日志滞后当前的leader，拒绝将entries添加到自己的log中。\n\n**通过维护以上两个特性，可以保持Leader进行日志复制时的高一致性**\n\n1.   通过AppendEntries 找到日志冲突点，就是follower从哪个位置开始和leader的日志不一致了\n2.   leader把follower日志冲突点以后的日志强行刷新成自己的。\n\n具体细节就是leader会向follower不间断的发送AppendEntries请求，如果follower返回false的话，那就证明follower和leader不一致。那么leader发送的AppendEntries就会把 index减1再次发送，直至和follower匹配上。匹配成功以后，通过AppendEntries请求将leader上的entries同步至follower。\n\n论文中有提到的一个优化手段就是AppendEntries请求返回失败同时，follower也返回冲突entry所在的任期和所在任期的第一个entry对应的logIndex。通过这两个信息，leader调整下次发送的prevLogIndex和prevLogTerm,可以减少rpc请求。\n\n\n\n## Safety\n\n","source":"_posts/Raft算法.md","raw":"---\ntitle: Raft算法\ntags:\n  - 分布式\n  - 共识算法(consensus)\ncategories:\n  - MIT 6.824\nabbrlink: 1df31392\ndate: 2022-09-13 14:28:59\n---\n\n# Raft\n\n>   Raft 算法是一种分布式共识算法，旨在使用简单的、易于理解的机制来构建具有较好一致性的分布式系统。为了强调可理解性，Raft将一致性算法分解为几个关键流程（模块），例如选主，安全性，日志复制，通过将分布式一致性这个复杂的问题转化为一系列的小问题进而各个击破的方式来解决问题。\n\n## Raft 特点\n\n解决集群容错，尽可能避免脑裂问题的发生\n\n+   强 leader：Raft 使用比其他共识算法更强的领导形式，例如日志条目（log entries）仅从 leader 流向其他服务器，这简化了复制日志的管理，使 Raft 更容易理解。\n+   Leader 选举：Raft 使用随机计时器(randomized timers)来选举 leaders，这仅为任何共识算法已经需要的心跳增加了少量机制，同时简单快速地解决了冲突。\n+   Membershipchanges：Raft使用了一个新机制joint consensus允许集群动态在线扩容，保障Raft的可持续服务能力。\n\n## 复制状态机\n\n所谓的复制状态机，即一个集群中的节点服务器通过复制集群 leader 中的操作日志，进而计算出完全一致的存储数据副本，使得整个集群内的节点服务器存储的数据达到一致。如图所示，每个服务器节点存储包含一系列命令的日志，节点状态机按顺序执行这些命令。由于状态机是确定性的，每个状态机都计算相同的状态和相同的输出序列。因此，集群leader通过对日志信息的控制保证对整个集群服务器的控制，而这种控制就是通过共识算法实现。\n\n![](Raft算法/fm.png)\n\n\n\n## Raft 节点\n\n### 节点状态(Role)\n\n+   Leader\n    +   负责与客户端交互\n    +   负责整个系统的日志管理与同步\n    +   向各个节点发送心跳包（heartbeat），并携带通信信息\n+   Follower\n    +   响应来自Leader的日志同步请求\n    +   响应来自Candidate的拉票请求\n    +   转发来自客户端的请求给Leader\n+   Candidate\n    +   发送拉票请求\n    +   准备成为Leader\n\n![](Raft算法/role.jpg)\n\n### 节点任期(Term)\n\n**Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。**\n\n+   Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。\n+   服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。\n\n### 节点通信(RPC)\n\nRaft 算法中服务器节点之间通信使用远程过程调用（RPC），并且基本的一致性算法只需要两种类型的 RPC，为了在服务器之间传输快照增加了第三种 RPC：\n\n>   （1）RequestVote RPC：候选人在选举期间发起。\n>   （2）AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。\n>   （3）InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。\n\n\n\n## Leader Election\n\nRaft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。\n\n每一个follower都有一个时钟，是一个随机的值，表示的是follower等待成为leader的时间，在一个时钟内收到来自Leader的心跳包，则重置时钟，谁的时钟先跑完，则发起leader选举。\n\nFollower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：\n\n1.   **赢得选举**：如果一个 candidate 在同一个任期内从这个集群中的大多数服务获得选票，那么它就赢得了选举。每个服务器将在给定的任期内以先到先得的方式投票给至多一名候选者（注意：第 5.4 节增加了对投票的额外限制）。多数规则确保最多一名 candidate 可以赢得特定任期的选举，一旦一个 candidate 赢得了选举它就会成为 leader，然后它向所有其它服务器发送心跳消息以建立其权限并阻止新的选举。\n\n2.   **输掉选举**：在等待投票时， candidte 可能会收到来自另一台声称是 leader 服务的 AppendEntries RPC。如果该 leader 的任期（包含在其 RPC 中）大于等于 candidate 当前任期，则 candidate 将 leader 视为合法并返回 follower 状态。否则将拒绝 RPC 并继续处于 candidate 。\n\n     <img src=\"Raft算法/voting.png\" style=\"zoom:80%;\" />\n\n3.   **无人胜出**：第三种可能的结果是这次选举candidate既没赢也没输：如果同时有多个 follower 成为 candidate ，可能会分裂选票，导致没有 candidate 获得多数票，发生这种情况时，每个 candidate 将超时并通过增加其任期并启动另一轮 RequestVote RPC 来开始新的选举。然而如果没有额外的措施，分裂选票可能会无限期地重复。\n\n     <img src=\"Raft算法\\votin_fail.png\" style=\"zoom:80%;\" />\n\n\n\n## Log Replication\n\n当Leader被选举出来后，用户的每一个提交的操作都会被Leader追加到本地日志中，根据与客户端的交互的情况实施长期周期性的日志复制操作，Leader 必须确保新增条目被安全复制且持久化（**AppendEntries RPC**）后，才会将该条目交给状态机来执行，然后返回执行结果。\n\n如何界定新增条目的安全持久化？\n\n### Commited 状态\n\n当某新增条目（Entry）被**<u>过半</u>**的Follower都安全的接收并持久化新增条目时，则称该条目Commited，该状态的条目能够确保能被可用的状态机执行。\n\n### Raft日志特性\n\n-   如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。\n-   如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。\n\n1.   **第一个特性**：leader在给定的term和index上只能创建一个entry，而且entry不被允许修改位置。\n\n2.   **第二个特性**：通过**<u>AppendEntries</u>**执行的简单一致性来保证。\n\n     首先从leader发出的AppendEntries中有两个比较重要的参数：\n\n     1.   prevLogIndex ：新entry对应的前一个entry对应的LogIndex（也就是leader当前日志中最后一个entry对应的log index）\n     2.   prevLogTerm : 新entry对应的前一个entry对应的term（也就是leader当前日志中最后一个entry对应的log term）\n\nfollower收到AppendEntries请求后，查看自己的log当中有没有prevLogIndex、prevLogTerm对应的entry。followed发现自己日志没有的话，就说明自己的日志滞后当前的leader，拒绝将entries添加到自己的log中。\n\n**通过维护以上两个特性，可以保持Leader进行日志复制时的高一致性**\n\n1.   通过AppendEntries 找到日志冲突点，就是follower从哪个位置开始和leader的日志不一致了\n2.   leader把follower日志冲突点以后的日志强行刷新成自己的。\n\n具体细节就是leader会向follower不间断的发送AppendEntries请求，如果follower返回false的话，那就证明follower和leader不一致。那么leader发送的AppendEntries就会把 index减1再次发送，直至和follower匹配上。匹配成功以后，通过AppendEntries请求将leader上的entries同步至follower。\n\n论文中有提到的一个优化手段就是AppendEntries请求返回失败同时，follower也返回冲突entry所在的任期和所在任期的第一个entry对应的logIndex。通过这两个信息，leader调整下次发送的prevLogIndex和prevLogTerm,可以减少rpc请求。\n\n\n\n## Safety\n\n","slug":"Raft算法","published":1,"updated":"2022-09-16T06:00:50.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjn000jecwd1n1jeykk","content":"<h1 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h1><blockquote>\n<p>  Raft 算法是一种分布式共识算法，旨在使用简单的、易于理解的机制来构建具有较好一致性的分布式系统。为了强调可理解性，Raft将一致性算法分解为几个关键流程（模块），例如选主，安全性，日志复制，通过将分布式一致性这个复杂的问题转化为一系列的小问题进而各个击破的方式来解决问题。</p>\n</blockquote>\n<h2 id=\"Raft-特点\"><a href=\"#Raft-特点\" class=\"headerlink\" title=\"Raft 特点\"></a>Raft 特点</h2><p>解决集群容错，尽可能避免脑裂问题的发生</p>\n<ul>\n<li>  强 leader：Raft 使用比其他共识算法更强的领导形式，例如日志条目（log entries）仅从 leader 流向其他服务器，这简化了复制日志的管理，使 Raft 更容易理解。</li>\n<li>  Leader 选举：Raft 使用随机计时器(randomized timers)来选举 leaders，这仅为任何共识算法已经需要的心跳增加了少量机制，同时简单快速地解决了冲突。</li>\n<li>  Membershipchanges：Raft使用了一个新机制joint consensus允许集群动态在线扩容，保障Raft的可持续服务能力。</li>\n</ul>\n<h2 id=\"复制状态机\"><a href=\"#复制状态机\" class=\"headerlink\" title=\"复制状态机\"></a>复制状态机</h2><p>所谓的复制状态机，即一个集群中的节点服务器通过复制集群 leader 中的操作日志，进而计算出完全一致的存储数据副本，使得整个集群内的节点服务器存储的数据达到一致。如图所示，每个服务器节点存储包含一系列命令的日志，节点状态机按顺序执行这些命令。由于状态机是确定性的，每个状态机都计算相同的状态和相同的输出序列。因此，集群leader通过对日志信息的控制保证对整个集群服务器的控制，而这种控制就是通过共识算法实现。</p>\n<p><img src=\"/post/1df31392/fm.png\"></p>\n<h2 id=\"Raft-节点\"><a href=\"#Raft-节点\" class=\"headerlink\" title=\"Raft 节点\"></a>Raft 节点</h2><h3 id=\"节点状态-Role\"><a href=\"#节点状态-Role\" class=\"headerlink\" title=\"节点状态(Role)\"></a>节点状态(Role)</h3><ul>\n<li>Leader<ul>\n<li>  负责与客户端交互</li>\n<li>  负责整个系统的日志管理与同步</li>\n<li>  向各个节点发送心跳包（heartbeat），并携带通信信息</li>\n</ul>\n</li>\n<li>Follower<ul>\n<li>  响应来自Leader的日志同步请求</li>\n<li>  响应来自Candidate的拉票请求</li>\n<li>  转发来自客户端的请求给Leader</li>\n</ul>\n</li>\n<li>Candidate<ul>\n<li>  发送拉票请求</li>\n<li>  准备成为Leader</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/post/1df31392/role.jpg\"></p>\n<h3 id=\"节点任期-Term\"><a href=\"#节点任期-Term\" class=\"headerlink\" title=\"节点任期(Term)\"></a>节点任期(Term)</h3><p><strong>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</strong></p>\n<ul>\n<li>  Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</li>\n<li>  服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</li>\n</ul>\n<h3 id=\"节点通信-RPC\"><a href=\"#节点通信-RPC\" class=\"headerlink\" title=\"节点通信(RPC)\"></a>节点通信(RPC)</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPC），并且基本的一致性算法只需要两种类型的 RPC，为了在服务器之间传输快照增加了第三种 RPC：</p>\n<blockquote>\n<p>  （1）RequestVote RPC：候选人在选举期间发起。<br>  （2）AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。<br>  （3）InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。</p>\n</blockquote>\n<h2 id=\"Leader-Election\"><a href=\"#Leader-Election\" class=\"headerlink\" title=\"Leader Election\"></a>Leader Election</h2><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p>\n<p>每一个follower都有一个时钟，是一个随机的值，表示的是follower等待成为leader的时间，在一个时钟内收到来自Leader的心跳包，则重置时钟，谁的时钟先跑完，则发起leader选举。</p>\n<p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：</p>\n<ol>\n<li><p>  <strong>赢得选举</strong>：如果一个 candidate 在同一个任期内从这个集群中的大多数服务获得选票，那么它就赢得了选举。每个服务器将在给定的任期内以先到先得的方式投票给至多一名候选者（注意：第 5.4 节增加了对投票的额外限制）。多数规则确保最多一名 candidate 可以赢得特定任期的选举，一旦一个 candidate 赢得了选举它就会成为 leader，然后它向所有其它服务器发送心跳消息以建立其权限并阻止新的选举。</p>\n</li>\n<li><p><strong>输掉选举</strong>：在等待投票时， candidte 可能会收到来自另一台声称是 leader 服务的 AppendEntries RPC。如果该 leader 的任期（包含在其 RPC 中）大于等于 candidate 当前任期，则 candidate 将 leader 视为合法并返回 follower 状态。否则将拒绝 RPC 并继续处于 candidate 。</p>\n  <img src=\"/post/1df31392/voting.png\" style=\"zoom:80%;\"></li>\n<li><p><strong>无人胜出</strong>：第三种可能的结果是这次选举candidate既没赢也没输：如果同时有多个 follower 成为 candidate ，可能会分裂选票，导致没有 candidate 获得多数票，发生这种情况时，每个 candidate 将超时并通过增加其任期并启动另一轮 RequestVote RPC 来开始新的选举。然而如果没有额外的措施，分裂选票可能会无限期地重复。</p>\n  <img src=\"/post/1df31392/votin_fail.png\" style=\"zoom:80%;\"></li>\n</ol>\n<h2 id=\"Log-Replication\"><a href=\"#Log-Replication\" class=\"headerlink\" title=\"Log Replication\"></a>Log Replication</h2><p>当Leader被选举出来后，用户的每一个提交的操作都会被Leader追加到本地日志中，根据与客户端的交互的情况实施长期周期性的日志复制操作，Leader 必须确保新增条目被安全复制且持久化（<strong>AppendEntries RPC</strong>）后，才会将该条目交给状态机来执行，然后返回执行结果。</p>\n<p>如何界定新增条目的安全持久化？</p>\n<h3 id=\"Commited-状态\"><a href=\"#Commited-状态\" class=\"headerlink\" title=\"Commited 状态\"></a>Commited 状态</h3><p>当某新增条目（Entry）被**<u>过半</u>**的Follower都安全的接收并持久化新增条目时，则称该条目Commited，该状态的条目能够确保能被可用的状态机执行。</p>\n<h3 id=\"Raft日志特性\"><a href=\"#Raft日志特性\" class=\"headerlink\" title=\"Raft日志特性\"></a>Raft日志特性</h3><ul>\n<li>  如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>\n<li>  如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li>\n</ul>\n<ol>\n<li><p>  <strong>第一个特性</strong>：leader在给定的term和index上只能创建一个entry，而且entry不被允许修改位置。</p>\n</li>\n<li><p><strong>第二个特性</strong>：通过**<u>AppendEntries</u>**执行的简单一致性来保证。</p>\n<p>  首先从leader发出的AppendEntries中有两个比较重要的参数：</p>\n<ol>\n<li>  prevLogIndex ：新entry对应的前一个entry对应的LogIndex（也就是leader当前日志中最后一个entry对应的log index）</li>\n<li>  prevLogTerm : 新entry对应的前一个entry对应的term（也就是leader当前日志中最后一个entry对应的log term）</li>\n</ol>\n</li>\n</ol>\n<p>follower收到AppendEntries请求后，查看自己的log当中有没有prevLogIndex、prevLogTerm对应的entry。followed发现自己日志没有的话，就说明自己的日志滞后当前的leader，拒绝将entries添加到自己的log中。</p>\n<p><strong>通过维护以上两个特性，可以保持Leader进行日志复制时的高一致性</strong></p>\n<ol>\n<li>  通过AppendEntries 找到日志冲突点，就是follower从哪个位置开始和leader的日志不一致了</li>\n<li>  leader把follower日志冲突点以后的日志强行刷新成自己的。</li>\n</ol>\n<p>具体细节就是leader会向follower不间断的发送AppendEntries请求，如果follower返回false的话，那就证明follower和leader不一致。那么leader发送的AppendEntries就会把 index减1再次发送，直至和follower匹配上。匹配成功以后，通过AppendEntries请求将leader上的entries同步至follower。</p>\n<p>论文中有提到的一个优化手段就是AppendEntries请求返回失败同时，follower也返回冲突entry所在的任期和所在任期的第一个entry对应的logIndex。通过这两个信息，leader调整下次发送的prevLogIndex和prevLogTerm,可以减少rpc请求。</p>\n<h2 id=\"Safety\"><a href=\"#Safety\" class=\"headerlink\" title=\"Safety\"></a>Safety</h2>","site":{"data":{}},"cover":"/img/c10.jpg","excerpt":"","more":"<h1 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h1><blockquote>\n<p>  Raft 算法是一种分布式共识算法，旨在使用简单的、易于理解的机制来构建具有较好一致性的分布式系统。为了强调可理解性，Raft将一致性算法分解为几个关键流程（模块），例如选主，安全性，日志复制，通过将分布式一致性这个复杂的问题转化为一系列的小问题进而各个击破的方式来解决问题。</p>\n</blockquote>\n<h2 id=\"Raft-特点\"><a href=\"#Raft-特点\" class=\"headerlink\" title=\"Raft 特点\"></a>Raft 特点</h2><p>解决集群容错，尽可能避免脑裂问题的发生</p>\n<ul>\n<li>  强 leader：Raft 使用比其他共识算法更强的领导形式，例如日志条目（log entries）仅从 leader 流向其他服务器，这简化了复制日志的管理，使 Raft 更容易理解。</li>\n<li>  Leader 选举：Raft 使用随机计时器(randomized timers)来选举 leaders，这仅为任何共识算法已经需要的心跳增加了少量机制，同时简单快速地解决了冲突。</li>\n<li>  Membershipchanges：Raft使用了一个新机制joint consensus允许集群动态在线扩容，保障Raft的可持续服务能力。</li>\n</ul>\n<h2 id=\"复制状态机\"><a href=\"#复制状态机\" class=\"headerlink\" title=\"复制状态机\"></a>复制状态机</h2><p>所谓的复制状态机，即一个集群中的节点服务器通过复制集群 leader 中的操作日志，进而计算出完全一致的存储数据副本，使得整个集群内的节点服务器存储的数据达到一致。如图所示，每个服务器节点存储包含一系列命令的日志，节点状态机按顺序执行这些命令。由于状态机是确定性的，每个状态机都计算相同的状态和相同的输出序列。因此，集群leader通过对日志信息的控制保证对整个集群服务器的控制，而这种控制就是通过共识算法实现。</p>\n<p><img src=\"/post/1df31392/fm.png\"></p>\n<h2 id=\"Raft-节点\"><a href=\"#Raft-节点\" class=\"headerlink\" title=\"Raft 节点\"></a>Raft 节点</h2><h3 id=\"节点状态-Role\"><a href=\"#节点状态-Role\" class=\"headerlink\" title=\"节点状态(Role)\"></a>节点状态(Role)</h3><ul>\n<li>Leader<ul>\n<li>  负责与客户端交互</li>\n<li>  负责整个系统的日志管理与同步</li>\n<li>  向各个节点发送心跳包（heartbeat），并携带通信信息</li>\n</ul>\n</li>\n<li>Follower<ul>\n<li>  响应来自Leader的日志同步请求</li>\n<li>  响应来自Candidate的拉票请求</li>\n<li>  转发来自客户端的请求给Leader</li>\n</ul>\n</li>\n<li>Candidate<ul>\n<li>  发送拉票请求</li>\n<li>  准备成为Leader</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/post/1df31392/role.jpg\"></p>\n<h3 id=\"节点任期-Term\"><a href=\"#节点任期-Term\" class=\"headerlink\" title=\"节点任期(Term)\"></a>节点任期(Term)</h3><p><strong>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</strong></p>\n<ul>\n<li>  Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</li>\n<li>  服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</li>\n</ul>\n<h3 id=\"节点通信-RPC\"><a href=\"#节点通信-RPC\" class=\"headerlink\" title=\"节点通信(RPC)\"></a>节点通信(RPC)</h3><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPC），并且基本的一致性算法只需要两种类型的 RPC，为了在服务器之间传输快照增加了第三种 RPC：</p>\n<blockquote>\n<p>  （1）RequestVote RPC：候选人在选举期间发起。<br>  （2）AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。<br>  （3）InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。</p>\n</blockquote>\n<h2 id=\"Leader-Election\"><a href=\"#Leader-Election\" class=\"headerlink\" title=\"Leader Election\"></a>Leader Election</h2><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p>\n<p>每一个follower都有一个时钟，是一个随机的值，表示的是follower等待成为leader的时间，在一个时钟内收到来自Leader的心跳包，则重置时钟，谁的时钟先跑完，则发起leader选举。</p>\n<p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：</p>\n<ol>\n<li><p>  <strong>赢得选举</strong>：如果一个 candidate 在同一个任期内从这个集群中的大多数服务获得选票，那么它就赢得了选举。每个服务器将在给定的任期内以先到先得的方式投票给至多一名候选者（注意：第 5.4 节增加了对投票的额外限制）。多数规则确保最多一名 candidate 可以赢得特定任期的选举，一旦一个 candidate 赢得了选举它就会成为 leader，然后它向所有其它服务器发送心跳消息以建立其权限并阻止新的选举。</p>\n</li>\n<li><p><strong>输掉选举</strong>：在等待投票时， candidte 可能会收到来自另一台声称是 leader 服务的 AppendEntries RPC。如果该 leader 的任期（包含在其 RPC 中）大于等于 candidate 当前任期，则 candidate 将 leader 视为合法并返回 follower 状态。否则将拒绝 RPC 并继续处于 candidate 。</p>\n  <img src=\"/post/1df31392/voting.png\" style=\"zoom:80%;\"></li>\n<li><p><strong>无人胜出</strong>：第三种可能的结果是这次选举candidate既没赢也没输：如果同时有多个 follower 成为 candidate ，可能会分裂选票，导致没有 candidate 获得多数票，发生这种情况时，每个 candidate 将超时并通过增加其任期并启动另一轮 RequestVote RPC 来开始新的选举。然而如果没有额外的措施，分裂选票可能会无限期地重复。</p>\n  <img src=\"/post/1df31392/votin_fail.png\" style=\"zoom:80%;\"></li>\n</ol>\n<h2 id=\"Log-Replication\"><a href=\"#Log-Replication\" class=\"headerlink\" title=\"Log Replication\"></a>Log Replication</h2><p>当Leader被选举出来后，用户的每一个提交的操作都会被Leader追加到本地日志中，根据与客户端的交互的情况实施长期周期性的日志复制操作，Leader 必须确保新增条目被安全复制且持久化（<strong>AppendEntries RPC</strong>）后，才会将该条目交给状态机来执行，然后返回执行结果。</p>\n<p>如何界定新增条目的安全持久化？</p>\n<h3 id=\"Commited-状态\"><a href=\"#Commited-状态\" class=\"headerlink\" title=\"Commited 状态\"></a>Commited 状态</h3><p>当某新增条目（Entry）被**<u>过半</u>**的Follower都安全的接收并持久化新增条目时，则称该条目Commited，该状态的条目能够确保能被可用的状态机执行。</p>\n<h3 id=\"Raft日志特性\"><a href=\"#Raft日志特性\" class=\"headerlink\" title=\"Raft日志特性\"></a>Raft日志特性</h3><ul>\n<li>  如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>\n<li>  如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li>\n</ul>\n<ol>\n<li><p>  <strong>第一个特性</strong>：leader在给定的term和index上只能创建一个entry，而且entry不被允许修改位置。</p>\n</li>\n<li><p><strong>第二个特性</strong>：通过**<u>AppendEntries</u>**执行的简单一致性来保证。</p>\n<p>  首先从leader发出的AppendEntries中有两个比较重要的参数：</p>\n<ol>\n<li>  prevLogIndex ：新entry对应的前一个entry对应的LogIndex（也就是leader当前日志中最后一个entry对应的log index）</li>\n<li>  prevLogTerm : 新entry对应的前一个entry对应的term（也就是leader当前日志中最后一个entry对应的log term）</li>\n</ol>\n</li>\n</ol>\n<p>follower收到AppendEntries请求后，查看自己的log当中有没有prevLogIndex、prevLogTerm对应的entry。followed发现自己日志没有的话，就说明自己的日志滞后当前的leader，拒绝将entries添加到自己的log中。</p>\n<p><strong>通过维护以上两个特性，可以保持Leader进行日志复制时的高一致性</strong></p>\n<ol>\n<li>  通过AppendEntries 找到日志冲突点，就是follower从哪个位置开始和leader的日志不一致了</li>\n<li>  leader把follower日志冲突点以后的日志强行刷新成自己的。</li>\n</ol>\n<p>具体细节就是leader会向follower不间断的发送AppendEntries请求，如果follower返回false的话，那就证明follower和leader不一致。那么leader发送的AppendEntries就会把 index减1再次发送，直至和follower匹配上。匹配成功以后，通过AppendEntries请求将leader上的entries同步至follower。</p>\n<p>论文中有提到的一个优化手段就是AppendEntries请求返回失败同时，follower也返回冲突entry所在的任期和所在任期的第一个entry对应的logIndex。通过这两个信息，leader调整下次发送的prevLogIndex和prevLogTerm,可以减少rpc请求。</p>\n<h2 id=\"Safety\"><a href=\"#Safety\" class=\"headerlink\" title=\"Safety\"></a>Safety</h2>"},{"title":"docker学习","abbrlink":"7fb3659b","_content":"\n# Profile\n\n>_Docker_ 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口\n\n## Install\n[Docker官网centos平台安装文档](https://docs.docker.com/engine/install/centos/)\n```bash\n# 卸载旧版本\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n# 安装依赖的包\nsudo yum install -y yum-utils\n\n# 配置镜像仓库\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n# 更新软件包\nsudo yum makecache fast\n\n# 安装\nsudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\nsudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io docker-buildx-plugin docker-compose-plugin\n\nyum -y install docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7 containerd.io-1.2.5-3.1.el7 docker-buildx-plugin docker-compose-plugin\n\n# 启动docker\nsudo systemctl start docker\n\n# 测试安装\ndocker version\nsudo docker run hello-world\n\n```\n\n**配置阿里云镜像加速**\n登录->控制台->侧边栏产品与服务->容器镜像服务->镜像加速器\n![](./docker学习/c5f7d7d0c8d5f55c6c637a68a704e9d.png)\n\n## Error\n+  yum软件包更新时，阿里docker源出错\n\t![](./docker学习/2a9868ee4596ff49f1311f20178704f.png)\n\t解决：切换到 `/etc/yum.repos.d` 目录下，将所有 docker 相关的 `repo`全部删掉后，重新添加镜像，命令如上。\n+ 低版本需要 `yum -y install deltarpm`\n+ etc\n\n# Command\n>常用命令 \n\n[官方DOC](https://docs.docker.com/engine/reference/commandline/cli/)\n## Help\n```bash\ndocker version\ndocker info\ndocker [command] --help\n```\n\n## Image\n> iid: image_id\n> cid: container_id\n```bash\n# 查看所有镜像\ndokcer images\n\n# 搜索\ndocker search\n\n# 下载\n# docker pull mysql:latest\ndocker pull image_name[:tag]\n\n# 删除\ndocker rmi -f [iid]\ndocker rmi -f $(docker images -qa) # 删除全部镜像\n\n# 发布(推送)镜像\ndocker tag ubuntu:18.04 username/ubuntu:18.04\ndocker push username/ubuntu:18.04\n\n```\n\n## Container\n```bash\n# 新建容器并启动\ndocker run [option] image\n# 参数\n--name=\"\" 容器名称\n-d        后台方式启动\n-it       交互式启动，并进入容器\n-p        指定容器端口 \n\t-p 主机端口:容器端口\n\t-p 容器端口\n-P        随机指定端口\n-volumes-from 数据卷容器名（同步数据）\n\n# 创建容器\ndocker create image\n\n# 退出容器\nexit # 停止并退出\nCtrl+p+q # 退出\n\n# 进入容器\ndocker exec -it cid # 新命令行\ndocker attach cid # 原命令行\n\n\n# 查看运行的容器\ndocker ps # 正在运行\ndocker ps -a # 正在运行以及运行过的容器\n\n# 删除容器\ndocker rm cid\ndokcer rm -f $(docker ps -aq) # 删除所有容器\n\n# 启动于停止\ndocker start cid # 启动\ndocker restart cid # 重启\ndocker stop cid # 停止\ndocker kill cid # 强制停止\n\n# 查看容器中进程信息\ndocker top cid\n\n# 查看容器元信息\ndocker inspect cid\n\n# 从容器中拷贝到主机\ndocker cp \n\n```\n\n## Log\n```bash\n# 打印日志\ndocker logs -tf --tail [num] cid\n```\n\n## Image Commit\n```bash\n# 提交容器成为镜像\ndocker commit -m=\"msg\" -a=\"author\" cid image[:tag] \n```\n\n\n## Archive\n```bash\n# 保存镜像为 tar 归档文件\ndocker save [OPTIONS] IMAGE [IMAGE...]\ndocker save -o xxx.tar image\n# 载入镜像包,恢复为镜像\ndocker load [OPTIONS]\ndocker load < xxx.tar\n\n# 保存容器为 tar 归档文件\ndocker export [OPTIONS] CONTAINER\n# 将容器归档恢复为镜像，会损失元数据 \ndocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]\n```\n\n# 容器数据卷\n\n+ 卷就是目录和文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过union file system提供一些用于持续存储或共享数据的特性。（将docker容器内的数据保存进宿主机的磁盘中）\n+ 卷的设计目的就是数据持久化（类似于redis中的rdb和aof文件），完全独立于容器的生命周期，因此docker不会在容器删除时删除其挂载的容器卷。\n\n## Usage\n\n> usage 1: 直接指定目录\n```bash\ndocker run -it -v 主机目录:容器目录 image\n```\n> usage 2: 未直接指定\n```bash\n# 具名挂载\ndocker run -v 卷名:容器目录 image\n# 匿名挂载\ndocker run -v 容器目录 image\n\n# 查看所有卷\ndocker volume ls\n# 查看某卷信息\ndocker volume inspect 卷名\n\n# 权限\n:ro readonly\n:rw readwrite\n```\n**未指定目录的卷一般在**`/var/lib/docker/volumes/卷名/_data`**目录下**\n> usage 3: Dockerfile\n```dockerfile\nFROM centos\n\nVOLUME [\"\",\"\"]\n\nCMD echo \"sss\"\n```\n\n\n# Dockerfile\n>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n\n## Grammar\n![](./docker学习/dockerfile_cmd.png)\n\n+ RUN 是在 docker build 时运行\n+ CMD 在docker run 时运行\n+ **CMD 命令只有最后一个会生效**\n+ \n```dockerfile\nFROM <image>[:<tag> | @<digest>]\nMAINTAINER <name>\n\n# RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后\n# Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用\n# RUN指令第一种方式为shell方式，使用/bin/sh -c <command>运行脚本，可以在其中使用将脚本分为多行\n# RUN指令第二种方式为exec方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令\nRUN <command> \nRUN [\"executable\",\"param1\",\"param2\"]\n\n# 为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n# CMD 可为 ENTRYPOINT 提供参数列表\nCMD <command>\nCMD [\"\",\"\"]\n\n# 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\nENTRYPOINT <command>\nENTRYPOINT [\"<executeable>\",\"<param1>\",\"<param2>\",...]\n\n\n```\n## Build\n```bash\ndocker build -f -t\n```\n\n---\n\n# UnionFS\n> 联合文件系统（Union File System）\n\n+ **UnionFS的核心就是高效的利用磁盘空间**\n+ **UnionFS 这类文件系统实现的主要功能是把多个目录（处于不同的分区）一起挂载（mount）在一个目录下**\n+ **UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS具有写时复制(copy-on-write)功能，UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中**\n\n\ndocker中使用到了UnionFS，任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。\n\n比如，我们可以把 ubuntu18.04 这个基础镜像的文件放在一个目录 ubuntu18.04/ 下，容器自己额外的程序文件 app_1_bin 放在 app_1/ 目录下。然后，我们把这两个目录挂载到 container_1/ 这个目录下，作为容器 1 看到的文件系统；对于容器 2，就可以把 ubuntu18.04/ 和 app_2/ 两个目录一起挂载到 container_2 的目录下。这样在节点上我们只要保留一份 ubuntu18.04 的文件就可以了。\n[相关](https://www.ngui.cc/el/647713.html?action=onClick)\n![](./docker学习/ufs.png)\n\n```bash\n[root@master ~]# kubectl create deployment nginx --image=nginx\ndeployment.apps/nginx created\n[root@master ~]# kubectl expose deployment nginx --port=80 --type=N                   odePort\n\n```","source":"_posts/docker学习.md","raw":"---\ntitle: docker学习\ntags:\n  - docker\n  - 容器\ncategories:\n  - 云计算\nabbrlink: 7fb3659b\n---\n\n# Profile\n\n>_Docker_ 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口\n\n## Install\n[Docker官网centos平台安装文档](https://docs.docker.com/engine/install/centos/)\n```bash\n# 卸载旧版本\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n# 安装依赖的包\nsudo yum install -y yum-utils\n\n# 配置镜像仓库\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n# 更新软件包\nsudo yum makecache fast\n\n# 安装\nsudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\nsudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io docker-buildx-plugin docker-compose-plugin\n\nyum -y install docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7 containerd.io-1.2.5-3.1.el7 docker-buildx-plugin docker-compose-plugin\n\n# 启动docker\nsudo systemctl start docker\n\n# 测试安装\ndocker version\nsudo docker run hello-world\n\n```\n\n**配置阿里云镜像加速**\n登录->控制台->侧边栏产品与服务->容器镜像服务->镜像加速器\n![](./docker学习/c5f7d7d0c8d5f55c6c637a68a704e9d.png)\n\n## Error\n+  yum软件包更新时，阿里docker源出错\n\t![](./docker学习/2a9868ee4596ff49f1311f20178704f.png)\n\t解决：切换到 `/etc/yum.repos.d` 目录下，将所有 docker 相关的 `repo`全部删掉后，重新添加镜像，命令如上。\n+ 低版本需要 `yum -y install deltarpm`\n+ etc\n\n# Command\n>常用命令 \n\n[官方DOC](https://docs.docker.com/engine/reference/commandline/cli/)\n## Help\n```bash\ndocker version\ndocker info\ndocker [command] --help\n```\n\n## Image\n> iid: image_id\n> cid: container_id\n```bash\n# 查看所有镜像\ndokcer images\n\n# 搜索\ndocker search\n\n# 下载\n# docker pull mysql:latest\ndocker pull image_name[:tag]\n\n# 删除\ndocker rmi -f [iid]\ndocker rmi -f $(docker images -qa) # 删除全部镜像\n\n# 发布(推送)镜像\ndocker tag ubuntu:18.04 username/ubuntu:18.04\ndocker push username/ubuntu:18.04\n\n```\n\n## Container\n```bash\n# 新建容器并启动\ndocker run [option] image\n# 参数\n--name=\"\" 容器名称\n-d        后台方式启动\n-it       交互式启动，并进入容器\n-p        指定容器端口 \n\t-p 主机端口:容器端口\n\t-p 容器端口\n-P        随机指定端口\n-volumes-from 数据卷容器名（同步数据）\n\n# 创建容器\ndocker create image\n\n# 退出容器\nexit # 停止并退出\nCtrl+p+q # 退出\n\n# 进入容器\ndocker exec -it cid # 新命令行\ndocker attach cid # 原命令行\n\n\n# 查看运行的容器\ndocker ps # 正在运行\ndocker ps -a # 正在运行以及运行过的容器\n\n# 删除容器\ndocker rm cid\ndokcer rm -f $(docker ps -aq) # 删除所有容器\n\n# 启动于停止\ndocker start cid # 启动\ndocker restart cid # 重启\ndocker stop cid # 停止\ndocker kill cid # 强制停止\n\n# 查看容器中进程信息\ndocker top cid\n\n# 查看容器元信息\ndocker inspect cid\n\n# 从容器中拷贝到主机\ndocker cp \n\n```\n\n## Log\n```bash\n# 打印日志\ndocker logs -tf --tail [num] cid\n```\n\n## Image Commit\n```bash\n# 提交容器成为镜像\ndocker commit -m=\"msg\" -a=\"author\" cid image[:tag] \n```\n\n\n## Archive\n```bash\n# 保存镜像为 tar 归档文件\ndocker save [OPTIONS] IMAGE [IMAGE...]\ndocker save -o xxx.tar image\n# 载入镜像包,恢复为镜像\ndocker load [OPTIONS]\ndocker load < xxx.tar\n\n# 保存容器为 tar 归档文件\ndocker export [OPTIONS] CONTAINER\n# 将容器归档恢复为镜像，会损失元数据 \ndocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]\n```\n\n# 容器数据卷\n\n+ 卷就是目录和文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过union file system提供一些用于持续存储或共享数据的特性。（将docker容器内的数据保存进宿主机的磁盘中）\n+ 卷的设计目的就是数据持久化（类似于redis中的rdb和aof文件），完全独立于容器的生命周期，因此docker不会在容器删除时删除其挂载的容器卷。\n\n## Usage\n\n> usage 1: 直接指定目录\n```bash\ndocker run -it -v 主机目录:容器目录 image\n```\n> usage 2: 未直接指定\n```bash\n# 具名挂载\ndocker run -v 卷名:容器目录 image\n# 匿名挂载\ndocker run -v 容器目录 image\n\n# 查看所有卷\ndocker volume ls\n# 查看某卷信息\ndocker volume inspect 卷名\n\n# 权限\n:ro readonly\n:rw readwrite\n```\n**未指定目录的卷一般在**`/var/lib/docker/volumes/卷名/_data`**目录下**\n> usage 3: Dockerfile\n```dockerfile\nFROM centos\n\nVOLUME [\"\",\"\"]\n\nCMD echo \"sss\"\n```\n\n\n# Dockerfile\n>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n\n## Grammar\n![](./docker学习/dockerfile_cmd.png)\n\n+ RUN 是在 docker build 时运行\n+ CMD 在docker run 时运行\n+ **CMD 命令只有最后一个会生效**\n+ \n```dockerfile\nFROM <image>[:<tag> | @<digest>]\nMAINTAINER <name>\n\n# RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后\n# Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用\n# RUN指令第一种方式为shell方式，使用/bin/sh -c <command>运行脚本，可以在其中使用将脚本分为多行\n# RUN指令第二种方式为exec方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令\nRUN <command> \nRUN [\"executable\",\"param1\",\"param2\"]\n\n# 为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n# CMD 可为 ENTRYPOINT 提供参数列表\nCMD <command>\nCMD [\"\",\"\"]\n\n# 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\nENTRYPOINT <command>\nENTRYPOINT [\"<executeable>\",\"<param1>\",\"<param2>\",...]\n\n\n```\n## Build\n```bash\ndocker build -f -t\n```\n\n---\n\n# UnionFS\n> 联合文件系统（Union File System）\n\n+ **UnionFS的核心就是高效的利用磁盘空间**\n+ **UnionFS 这类文件系统实现的主要功能是把多个目录（处于不同的分区）一起挂载（mount）在一个目录下**\n+ **UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS具有写时复制(copy-on-write)功能，UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中**\n\n\ndocker中使用到了UnionFS，任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。\n\n比如，我们可以把 ubuntu18.04 这个基础镜像的文件放在一个目录 ubuntu18.04/ 下，容器自己额外的程序文件 app_1_bin 放在 app_1/ 目录下。然后，我们把这两个目录挂载到 container_1/ 这个目录下，作为容器 1 看到的文件系统；对于容器 2，就可以把 ubuntu18.04/ 和 app_2/ 两个目录一起挂载到 container_2 的目录下。这样在节点上我们只要保留一份 ubuntu18.04 的文件就可以了。\n[相关](https://www.ngui.cc/el/647713.html?action=onClick)\n![](./docker学习/ufs.png)\n\n```bash\n[root@master ~]# kubectl create deployment nginx --image=nginx\ndeployment.apps/nginx created\n[root@master ~]# kubectl expose deployment nginx --port=80 --type=N                   odePort\n\n```","slug":"docker学习","published":1,"date":"2023-03-14T10:15:04.071Z","updated":"2023-03-17T03:28:15.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjo000kecwdepqsfz2q","content":"<h1 id=\"Profile\"><a href=\"#Profile\" class=\"headerlink\" title=\"Profile\"></a>Profile</h1><blockquote>\n<p><em>Docker</em> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>\n</blockquote>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p><a href=\"https://docs.docker.com/engine/install/centos/\">Docker官网centos平台安装文档</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载旧版本</span></span><br><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                  docker-client \\</span><br><span class=\"line\">                  docker-client-latest \\</span><br><span class=\"line\">                  docker-common \\</span><br><span class=\"line\">                  docker-latest \\</span><br><span class=\"line\">                  docker-latest-logrotate \\</span><br><span class=\"line\">                  docker-logrotate \\</span><br><span class=\"line\">                  docker-engine</span><br><span class=\"line\"><span class=\"comment\"># 安装依赖的包</span></span><br><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置镜像仓库</span></span><br><span class=\"line\">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新软件包</span></span><br><span class=\"line\">sudo yum makecache fast</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7 containerd.io-1.2.5-3.1.el7 docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker</span></span><br><span class=\"line\">sudo systemctl start docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试安装</span></span><br><span class=\"line\">docker version</span><br><span class=\"line\">sudo docker run hello-world</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>配置阿里云镜像加速</strong><br>登录-&gt;控制台-&gt;侧边栏产品与服务-&gt;容器镜像服务-&gt;镜像加速器<br><img src=\"/post/7fb3659b/c5f7d7d0c8d5f55c6c637a68a704e9d.png\"></p>\n<h2 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h2><ul>\n<li>yum软件包更新时，阿里docker源出错<br>  <img src=\"/post/7fb3659b/2a9868ee4596ff49f1311f20178704f.png\"><br>  解决：切换到 <code>/etc/yum.repos.d</code> 目录下，将所有 docker 相关的 <code>repo</code>全部删掉后，重新添加镜像，命令如上。</li>\n<li>低版本需要 <code>yum -y install deltarpm</code></li>\n<li>etc</li>\n</ul>\n<h1 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h1><blockquote>\n<p>常用命令 </p>\n</blockquote>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/cli/\">官方DOC</a></p>\n<h2 id=\"Help\"><a href=\"#Help\" class=\"headerlink\" title=\"Help\"></a>Help</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br><span class=\"line\">docker info</span><br><span class=\"line\">docker [<span class=\"built_in\">command</span>] --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><blockquote>\n<p>iid: image_id<br>cid: container_id</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有镜像</span></span><br><span class=\"line\">dokcer images</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索</span></span><br><span class=\"line\">docker search</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载</span></span><br><span class=\"line\"><span class=\"comment\"># docker pull mysql:latest</span></span><br><span class=\"line\">docker pull image_name[:tag]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker rmi -f [iid]</span><br><span class=\"line\">docker rmi -f $(docker images -qa) <span class=\"comment\"># 删除全部镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发布(推送)镜像</span></span><br><span class=\"line\">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class=\"line\">docker push username/ubuntu:18.04</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建容器并启动</span></span><br><span class=\"line\">docker run [option] image</span><br><span class=\"line\"><span class=\"comment\"># 参数</span></span><br><span class=\"line\">--name=<span class=\"string\">&quot;&quot;</span> 容器名称</span><br><span class=\"line\">-d        后台方式启动</span><br><span class=\"line\">-it       交互式启动，并进入容器</span><br><span class=\"line\">-p        指定容器端口 </span><br><span class=\"line\">\t-p 主机端口:容器端口</span><br><span class=\"line\">\t-p 容器端口</span><br><span class=\"line\">-P        随机指定端口</span><br><span class=\"line\">-volumes-from 数据卷容器名（同步数据）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建容器</span></span><br><span class=\"line\">docker create image</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出容器</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\"># 停止并退出</span></span><br><span class=\"line\">Ctrl+p+q <span class=\"comment\"># 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it cid <span class=\"comment\"># 新命令行</span></span><br><span class=\"line\">docker attach cid <span class=\"comment\"># 原命令行</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看运行的容器</span></span><br><span class=\"line\">docker ps <span class=\"comment\"># 正在运行</span></span><br><span class=\"line\">docker ps -a <span class=\"comment\"># 正在运行以及运行过的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> cid</span><br><span class=\"line\">dokcer <span class=\"built_in\">rm</span> -f $(docker ps -aq) <span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动于停止</span></span><br><span class=\"line\">docker start cid <span class=\"comment\"># 启动</span></span><br><span class=\"line\">docker restart cid <span class=\"comment\"># 重启</span></span><br><span class=\"line\">docker stop cid <span class=\"comment\"># 停止</span></span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> cid <span class=\"comment\"># 强制停止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器中进程信息</span></span><br><span class=\"line\">docker top cid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器元信息</span></span><br><span class=\"line\">docker inspect cid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从容器中拷贝到主机</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"Log\"></a>Log</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印日志</span></span><br><span class=\"line\">docker logs -tf --<span class=\"built_in\">tail</span> [num] cid</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Image-Commit\"><a href=\"#Image-Commit\" class=\"headerlink\" title=\"Image Commit\"></a>Image Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 提交容器成为镜像</span></span><br><span class=\"line\">docker commit -m=<span class=\"string\">&quot;msg&quot;</span> -a=<span class=\"string\">&quot;author&quot;</span> cid image[:tag] </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存镜像为 tar 归档文件</span></span><br><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\">docker save -o xxx.tar image</span><br><span class=\"line\"><span class=\"comment\"># 载入镜像包,恢复为镜像</span></span><br><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">docker load &lt; xxx.tar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存容器为 tar 归档文件</span></span><br><span class=\"line\">docker <span class=\"built_in\">export</span> [OPTIONS] CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 将容器归档恢复为镜像，会损失元数据 </span></span><br><span class=\"line\">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h1><ul>\n<li>卷就是目录和文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过union file system提供一些用于持续存储或共享数据的特性。（将docker容器内的数据保存进宿主机的磁盘中）</li>\n<li>卷的设计目的就是数据持久化（类似于redis中的rdb和aof文件），完全独立于容器的生命周期，因此docker不会在容器删除时删除其挂载的容器卷。</li>\n</ul>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p>usage 1: 直接指定目录</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v 主机目录:容器目录 image</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>usage 2: 未直接指定</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 具名挂载</span></span><br><span class=\"line\">docker run -v 卷名:容器目录 image</span><br><span class=\"line\"><span class=\"comment\"># 匿名挂载</span></span><br><span class=\"line\">docker run -v 容器目录 image</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看某卷信息</span></span><br><span class=\"line\">docker volume inspect 卷名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 权限</span></span><br><span class=\"line\">:ro <span class=\"built_in\">readonly</span></span><br><span class=\"line\">:rw readwrite</span><br></pre></td></tr></table></figure>\n<p><strong>未指定目录的卷一般在</strong><code>/var/lib/docker/volumes/卷名/_data</code><strong>目录下</strong></p>\n<blockquote>\n<p>usage 3: Dockerfile</p>\n</blockquote>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sss&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><blockquote>\n<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>\n</blockquote>\n<h2 id=\"Grammar\"><a href=\"#Grammar\" class=\"headerlink\" title=\"Grammar\"></a>Grammar</h2><p><img src=\"/post/7fb3659b/dockerfile_cmd.png\"></p>\n<ul>\n<li>RUN 是在 docker build 时运行</li>\n<li>CMD 在docker run 时运行</li>\n<li><strong>CMD 命令只有最后一个会生效</strong></li>\n<li><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;[:&lt;tag&gt; | @&lt;digest&gt;]</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后</span></span><br><span class=\"line\"><span class=\"comment\"># Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用</span></span><br><span class=\"line\"><span class=\"comment\"># RUN指令第一种方式为shell方式，使用/bin/sh -c &lt;command&gt;运行脚本，可以在其中使用将脚本分为多行</span></span><br><span class=\"line\"><span class=\"comment\"># RUN指令第二种方式为exec方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt; </span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>,<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 可为 ENTRYPOINT 提供参数列表</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&lt;executeable&gt;&quot;</span>,<span class=\"string\">&quot;&lt;param1&gt;&quot;</span>,<span class=\"string\">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f -t</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h1 id=\"UnionFS\"><a href=\"#UnionFS\" class=\"headerlink\" title=\"UnionFS\"></a>UnionFS</h1><blockquote>\n<p>联合文件系统（Union File System）</p>\n</blockquote>\n<ul>\n<li><strong>UnionFS的核心就是高效的利用磁盘空间</strong></li>\n<li><strong>UnionFS 这类文件系统实现的主要功能是把多个目录（处于不同的分区）一起挂载（mount）在一个目录下</strong></li>\n<li><strong>UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS具有写时复制(copy-on-write)功能，UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中</strong></li>\n</ul>\n<p>docker中使用到了UnionFS，任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。</p>\n<p>比如，我们可以把 ubuntu18.04 这个基础镜像的文件放在一个目录 ubuntu18.04/ 下，容器自己额外的程序文件 app_1_bin 放在 app_1/ 目录下。然后，我们把这两个目录挂载到 container_1/ 这个目录下，作为容器 1 看到的文件系统；对于容器 2，就可以把 ubuntu18.04/ 和 app_2/ 两个目录一起挂载到 container_2 的目录下。这样在节点上我们只要保留一份 ubuntu18.04 的文件就可以了。<br><a href=\"https://www.ngui.cc/el/647713.html?action=onClick\">相关</a><br><img src=\"/post/7fb3659b/ufs.png\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]<span class=\"comment\"># kubectl create deployment nginx --image=nginx</span></span><br><span class=\"line\">deployment.apps/nginx created</span><br><span class=\"line\">[root@master ~]<span class=\"comment\"># kubectl expose deployment nginx --port=80 --type=N                   odePort</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/c3.png","excerpt":"","more":"<h1 id=\"Profile\"><a href=\"#Profile\" class=\"headerlink\" title=\"Profile\"></a>Profile</h1><blockquote>\n<p><em>Docker</em> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>\n</blockquote>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p><a href=\"https://docs.docker.com/engine/install/centos/\">Docker官网centos平台安装文档</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载旧版本</span></span><br><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                  docker-client \\</span><br><span class=\"line\">                  docker-client-latest \\</span><br><span class=\"line\">                  docker-common \\</span><br><span class=\"line\">                  docker-latest \\</span><br><span class=\"line\">                  docker-latest-logrotate \\</span><br><span class=\"line\">                  docker-logrotate \\</span><br><span class=\"line\">                  docker-engine</span><br><span class=\"line\"><span class=\"comment\"># 安装依赖的包</span></span><br><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置镜像仓库</span></span><br><span class=\"line\">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新软件包</span></span><br><span class=\"line\">sudo yum makecache fast</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install docker-ce-19.03.8-3.el7 docker-ce-cli-19.03.8-3.el7 containerd.io-1.2.5-3.1.el7 docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker</span></span><br><span class=\"line\">sudo systemctl start docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试安装</span></span><br><span class=\"line\">docker version</span><br><span class=\"line\">sudo docker run hello-world</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>配置阿里云镜像加速</strong><br>登录-&gt;控制台-&gt;侧边栏产品与服务-&gt;容器镜像服务-&gt;镜像加速器<br><img src=\"/post/7fb3659b/c5f7d7d0c8d5f55c6c637a68a704e9d.png\"></p>\n<h2 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h2><ul>\n<li>yum软件包更新时，阿里docker源出错<br>  <img src=\"/post/7fb3659b/2a9868ee4596ff49f1311f20178704f.png\"><br>  解决：切换到 <code>/etc/yum.repos.d</code> 目录下，将所有 docker 相关的 <code>repo</code>全部删掉后，重新添加镜像，命令如上。</li>\n<li>低版本需要 <code>yum -y install deltarpm</code></li>\n<li>etc</li>\n</ul>\n<h1 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h1><blockquote>\n<p>常用命令 </p>\n</blockquote>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/cli/\">官方DOC</a></p>\n<h2 id=\"Help\"><a href=\"#Help\" class=\"headerlink\" title=\"Help\"></a>Help</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br><span class=\"line\">docker info</span><br><span class=\"line\">docker [<span class=\"built_in\">command</span>] --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><blockquote>\n<p>iid: image_id<br>cid: container_id</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看所有镜像</span></span><br><span class=\"line\">dokcer images</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 搜索</span></span><br><span class=\"line\">docker search</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载</span></span><br><span class=\"line\"><span class=\"comment\"># docker pull mysql:latest</span></span><br><span class=\"line\">docker pull image_name[:tag]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">docker rmi -f [iid]</span><br><span class=\"line\">docker rmi -f $(docker images -qa) <span class=\"comment\"># 删除全部镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发布(推送)镜像</span></span><br><span class=\"line\">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class=\"line\">docker push username/ubuntu:18.04</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建容器并启动</span></span><br><span class=\"line\">docker run [option] image</span><br><span class=\"line\"><span class=\"comment\"># 参数</span></span><br><span class=\"line\">--name=<span class=\"string\">&quot;&quot;</span> 容器名称</span><br><span class=\"line\">-d        后台方式启动</span><br><span class=\"line\">-it       交互式启动，并进入容器</span><br><span class=\"line\">-p        指定容器端口 </span><br><span class=\"line\">\t-p 主机端口:容器端口</span><br><span class=\"line\">\t-p 容器端口</span><br><span class=\"line\">-P        随机指定端口</span><br><span class=\"line\">-volumes-from 数据卷容器名（同步数据）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建容器</span></span><br><span class=\"line\">docker create image</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出容器</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> <span class=\"comment\"># 停止并退出</span></span><br><span class=\"line\">Ctrl+p+q <span class=\"comment\"># 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it cid <span class=\"comment\"># 新命令行</span></span><br><span class=\"line\">docker attach cid <span class=\"comment\"># 原命令行</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看运行的容器</span></span><br><span class=\"line\">docker ps <span class=\"comment\"># 正在运行</span></span><br><span class=\"line\">docker ps -a <span class=\"comment\"># 正在运行以及运行过的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> cid</span><br><span class=\"line\">dokcer <span class=\"built_in\">rm</span> -f $(docker ps -aq) <span class=\"comment\"># 删除所有容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动于停止</span></span><br><span class=\"line\">docker start cid <span class=\"comment\"># 启动</span></span><br><span class=\"line\">docker restart cid <span class=\"comment\"># 重启</span></span><br><span class=\"line\">docker stop cid <span class=\"comment\"># 停止</span></span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> cid <span class=\"comment\"># 强制停止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器中进程信息</span></span><br><span class=\"line\">docker top cid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看容器元信息</span></span><br><span class=\"line\">docker inspect cid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从容器中拷贝到主机</span></span><br><span class=\"line\">docker <span class=\"built_in\">cp</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"Log\"></a>Log</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打印日志</span></span><br><span class=\"line\">docker logs -tf --<span class=\"built_in\">tail</span> [num] cid</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Image-Commit\"><a href=\"#Image-Commit\" class=\"headerlink\" title=\"Image Commit\"></a>Image Commit</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 提交容器成为镜像</span></span><br><span class=\"line\">docker commit -m=<span class=\"string\">&quot;msg&quot;</span> -a=<span class=\"string\">&quot;author&quot;</span> cid image[:tag] </span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Archive\"><a href=\"#Archive\" class=\"headerlink\" title=\"Archive\"></a>Archive</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存镜像为 tar 归档文件</span></span><br><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\">docker save -o xxx.tar image</span><br><span class=\"line\"><span class=\"comment\"># 载入镜像包,恢复为镜像</span></span><br><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">docker load &lt; xxx.tar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 保存容器为 tar 归档文件</span></span><br><span class=\"line\">docker <span class=\"built_in\">export</span> [OPTIONS] CONTAINER</span><br><span class=\"line\"><span class=\"comment\"># 将容器归档恢复为镜像，会损失元数据 </span></span><br><span class=\"line\">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h1><ul>\n<li>卷就是目录和文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过union file system提供一些用于持续存储或共享数据的特性。（将docker容器内的数据保存进宿主机的磁盘中）</li>\n<li>卷的设计目的就是数据持久化（类似于redis中的rdb和aof文件），完全独立于容器的生命周期，因此docker不会在容器删除时删除其挂载的容器卷。</li>\n</ul>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><blockquote>\n<p>usage 1: 直接指定目录</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v 主机目录:容器目录 image</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>usage 2: 未直接指定</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 具名挂载</span></span><br><span class=\"line\">docker run -v 卷名:容器目录 image</span><br><span class=\"line\"><span class=\"comment\"># 匿名挂载</span></span><br><span class=\"line\">docker run -v 容器目录 image</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有卷</span></span><br><span class=\"line\">docker volume <span class=\"built_in\">ls</span></span><br><span class=\"line\"><span class=\"comment\"># 查看某卷信息</span></span><br><span class=\"line\">docker volume inspect 卷名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 权限</span></span><br><span class=\"line\">:ro <span class=\"built_in\">readonly</span></span><br><span class=\"line\">:rw readwrite</span><br></pre></td></tr></table></figure>\n<p><strong>未指定目录的卷一般在</strong><code>/var/lib/docker/volumes/卷名/_data</code><strong>目录下</strong></p>\n<blockquote>\n<p>usage 3: Dockerfile</p>\n</blockquote>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;sss&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><blockquote>\n<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>\n</blockquote>\n<h2 id=\"Grammar\"><a href=\"#Grammar\" class=\"headerlink\" title=\"Grammar\"></a>Grammar</h2><p><img src=\"/post/7fb3659b/dockerfile_cmd.png\"></p>\n<ul>\n<li>RUN 是在 docker build 时运行</li>\n<li>CMD 在docker run 时运行</li>\n<li><strong>CMD 命令只有最后一个会生效</strong></li>\n<li><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> &lt;image&gt;[:&lt;tag&gt; | @&lt;digest&gt;]</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RUN指令会生成容器，在容器中执行脚本，容器使用当前镜像，脚本指令完成后</span></span><br><span class=\"line\"><span class=\"comment\"># Docker Daemon会将该容器提交为一个中间镜像，供后面的指令使用</span></span><br><span class=\"line\"><span class=\"comment\"># RUN指令第一种方式为shell方式，使用/bin/sh -c &lt;command&gt;运行脚本，可以在其中使用将脚本分为多行</span></span><br><span class=\"line\"><span class=\"comment\"># RUN指令第二种方式为exec方式，镜像中没有/bin/sh或者要使用其他shell时使用该方式，其不会调用shell命令</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt; </span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>,<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</span></span><br><span class=\"line\"><span class=\"comment\"># CMD 可为 ENTRYPOINT 提供参数列表</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> &lt;<span class=\"built_in\">command</span>&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;&lt;executeable&gt;&quot;</span>,<span class=\"string\">&quot;&lt;param1&gt;&quot;</span>,<span class=\"string\">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f -t</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h1 id=\"UnionFS\"><a href=\"#UnionFS\" class=\"headerlink\" title=\"UnionFS\"></a>UnionFS</h1><blockquote>\n<p>联合文件系统（Union File System）</p>\n</blockquote>\n<ul>\n<li><strong>UnionFS的核心就是高效的利用磁盘空间</strong></li>\n<li><strong>UnionFS 这类文件系统实现的主要功能是把多个目录（处于不同的分区）一起挂载（mount）在一个目录下</strong></li>\n<li><strong>UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS具有写时复制(copy-on-write)功能，UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中</strong></li>\n</ul>\n<p>docker中使用到了UnionFS，任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。</p>\n<p>比如，我们可以把 ubuntu18.04 这个基础镜像的文件放在一个目录 ubuntu18.04/ 下，容器自己额外的程序文件 app_1_bin 放在 app_1/ 目录下。然后，我们把这两个目录挂载到 container_1/ 这个目录下，作为容器 1 看到的文件系统；对于容器 2，就可以把 ubuntu18.04/ 和 app_2/ 两个目录一起挂载到 container_2 的目录下。这样在节点上我们只要保留一份 ubuntu18.04 的文件就可以了。<br><a href=\"https://www.ngui.cc/el/647713.html?action=onClick\">相关</a><br><img src=\"/post/7fb3659b/ufs.png\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master ~]<span class=\"comment\"># kubectl create deployment nginx --image=nginx</span></span><br><span class=\"line\">deployment.apps/nginx created</span><br><span class=\"line\">[root@master ~]<span class=\"comment\"># kubectl expose deployment nginx --port=80 --type=N                   odePort</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"conda安装jupyter","abbrlink":"bdcd1c7d","date":"2022-09-21T07:26:19.000Z","_content":"\n# Conda 安装 Jupyter\n\n\n\n>   请确保已经配置好了conda的环境\n\n\n\n## Install\n\n```bash\n# conda新建一个环境\n$ conda create -n jupyter -y\n# 激活jupyter环境\n$ conda activate jupyter \n# 安装jupyter\n$ conda install jupyter -y\n```\n\n## Config\n\n```bash\n$ jupyter notebook --generate-config\n# 此处会显示自动生成的配置文件的位置\n# 默认在C:/user/xxx/.jupyter/\n```\n\n在该终端打开python，执行以下代码：\n\n```python\nfrom notebook.auth import passwd\npasswd()\n# 输入密码，再次输入\n# 此处会显示生成的密码串 'xxxxxxxxxxxxx'\nexit()\n```\n\n打开配置文件\n\n```python\n# 插入下面的内容\nc.NotebookApp.ip='*'\nc.NotebookApp.password=u'argon2:$argon2id$v=19$m=10240,t=10,p=8$OBOjmJ9BxdyrtuY4acfI9g$iwU6g+wQHTNeJJQ0DAjJXjj6azUpJ8oDFvjKxnqxfWw' # 上方生成的密码串前加上子母u\nc.NotebookApp.open_browser=False\nc.NotebookApp.port=8888\n```\n\n## Run\n\n```bash\n# 激活你所安装jupyter的conda环境后\n$ jupyter notebook\n```\n\n\n\n## Pycharm 中使用 Jupyter\n\n+   新建jupyter notebook页面\n+   配置jupyter服务器地址， 输入密码\n+   按上述启动jupyter\n\n![](conda安装jupyter/1.png)\n\n","source":"_posts/conda安装jupyter.md","raw":"---\ntitle: conda安装jupyter\ntags:\n  - jupyter notebook\ncategories:\n  - DL\nabbrlink: bdcd1c7d\ndate: 2022-09-21 15:26:19\n---\n\n# Conda 安装 Jupyter\n\n\n\n>   请确保已经配置好了conda的环境\n\n\n\n## Install\n\n```bash\n# conda新建一个环境\n$ conda create -n jupyter -y\n# 激活jupyter环境\n$ conda activate jupyter \n# 安装jupyter\n$ conda install jupyter -y\n```\n\n## Config\n\n```bash\n$ jupyter notebook --generate-config\n# 此处会显示自动生成的配置文件的位置\n# 默认在C:/user/xxx/.jupyter/\n```\n\n在该终端打开python，执行以下代码：\n\n```python\nfrom notebook.auth import passwd\npasswd()\n# 输入密码，再次输入\n# 此处会显示生成的密码串 'xxxxxxxxxxxxx'\nexit()\n```\n\n打开配置文件\n\n```python\n# 插入下面的内容\nc.NotebookApp.ip='*'\nc.NotebookApp.password=u'argon2:$argon2id$v=19$m=10240,t=10,p=8$OBOjmJ9BxdyrtuY4acfI9g$iwU6g+wQHTNeJJQ0DAjJXjj6azUpJ8oDFvjKxnqxfWw' # 上方生成的密码串前加上子母u\nc.NotebookApp.open_browser=False\nc.NotebookApp.port=8888\n```\n\n## Run\n\n```bash\n# 激活你所安装jupyter的conda环境后\n$ jupyter notebook\n```\n\n\n\n## Pycharm 中使用 Jupyter\n\n+   新建jupyter notebook页面\n+   配置jupyter服务器地址， 输入密码\n+   按上述启动jupyter\n\n![](conda安装jupyter/1.png)\n\n","slug":"conda安装jupyter","published":1,"updated":"2022-09-21T07:46:26.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xjq000necwdd7ep8exa","content":"<h1 id=\"Conda-安装-Jupyter\"><a href=\"#Conda-安装-Jupyter\" class=\"headerlink\" title=\"Conda 安装 Jupyter\"></a>Conda 安装 Jupyter</h1><blockquote>\n<p>  请确保已经配置好了conda的环境</p>\n</blockquote>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># conda新建一个环境</span></span><br><span class=\"line\">$ conda create -n jupyter -y</span><br><span class=\"line\"><span class=\"comment\"># 激活jupyter环境</span></span><br><span class=\"line\">$ conda activate jupyter </span><br><span class=\"line\"><span class=\"comment\"># 安装jupyter</span></span><br><span class=\"line\">$ conda install jupyter -y</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jupyter notebook --generate-config</span><br><span class=\"line\"><span class=\"comment\"># 此处会显示自动生成的配置文件的位置</span></span><br><span class=\"line\"><span class=\"comment\"># 默认在C:/user/xxx/.jupyter/</span></span><br></pre></td></tr></table></figure>\n\n<p>在该终端打开python，执行以下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> notebook.auth <span class=\"keyword\">import</span> passwd</span><br><span class=\"line\">passwd()</span><br><span class=\"line\"><span class=\"comment\"># 输入密码，再次输入</span></span><br><span class=\"line\"><span class=\"comment\"># 此处会显示生成的密码串 &#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class=\"line\">exit()</span><br></pre></td></tr></table></figure>\n\n<p>打开配置文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 插入下面的内容</span></span><br><span class=\"line\">c.NotebookApp.ip=<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">c.NotebookApp.password=<span class=\"string\">u&#x27;argon2:$argon2id$v=19$m=10240,t=10,p=8$OBOjmJ9BxdyrtuY4acfI9g$iwU6g+wQHTNeJJQ0DAjJXjj6azUpJ8oDFvjKxnqxfWw&#x27;</span> <span class=\"comment\"># 上方生成的密码串前加上子母u</span></span><br><span class=\"line\">c.NotebookApp.open_browser=<span class=\"literal\">False</span></span><br><span class=\"line\">c.NotebookApp.port=<span class=\"number\">8888</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活你所安装jupyter的conda环境后</span></span><br><span class=\"line\">$ jupyter notebook</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Pycharm-中使用-Jupyter\"><a href=\"#Pycharm-中使用-Jupyter\" class=\"headerlink\" title=\"Pycharm 中使用 Jupyter\"></a>Pycharm 中使用 Jupyter</h2><ul>\n<li>  新建jupyter notebook页面</li>\n<li>  配置jupyter服务器地址， 输入密码</li>\n<li>  按上述启动jupyter</li>\n</ul>\n<p><img src=\"/post/bdcd1c7d/1.png\"></p>\n","site":{"data":{}},"cover":"/img/c1.jpg","excerpt":"","more":"<h1 id=\"Conda-安装-Jupyter\"><a href=\"#Conda-安装-Jupyter\" class=\"headerlink\" title=\"Conda 安装 Jupyter\"></a>Conda 安装 Jupyter</h1><blockquote>\n<p>  请确保已经配置好了conda的环境</p>\n</blockquote>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># conda新建一个环境</span></span><br><span class=\"line\">$ conda create -n jupyter -y</span><br><span class=\"line\"><span class=\"comment\"># 激活jupyter环境</span></span><br><span class=\"line\">$ conda activate jupyter </span><br><span class=\"line\"><span class=\"comment\"># 安装jupyter</span></span><br><span class=\"line\">$ conda install jupyter -y</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jupyter notebook --generate-config</span><br><span class=\"line\"><span class=\"comment\"># 此处会显示自动生成的配置文件的位置</span></span><br><span class=\"line\"><span class=\"comment\"># 默认在C:/user/xxx/.jupyter/</span></span><br></pre></td></tr></table></figure>\n\n<p>在该终端打开python，执行以下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> notebook.auth <span class=\"keyword\">import</span> passwd</span><br><span class=\"line\">passwd()</span><br><span class=\"line\"><span class=\"comment\"># 输入密码，再次输入</span></span><br><span class=\"line\"><span class=\"comment\"># 此处会显示生成的密码串 &#x27;xxxxxxxxxxxxx&#x27;</span></span><br><span class=\"line\">exit()</span><br></pre></td></tr></table></figure>\n\n<p>打开配置文件</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 插入下面的内容</span></span><br><span class=\"line\">c.NotebookApp.ip=<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">c.NotebookApp.password=<span class=\"string\">u&#x27;argon2:$argon2id$v=19$m=10240,t=10,p=8$OBOjmJ9BxdyrtuY4acfI9g$iwU6g+wQHTNeJJQ0DAjJXjj6azUpJ8oDFvjKxnqxfWw&#x27;</span> <span class=\"comment\"># 上方生成的密码串前加上子母u</span></span><br><span class=\"line\">c.NotebookApp.open_browser=<span class=\"literal\">False</span></span><br><span class=\"line\">c.NotebookApp.port=<span class=\"number\">8888</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Run\"><a href=\"#Run\" class=\"headerlink\" title=\"Run\"></a>Run</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活你所安装jupyter的conda环境后</span></span><br><span class=\"line\">$ jupyter notebook</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Pycharm-中使用-Jupyter\"><a href=\"#Pycharm-中使用-Jupyter\" class=\"headerlink\" title=\"Pycharm 中使用 Jupyter\"></a>Pycharm 中使用 Jupyter</h2><ul>\n<li>  新建jupyter notebook页面</li>\n<li>  配置jupyter服务器地址， 输入密码</li>\n<li>  按上述启动jupyter</li>\n</ul>\n<p><img src=\"/post/bdcd1c7d/1.png\"></p>\n"},{"title":"Hello World","abbrlink":"4a17b156","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 4a17b156\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-09-07T13:50:14.377Z","updated":"2022-09-07T14:32:14.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xk1002cecwd20siarky","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"cover":"/img/c5.jpg","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"带状疱疹病史","abbrlink":"9c057035","_content":"\n>_带状疱疹_是由水痘- _带状疱疹_病毒引起,以沿单侧周围神经分布的簇集性小水疱为特征的常见皮肤病,常伴有明显神经痛。当抵抗力低下或劳累、感染、感冒时，病毒可再次生长繁殖，并沿神经纤维移至皮肤，使受侵犯的神经和皮肤产生强烈的炎症。\n\n# 前情提要\n\n3月26日突发感冒发烧（怀疑为甲流），历时三天，退烧后身体较为虚弱，喉咙长时间有痰；后续一段时期头晕，精神不佳，抵抗力严重下降。\n\n# 正题\n\n## 4月6日晚\n突然发现面部右侧耳多附近淋巴结肿大（当时误以为是`急性腮腺炎`），右侧眼睑、额头出现微凸起的红斑，按压有痛感，因为耳部的症状更加明显和剧烈，所以对于凸起的红斑不够重视，以为就是普通的上火长疮，涂抹了一些金霉素眼膏(抗生素)。\n少量服用了阿莫西林。\n\n## 4月7日\n眼睑处的红斑中央开始出现细微小水泡，夜晚出现了右侧面部乃至头部的神经性跳痛、刺痛，导致晚上完全没有睡好，淋巴结肿大无变化，打算第二天去医院看一下。\n少量服用了阿莫西林。\n\n## 4月8日\n早晨发现眼睑处水泡变大，已明显可见。\n先去了校医务室，当班校医无法确认，只是说有点像腮腺炎，因为怕有传染性，建议我去医院检查。\n校医先是将我转诊至北京积水潭医院昌平分院，到院后无号可挂，校医建议我返回；回途中发现昌平区医院有第二天的全科医学科室的号可以挂，于是返校后让校医将我转诊至昌平区医院。\n是日晚，右眼神经性刺痛难耐。\n\n## 4月9日\n+ 上午9:30，先于全科医学门诊处就诊，坐诊医生怀疑面部右侧的皮肤症状为`带状疱疹`并由该病毒导致右侧耳部多个淋巴结肿大，应该不为腮腺炎，建议我转诊至皮肤科就诊；\n+ 上午10:30，于皮肤科就诊，医生一眼断定为带状疱疹，并准确描述出了我前几日的面部神经痛现象，至此基本可以确定病症所在；\n+ 后半日开始正式的针对带状疱疹的治疗，夜晚仍头部神经痛，吃了止痛药。\n```mermaid\ngraph LR\n带状疱疹 --> 病毒感染\n病毒感染 --> 淋巴结肿大\n```\n\n### 药物处方如下\n\n- [x] 泛昔洛韦\n- [x] 甲钴胺\n- [x] 龙血竭片\n- [x] 阿昔洛韦乳膏\n- [x] 加巴喷丁胶囊\n\n## 4月10日\n前一晚没睡好，头疼欲裂，疱疹陆续开始加重，眼睑处又多冒出了几个水泡。\n夜晚，畏寒低烧，体温升至37.5左右，吃了布洛芬一方面退烧，一方面抑制头疼。\n\n## 4月11日\n早晨，发现耳垂下的淋巴结变小了，眼睑处和额头处疱疹颜色变浅(深?)，红晕缩小，似有恢复的迹象。\n\n## 4月12日\n耳部附近淋巴结有明显变小，压痛感减轻，面部疱疹颜色进一步变深，偶尔神经痛刺痛；\n感觉阿昔洛韦乳膏涂抹过多，皮肤表面难以清洗，减少涂药量为宜。\n\n## 4月13日\n耳部附近淋巴结进一步变小，压痛感几乎消失，面部疱疹颜色进一步变深，偶尔神经刺痛；","source":"_posts/带状疱疹病史.md","raw":"---\ntitle: 带状疱疹病史\ntags:\n  - life\ncategories:\n  - life\nabbrlink: 9c057035\n---\n\n>_带状疱疹_是由水痘- _带状疱疹_病毒引起,以沿单侧周围神经分布的簇集性小水疱为特征的常见皮肤病,常伴有明显神经痛。当抵抗力低下或劳累、感染、感冒时，病毒可再次生长繁殖，并沿神经纤维移至皮肤，使受侵犯的神经和皮肤产生强烈的炎症。\n\n# 前情提要\n\n3月26日突发感冒发烧（怀疑为甲流），历时三天，退烧后身体较为虚弱，喉咙长时间有痰；后续一段时期头晕，精神不佳，抵抗力严重下降。\n\n# 正题\n\n## 4月6日晚\n突然发现面部右侧耳多附近淋巴结肿大（当时误以为是`急性腮腺炎`），右侧眼睑、额头出现微凸起的红斑，按压有痛感，因为耳部的症状更加明显和剧烈，所以对于凸起的红斑不够重视，以为就是普通的上火长疮，涂抹了一些金霉素眼膏(抗生素)。\n少量服用了阿莫西林。\n\n## 4月7日\n眼睑处的红斑中央开始出现细微小水泡，夜晚出现了右侧面部乃至头部的神经性跳痛、刺痛，导致晚上完全没有睡好，淋巴结肿大无变化，打算第二天去医院看一下。\n少量服用了阿莫西林。\n\n## 4月8日\n早晨发现眼睑处水泡变大，已明显可见。\n先去了校医务室，当班校医无法确认，只是说有点像腮腺炎，因为怕有传染性，建议我去医院检查。\n校医先是将我转诊至北京积水潭医院昌平分院，到院后无号可挂，校医建议我返回；回途中发现昌平区医院有第二天的全科医学科室的号可以挂，于是返校后让校医将我转诊至昌平区医院。\n是日晚，右眼神经性刺痛难耐。\n\n## 4月9日\n+ 上午9:30，先于全科医学门诊处就诊，坐诊医生怀疑面部右侧的皮肤症状为`带状疱疹`并由该病毒导致右侧耳部多个淋巴结肿大，应该不为腮腺炎，建议我转诊至皮肤科就诊；\n+ 上午10:30，于皮肤科就诊，医生一眼断定为带状疱疹，并准确描述出了我前几日的面部神经痛现象，至此基本可以确定病症所在；\n+ 后半日开始正式的针对带状疱疹的治疗，夜晚仍头部神经痛，吃了止痛药。\n```mermaid\ngraph LR\n带状疱疹 --> 病毒感染\n病毒感染 --> 淋巴结肿大\n```\n\n### 药物处方如下\n\n- [x] 泛昔洛韦\n- [x] 甲钴胺\n- [x] 龙血竭片\n- [x] 阿昔洛韦乳膏\n- [x] 加巴喷丁胶囊\n\n## 4月10日\n前一晚没睡好，头疼欲裂，疱疹陆续开始加重，眼睑处又多冒出了几个水泡。\n夜晚，畏寒低烧，体温升至37.5左右，吃了布洛芬一方面退烧，一方面抑制头疼。\n\n## 4月11日\n早晨，发现耳垂下的淋巴结变小了，眼睑处和额头处疱疹颜色变浅(深?)，红晕缩小，似有恢复的迹象。\n\n## 4月12日\n耳部附近淋巴结有明显变小，压痛感减轻，面部疱疹颜色进一步变深，偶尔神经痛刺痛；\n感觉阿昔洛韦乳膏涂抹过多，皮肤表面难以清洗，减少涂药量为宜。\n\n## 4月13日\n耳部附近淋巴结进一步变小，压痛感几乎消失，面部疱疹颜色进一步变深，偶尔神经刺痛；","slug":"带状疱疹病史","published":1,"date":"2023-04-10T10:14:32.521Z","updated":"2023-04-14T08:37:34.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xk2002decwd7o0q9g77","content":"<blockquote>\n<p>_带状疱疹_是由水痘- _带状疱疹_病毒引起,以沿单侧周围神经分布的簇集性小水疱为特征的常见皮肤病,常伴有明显神经痛。当抵抗力低下或劳累、感染、感冒时，病毒可再次生长繁殖，并沿神经纤维移至皮肤，使受侵犯的神经和皮肤产生强烈的炎症。</p>\n</blockquote>\n<h1 id=\"前情提要\"><a href=\"#前情提要\" class=\"headerlink\" title=\"前情提要\"></a>前情提要</h1><p>3月26日突发感冒发烧（怀疑为甲流），历时三天，退烧后身体较为虚弱，喉咙长时间有痰；后续一段时期头晕，精神不佳，抵抗力严重下降。</p>\n<h1 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h1><h2 id=\"4月6日晚\"><a href=\"#4月6日晚\" class=\"headerlink\" title=\"4月6日晚\"></a>4月6日晚</h2><p>突然发现面部右侧耳多附近淋巴结肿大（当时误以为是<code>急性腮腺炎</code>），右侧眼睑、额头出现微凸起的红斑，按压有痛感，因为耳部的症状更加明显和剧烈，所以对于凸起的红斑不够重视，以为就是普通的上火长疮，涂抹了一些金霉素眼膏(抗生素)。<br>少量服用了阿莫西林。</p>\n<h2 id=\"4月7日\"><a href=\"#4月7日\" class=\"headerlink\" title=\"4月7日\"></a>4月7日</h2><p>眼睑处的红斑中央开始出现细微小水泡，夜晚出现了右侧面部乃至头部的神经性跳痛、刺痛，导致晚上完全没有睡好，淋巴结肿大无变化，打算第二天去医院看一下。<br>少量服用了阿莫西林。</p>\n<h2 id=\"4月8日\"><a href=\"#4月8日\" class=\"headerlink\" title=\"4月8日\"></a>4月8日</h2><p>早晨发现眼睑处水泡变大，已明显可见。<br>先去了校医务室，当班校医无法确认，只是说有点像腮腺炎，因为怕有传染性，建议我去医院检查。<br>校医先是将我转诊至北京积水潭医院昌平分院，到院后无号可挂，校医建议我返回；回途中发现昌平区医院有第二天的全科医学科室的号可以挂，于是返校后让校医将我转诊至昌平区医院。<br>是日晚，右眼神经性刺痛难耐。</p>\n<h2 id=\"4月9日\"><a href=\"#4月9日\" class=\"headerlink\" title=\"4月9日\"></a>4月9日</h2><ul>\n<li>上午9:30，先于全科医学门诊处就诊，坐诊医生怀疑面部右侧的皮肤症状为<code>带状疱疹</code>并由该病毒导致右侧耳部多个淋巴结肿大，应该不为腮腺炎，建议我转诊至皮肤科就诊；</li>\n<li>上午10:30，于皮肤科就诊，医生一眼断定为带状疱疹，并准确描述出了我前几日的面部神经痛现象，至此基本可以确定病症所在；</li>\n<li>后半日开始正式的针对带状疱疹的治疗，夜晚仍头部神经痛，吃了止痛药。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">带状疱疹 --&gt; 病毒感染</span><br><span class=\"line\">病毒感染 --&gt; 淋巴结肿大</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"药物处方如下\"><a href=\"#药物处方如下\" class=\"headerlink\" title=\"药物处方如下\"></a>药物处方如下</h3><ul>\n<li><input checked disabled type=\"checkbox\"> 泛昔洛韦</li>\n<li><input checked disabled type=\"checkbox\"> 甲钴胺</li>\n<li><input checked disabled type=\"checkbox\"> 龙血竭片</li>\n<li><input checked disabled type=\"checkbox\"> 阿昔洛韦乳膏</li>\n<li><input checked disabled type=\"checkbox\"> 加巴喷丁胶囊</li>\n</ul>\n<h2 id=\"4月10日\"><a href=\"#4月10日\" class=\"headerlink\" title=\"4月10日\"></a>4月10日</h2><p>前一晚没睡好，头疼欲裂，疱疹陆续开始加重，眼睑处又多冒出了几个水泡。<br>夜晚，畏寒低烧，体温升至37.5左右，吃了布洛芬一方面退烧，一方面抑制头疼。</p>\n<h2 id=\"4月11日\"><a href=\"#4月11日\" class=\"headerlink\" title=\"4月11日\"></a>4月11日</h2><p>早晨，发现耳垂下的淋巴结变小了，眼睑处和额头处疱疹颜色变浅(深?)，红晕缩小，似有恢复的迹象。</p>\n<h2 id=\"4月12日\"><a href=\"#4月12日\" class=\"headerlink\" title=\"4月12日\"></a>4月12日</h2><p>耳部附近淋巴结有明显变小，压痛感减轻，面部疱疹颜色进一步变深，偶尔神经痛刺痛；<br>感觉阿昔洛韦乳膏涂抹过多，皮肤表面难以清洗，减少涂药量为宜。</p>\n<h2 id=\"4月13日\"><a href=\"#4月13日\" class=\"headerlink\" title=\"4月13日\"></a>4月13日</h2><p>耳部附近淋巴结进一步变小，压痛感几乎消失，面部疱疹颜色进一步变深，偶尔神经刺痛；</p>\n","site":{"data":{}},"cover":"/img/c5.jpg","excerpt":"","more":"<blockquote>\n<p>_带状疱疹_是由水痘- _带状疱疹_病毒引起,以沿单侧周围神经分布的簇集性小水疱为特征的常见皮肤病,常伴有明显神经痛。当抵抗力低下或劳累、感染、感冒时，病毒可再次生长繁殖，并沿神经纤维移至皮肤，使受侵犯的神经和皮肤产生强烈的炎症。</p>\n</blockquote>\n<h1 id=\"前情提要\"><a href=\"#前情提要\" class=\"headerlink\" title=\"前情提要\"></a>前情提要</h1><p>3月26日突发感冒发烧（怀疑为甲流），历时三天，退烧后身体较为虚弱，喉咙长时间有痰；后续一段时期头晕，精神不佳，抵抗力严重下降。</p>\n<h1 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h1><h2 id=\"4月6日晚\"><a href=\"#4月6日晚\" class=\"headerlink\" title=\"4月6日晚\"></a>4月6日晚</h2><p>突然发现面部右侧耳多附近淋巴结肿大（当时误以为是<code>急性腮腺炎</code>），右侧眼睑、额头出现微凸起的红斑，按压有痛感，因为耳部的症状更加明显和剧烈，所以对于凸起的红斑不够重视，以为就是普通的上火长疮，涂抹了一些金霉素眼膏(抗生素)。<br>少量服用了阿莫西林。</p>\n<h2 id=\"4月7日\"><a href=\"#4月7日\" class=\"headerlink\" title=\"4月7日\"></a>4月7日</h2><p>眼睑处的红斑中央开始出现细微小水泡，夜晚出现了右侧面部乃至头部的神经性跳痛、刺痛，导致晚上完全没有睡好，淋巴结肿大无变化，打算第二天去医院看一下。<br>少量服用了阿莫西林。</p>\n<h2 id=\"4月8日\"><a href=\"#4月8日\" class=\"headerlink\" title=\"4月8日\"></a>4月8日</h2><p>早晨发现眼睑处水泡变大，已明显可见。<br>先去了校医务室，当班校医无法确认，只是说有点像腮腺炎，因为怕有传染性，建议我去医院检查。<br>校医先是将我转诊至北京积水潭医院昌平分院，到院后无号可挂，校医建议我返回；回途中发现昌平区医院有第二天的全科医学科室的号可以挂，于是返校后让校医将我转诊至昌平区医院。<br>是日晚，右眼神经性刺痛难耐。</p>\n<h2 id=\"4月9日\"><a href=\"#4月9日\" class=\"headerlink\" title=\"4月9日\"></a>4月9日</h2><ul>\n<li>上午9:30，先于全科医学门诊处就诊，坐诊医生怀疑面部右侧的皮肤症状为<code>带状疱疹</code>并由该病毒导致右侧耳部多个淋巴结肿大，应该不为腮腺炎，建议我转诊至皮肤科就诊；</li>\n<li>上午10:30，于皮肤科就诊，医生一眼断定为带状疱疹，并准确描述出了我前几日的面部神经痛现象，至此基本可以确定病症所在；</li>\n<li>后半日开始正式的针对带状疱疹的治疗，夜晚仍头部神经痛，吃了止痛药。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">带状疱疹 --&gt; 病毒感染</span><br><span class=\"line\">病毒感染 --&gt; 淋巴结肿大</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"药物处方如下\"><a href=\"#药物处方如下\" class=\"headerlink\" title=\"药物处方如下\"></a>药物处方如下</h3><ul>\n<li><input checked disabled type=\"checkbox\"> 泛昔洛韦</li>\n<li><input checked disabled type=\"checkbox\"> 甲钴胺</li>\n<li><input checked disabled type=\"checkbox\"> 龙血竭片</li>\n<li><input checked disabled type=\"checkbox\"> 阿昔洛韦乳膏</li>\n<li><input checked disabled type=\"checkbox\"> 加巴喷丁胶囊</li>\n</ul>\n<h2 id=\"4月10日\"><a href=\"#4月10日\" class=\"headerlink\" title=\"4月10日\"></a>4月10日</h2><p>前一晚没睡好，头疼欲裂，疱疹陆续开始加重，眼睑处又多冒出了几个水泡。<br>夜晚，畏寒低烧，体温升至37.5左右，吃了布洛芬一方面退烧，一方面抑制头疼。</p>\n<h2 id=\"4月11日\"><a href=\"#4月11日\" class=\"headerlink\" title=\"4月11日\"></a>4月11日</h2><p>早晨，发现耳垂下的淋巴结变小了，眼睑处和额头处疱疹颜色变浅(深?)，红晕缩小，似有恢复的迹象。</p>\n<h2 id=\"4月12日\"><a href=\"#4月12日\" class=\"headerlink\" title=\"4月12日\"></a>4月12日</h2><p>耳部附近淋巴结有明显变小，压痛感减轻，面部疱疹颜色进一步变深，偶尔神经痛刺痛；<br>感觉阿昔洛韦乳膏涂抹过多，皮肤表面难以清洗，减少涂药量为宜。</p>\n<h2 id=\"4月13日\"><a href=\"#4月13日\" class=\"headerlink\" title=\"4月13日\"></a>4月13日</h2><p>耳部附近淋巴结进一步变小，压痛感几乎消失，面部疱疹颜色进一步变深，偶尔神经刺痛；</p>\n"},{"title":"汇编语言","abbrlink":"8e41db39","date":"2022-09-08T13:27:48.000Z","_content":"\n# 汇编知识\n\n#### 汇编语言的组成\n\n1.   汇编指令：机器码的助记符，有对应的机器码\n2.   伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行\n3.   其他符号：由编译器识别，没有对应的机器码\n\n#### 8086PC 内存地址分配\n\n8086PC 具有宽度为20的地址总线，宽度为16的数据总线\n\n00000 ~ 9FFFF     主存储器RAM\n\nA0000 ~ BFFFF    显存地址\n\nC0000 ~ FFFFF    各类ROM\n\n#### Debug程序\n\n+   -u : check a memory segment in assembly way    以数据的形式查看一段内存\n+   -d : check a memory segment in data way             以代码的形式查看一段内存\n+   -e : edit a memory segment                    编辑一段内存地址，使用空格进行后移                   \n+   -a : input a series of assembly code              默认在cs:ip位置处编写一段汇编代码，可指定其他内存位置\n+   -r : check all registers or update a register       查看所用通用寄存器或者修改某寄存器的值\n+   -t : debug a programme step by step with going into sub programme          单步调试，进入子程序\n+   -p : debug a programme step by step without going into sub programme      单步调试，不进入子程序，跳过循环\n+   -n : rename a file           文件重命名\n+   -g : don't stop executing the programme until the target address you set comes           运行程序到你设定的地址\n\n## 通用寄存器\n\n​\t是CPU内部的存储器，是用来暂存计算数据及结果，是程序员可以进行操纵的空间，通过操纵寄存器进而达到操纵CPU的目的\n\n对于8086CPU来说，总共有14个\n\n### 数据寄存器\n\n其中通用寄存器有4个{AX，BX，CX，DX}，用来存放数据，每一个通用寄存器是由高低两个8位寄存器组成的16位寄存器{AX = AH + AL}；\n\n>EAX : 32位寄存器                  RAX : 64位寄存器 \n>\n>EAX 位于 RAX 的低32位\n>\n>AX 位于 EAX 的低16位\n\n进行8位运算时，两个8位寄存器互不影响，不进位不借位，进位值与借位值存在标志寄存器的**CF标志位**中\n\n进行16位运算时，  高位溢出舍弃\n\n#### MOV & ADD & SUB 指令\n\n```assembly\nmov ax,bx      ; 将ax中的数据与bx相加后结果送入ax\nmov ax,5FC5    ; 将ax的值改为5fc5\nmov al,bh      ; 将ax的低8位的值改为bx高8位的值\nadd ax,05A6    ; ax的值加上05a6后，送入ax中\nadd bh,al      ; 将bx的高8位加上ax的低8位\nsub ax,ax      ; 减法运算\n```\n\n### 地址寄存器\n\n+   段地址寄存器\n\n    {CS，DS，SS，ES} = {代码段，数据段，堆栈段，其他段}\n\n+   偏移地址寄存器\n\n    {SP，BP，SI，DI，IP，BX} = {，，，，指令指针，}\n\n+   设计目的\n\n    8086CPU地址总线宽度为20，而寄存器位长16，那么就需要用两个寄存器来存一个物理地址\n\n```mathematica\nPhysicalAddr = SegmentAddr * 10h + OffsetAddr\n```\n\n### CS : IP 代码段\n\n>   代码段寄存器 : 指令指针寄存器\n\nCPU将CS:IP指向的内存单元中的内容当做代码执行 \n\n指令执行过程：\n\n```tex\n1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲区\n2. IP = IP + Length(Instruction) 从而指向下一条指令的地址\n3. 执行指令，转到步骤 1\n```\n\n在8086CPU加电启动或复位后，CS被置为FFFFH，IP被置为0000H\n\n#### JMP 指令\n\n转移指令，修改CS:IP的值\n\n```assembly\njmp 2000:0010    ; 修改CS为2000，修改IP为0010\njmp ax           ; 修改IP为AX中存储的值\n```\n\n### DS : [Offset] 数据段\n\n>   数据段寄存器 : [偏移地址]\n\nCPU将DS:[Offset]指向的内存地址中的内容当做数据读写（<u>**需要注意小端序还是大端序**</u>）\n\n```assembly\nmov bx,3001\nmov ds,bx         ; 将BX中存储的段地址送入DS数据段寄存器中，8086不允许使用MOV指令直接给段寄存器赋值\nmov ax,[0101]     ; 将内存中地址为 DS * 10h + 0101h 中的数据送入AX中\nmov [0102],ax     ; 将AX中的数据送入到内存地位为 DS * 10h + 0102h 的地方\n```\n\n### SS : SP 堆栈段\n\n>   堆栈段寄存器 : 栈顶指针寄存器\n\n8086CPU的入栈操作和出栈操作都是以**字**为单位进行的；入栈时，栈顶由高地址向低地址的方向增长(小端序)\n\n#### PUSH & POP 指令\n\n出栈 & 入栈\n\n```assembly\n;指定栈顶界限，假定栈段范围为10000 ~ 1001F\nmov ax,1000\nmov ss,ax\n;设置栈顶指针,空栈时,栈顶指针指向栈底后一位地址\nmov sp,0020\n;入栈：\n;\tSP = SP - 2       \nmov bx,3FFF\npush bx\npush ds\npush [0]\n;出栈：\n;\tSP = SP + 2\npop [0]\npop ds\npop bx\n```\n\n**当执行修改SS堆栈段寄存器的值时，下一条指令也会紧接着执行**\n\n## 源代码\n\n```assembly\nassume cs:code,ds:data,ss:stack\n\n; 数据段\ndata segment\ndate ends\n; 堆栈段\nstack segment stack\nstack ends\n; 代码段\ncode segment\n\t\n\tmov ax,4500H\n\tmov ds,ax\n\tmov ax,1000H\n\tmov ss,ax\n\tmov sp,0020H\n\t\n\tmov ax,0D200H      ; 在汇编源程序中，数据不能以字母开头，若最高位＞9时，需要在前面补0\n\tmov ds:[0],ax\n    push ds:[0]\n    pop bx\n    mov ds:[2],bx\n\t\n\t; 返回上级程序\n\tmov ax,4c00H\n\tint 21H\ncode ends\n\nend\n```\n\n## [BX] & LOOP 指令\n\n```assembly\nmov bx,0010H   \nmov ax,50F0H\nmov ds:[bx],ax   ; 将bx寄存器中的数据当做地址偏移量\n```\n\n​\t\tCX寄存器中的值可作为loop指令循环次数，每次减一，知道减为零结束循环\n\n```assembly\nassume cs:code\ncode segment\n\tmov ax,1000H\n\tmov ds,ax\n\tmov bx,5H\n\t\n\tmov al,ds:[bx]\n\tmov ah,0H\n\tmov dx,0H\n\t\n\tmov cx,5            ; 初始化循环次数\ns: \tadd dx,ax           ; 定义循环体\n\tloop s              ; 开始循环\n\t\n\tmov ax,004cH\n\tint 21H\ncode ends\nend\n```\n\n综合运用[bx]&loop\n\n### INC 指令\n\n​\t数值自增一\n\n### DEC 指令\n\n​\t数值自减一\n\n```assembly\n; \t计算从10000H ~ 1000aH地址中所有数值的和，储存在dx中\n\t\n\tmov ax,1000H\n\tmov ds,ax\n\tmov bx,0H\n\n\tmov dx,0H\n\tmov cx,0aH\n\ns: \tmov al,ds:[bx]\n\tmov ah,0H\n\tadd dx,ax\n\tinc bx\n\tloop s\n\t\n```\n\n\n\n## DW 伪指令 & start 标号\n\n定义字型数据(define word)，可在代码段中存放提前定义好的数据\n\n**start** 标号用来标识程序的入口，即是初始化CS:IP的值，用 **end** 指令来声明**start**标号的作用（程序入口）\n\n```assembly\nassume cs:code\ncode segment\n\t\n\t; 定义数据\n\tdw 0123H,0a446H,5FF6H\n\t\n\t; 代码\nstart:\tmov bx,0\n\t\tmov ax,0\n\t\tmov cx,3\n\t\t\ns:\t\tadd ax,cs:[bx]\n\t\tadd bx,2H\n\t\tloop s\n\t\n\t\tmov ax,4c00H\n\t\tint 21H\ncode ends\nend start\n```\n\n### 分段\n\n​\t将数据、代码、栈三段分立，方便管理\n\n```assembly\nassume cs:code,ds:data,ss:stack\n\ndata segment\n\tdw 0123H,0456H,0789H,0abcH,0defH\ndata ends\n\nstack segment stack\n\tdw 0H,0H,0H,0,0,0,0\nstack ends\n\ncode segment\nstart:\t\n\t\tmov ax,data\n\t\tmov ds,ax         ; 分配数据段\n\t\tmov ax,stack\n\t\tmov ss,ax         ; 分配栈段\n\t\tmov sp,0eH\n\t\t\n\t\tmov ax,4c00H\n\t\tint 21H\ncode ends\n\nend start\n\t\t\n```\n\n## 地址定位与数据处理\n\n### AND & OR 指令\n\n​\t二进制逻辑与或运算\n\n### XOR 指令\n\n​\t异或运算，常用于main函数设置返回值0\n\n```assembly\nxor eax,eax     ; 该命令执行速度比 mov ax,0 要快\n```\n\n### 字符串型数据 & DB 伪指令\n\n```assembly\ndata segment\n\tdb 'string'\ndata ends\n; low -> up\nor al,00100000\n; up -> low\nand al,11011111\n```\n\n### 灵活定位 & DI & SI & BP\n\n```assembly\nmov ax,ds:[bx+100]\nmov ax,ds:[bx+di]\nmov ax,ds:[bx][si]\nmov ax,ds:[bx+si+100]\nmov ax,ds:[bx][si].100\nmov ax,ds:[bp+si+100]\nmov ax,ds:[bp][si].100\n```\n\nSI & DI ：16位寄存器，无法分割为两个8位寄存器\n\nBP：[见此处](#BP寄存器)\n\n\n\n### X PTR\n\n**指明数据长度的方式**：\n\n+   通过寄存器名指明数据长度\n\n    ```assembly\n    mov ax,1H\n    mov al,1H\n    ```\n\n    \n\n+   通过操作符 X PTR 指明数据长度\n\n```assembly\nmov word ptr ds:[0],1H\nmov byte ptr ds:[2],1H\nmov byte ptr ds:[bx+si+10],'F'\n```\n\n### DIV 指令\n\n1.   除数：在寄存器或内存\n2.   被除数：默认在AX或DX\n     +   除数为8位，被除数为16位，则被除数放在AX\n     +   除数为16位，被除数为32位，则被除数在DX与AX，DX放高位，AX放低位\n3.   结果：\n     +   若除数为8位，则al存放商，ah存放余数\n     +   若除数为16位，则ax存放商，dx存放余数\n\n```assembly\n; 计算 100001 / 100\n; 100001 => 186a1H\nmov dx,1H\nmov ax,86a1H\nmov word ptr ds:[bx+si+10],100\ndiv word ptr ds:[bx+si+10]\n```\n\n### DD 伪指令\n\n用来定义DWORD（double word）双字型数据\n\n### DUP 伪指令\n\n与db、dw、dd等数据定义伪指令配合使用，进行重复数据的定义\n\n+   db 重复次数 dup (被重复的字节型数据)\n+   dw 重复次数 dup (被重复的字型数据)\n+   dd 重复次数 dup (被重复的双字型数据)\n\n```assembly\ndb 3 dup ('12')    ;   db '121212'\ndb 5 dup (10H)     ;   db 10h,10h,10h,10h,10h\ndw 2 dup (5f5fH)   ;   dw 5f5fH,5f5fH\ndd 2 dup(12H)      ;   dd 00000012H,00000012H\n```\n\n## JMP指令原理\n\n### OFFSET 伪指令\n\n取得标号的偏移地址，**不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编**\n\n``` assembly\ncode segment\nstart:\t\n\t\tmov ax,offset start\n```\n\n### JMP指令的用法\n\n1.   数值指明目的地址\n\n     +   同时修改cs : ip\n\n         ```assembly\n         jmp 1000:0000\n         ```\n\n2.   段内短转移（机器码中不出现目的地址，只出现相对位移，**<u>==该相对位移在编译时确定==</u>**）\n\n     转移位移为8位，-128,127\n\n     ```assembly\n     code segment\n     s:\n     \tmov ax,10H\n     \tjmp short s          ; 使用相对距离差修改ip的值，ip = ip + (标号地址 - jmp后下一条指令初地址) \n     \tmov bx,11H\n     ```\n\n3.   段内近转移\n\n     转移位移为16位，-32768,32767（机器码中不出现目的地址，......同短转移）\n\n     ```assembly\n     code segment\n     s:\n     \tmov ax,10H\n     \tjmp near ptr s\n     \tmov bx,11H\n     ```\n\n4.   段间转移（远转移）\n\n     同时修改CS:IP，cs = 标号所在段的段地址，ip = 标号在所在段的偏移地址\n\n     ```assembly\n     acode segment\n     sa:\n     \tmov ax,10H\n     \tjmp far ptr sb\n     acode ends\n     \n     bcode segment\n     sb:\n     \tmov bx,11H\n     bcode ends\n     ```\n\n     \n\n5.   转移地址在寄存器中\n\n     ```assembly\n     mov ax,10F1H\n     jmp ax\n     ```\n\n     \n\n6.   转移地址在内存中\n\n     +   内存单元中存有一个字型数据，即为目的地址的偏移地址（段内转移但非近转移）\n\n         ```assembly\n         mov ax,1000H\n         mov ds:[1],ax\n         jmp word ptr ds:[1]\n         ```\n\n     +   内存单元中存有一个双字型数据，高位为目的地址的段地址，低位为偏移地址（段间转移）\n\n         ```assembly\n         mov ax,1000H\n         mov ds:[0],ax\n         mov word ptr ds:[2],0H\n         jmp dword ptr ds:[0]\n         ```\n\n### 有条件转移指令\n\n所有的条件转移指令都是短转移，在对应机器码中不出现目的地址，只出现相对位移，在编译时确定\n\n+   jcxz 指令\n\n    功能上等同于在段内短转移之前判断CX是否等于0，若cx == 0，则跳转，若cx != 0，则不跳转\n\n+   loop 指令\n\n    本质上也是条件转移指令，条件与jcxz相反，且伴随着cx的递减\n\n+   检测比较结果的条件转移指令（根据**<u>==无符号数==</u>**的比较结果进行转移）\n\n    | 指令 |     含义     |      相关标志位      |\n    | :--: | :----------: | :------------------: |\n    |  JE  |  等于则转移  |        ZF = 1        |\n    | JNE  | 不等于则转移 |        ZF = 0        |\n    |  JB  |  低于则转移  |        CF = 1        |\n    | JNB  | 不低于则转移 |        CF = 0        |\n    |  JA  |  高于则转移  |  CF = 0  &&  ZF = 0  |\n    | JNA  | 不高于则转移 | CF = 1  \\|\\|  ZF = 1 |\n\n    \n\n```assembly\njcxz 标号\n```\n\n\n\n## 栈操作\n\n### RET & RETF 指令\n\nret：用栈中的数据修改ip的内容，实现近转移\n\n```assembly\nret \n====>   \npop ip\n```\n\nretf：用栈中的数据修改 cs : ip，实现远转移\n\n```assembly\nretf \n====>\npop ip\npop cs\n====>\nmov bx,sp\njmp dword ptr ss:[bx]\nadd sp,4\n```\n\n### CALL 指令\n\ncall：将当前 ip 或 cs : ip 压入栈中，再转移\n\n+   进行近转移的call指令\n\n    ```assembly\n    call fun     ; fun 为本段内某标号\n    ====>\n    push ip\n    jmp near ptr fun\n    ```\n\n+   进行远转移的call指令\n\n    ```assembly\n    call far ptr fun     ; fun 为非本段内某标号\n    ====>\n    push cs\n    push ip\n    jmp far ptr fun\n    ```\n\n+   目的地址在寄存器的call指令\n\n    ```assembly\n    call ax      \n    ====>\n    push ip\n    jmp ax\n    ```\n\n+   目的地址在内存中的call指令\n\n    ```assembly\n    call word ptr ds:[bx]              ; 段内转移\n    ====>\n    push ip\n    jmp word ptr ds:[bx]\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    call dword ptr ds:[bx]             ; 段间转移（远转移）\n    ====>\n    push cs\n    push ip\n    jmp dword ptr ds:[bx]\n    ```\n\n### BP寄存器\n\n+   当没有显式指出段地址且偏移量寄存器使用bp时，则段地址默认为SS寄存器中的值，无法分割bp为基址寄存器\n+   和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到\n+   一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：\n\n```assembly\n;在函数进入时:\npush bp     ;\t保存bp指针\nmov bp,sp \t;\t将sp指针传给bp，此时bp指向sp的基地址。\n\n;;;;   函数体   ;;;;\n\nmov sp,bp   ;\tsp回到栈顶\npop bp      ;\tbp恢复初始值\nret         ; \t函数返回\n```\n\n### 参数压栈\n\n​\t调用某些带有参数的函数时，先按参数顺序将参数压栈(参数位于栈高位)，然后再执行**CALL**命令将CS:IP压栈(CS:IP位于栈低位)\n\n### LEA 指令\n\n​\tLEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。\n\n```assembly\nmakeArray PROC\n    push ebp\n    mov ebp,esp\n    sub esp, 32            ;myString 位于 EBP-30 的位置\n    lea esi, [ebp-30]      ;加载 myString 的地址\n    mov ecx, 30            ;循环计数器\nLI: mov BYTE PTR [esi]     ;填充一个位置\n    inc esi                ;指向下一个元素\n    loop LI                ;循环，直到 ECX=0\n    add esp, 32            ;删除数组(恢复ESP)\n    pop ebp\n    ret\nmakeArray ENDP\n```\n\n\n\n### MUL 指令\n\n+   两数相乘，要么都是8位，要么都是16位\n+   若是8位，一个默认在AL，另一个在8位寄存器或内存，结果在AX\n+   若是16位，一个默认在AX，另一个在16位寄存器或内存，高位在DX，低位在AX\n\n### 寄存器冲突问题\n\n若计数器寄存器 CX 另有用途，无法存放循环次数，那么可以用 jmp 与 jcxz 指令配合代替loop指令，实现有限循环\n\n---\n\n## 标志寄存器\n\n### 作用\n\n+   用来存储相关指令的某些执行结果\n+   用来为CPU执行相关指令提供行为依据\n+   用来控制CPU的相关工作方式\n\n>   8086CPU的标志寄存器时16位寄存器，其信息是按起作用，每一个位存储的信息通常被称为程序状态字(PSW)\n\n|  15  |  14  |  13  |  12  |  11  |  10  |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|      |      |      |      |  OF  |  DF  |  IF  |  TF  |  SF  |  ZF  |      |  AF  |      |  PF  |      |  CF  |\n\n### ZF 标志\n\n+   位于第  **==6==** 位\n+   零标志位，记录相关指令执行后，其结果是否为0，若为 ==0== 则ZF = 1，否则ZF = 0；\n+   在8086CPU指令集中，add、sub、mul、div、inc、or、and 等运算指令一般影响ZF\n\n### PF 标志\n\n+   位于第 **==2==** 位\n+   奇偶标志位，记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若 ==偶== 则 ==1==，若 ==奇== 则 ==0==\n\n### SF 标志\n\n+   位于第 **==7==** 位\n+   符号标志位，记录相关指令执行后，其结果是否为负，若 ==负== 则 ==1==，若 ==非负== 则 ==0==\n\n### CF 标志\n\n+   位于第 **==0==** 位\n+   进位标志位，一般情况下，在进行 <u>无符号数</u> 运算的时候，记录了运算结果的最高有效位向更高位的进位值，或借位值\n\n### OF 标志\n\n+   位于第 **==11==** 位\n+   CPU在进行 <u>有符号数</u> 运算时，若溢出则为 1 ，若未溢出，则为 0 \n\n### ADC 指令\n\nadc指令是带进位的加法指令，利用了CF标志位\n\n```assembly\nadc ax,bx    ;  ax = ax + bx + CF\n```\n\n### SBB 指令\n\nsbb指令是带借位减法指令，同样利用了CF标志位\n\n```assembly\nsbb ax,bx    ; ax = ax - bx - CF\n```\n\n### CMP 指令\n\ncmp是比较指令，功能上相当于减法指令，但不保存结果，只影响相关标志位的值\n\n```assembly\nmov ax,3\nmov bx,4\ncmp ax,bx\n; 相当于执行减法，执行后 ZF = 0，PF = 1，SF = 1,CF = 1,OF = 0\n```\n\n+   ZF = 1  ==>  ax == bx\n+   ZF = 0  ==>  ax != bx\n+   CF = 1  ==>  ax < bx\n+   CF = 0  ==>  ax >= bx\n\n### TEST 指令\n\ntest 对两个操作数进行逻辑（按位）与操作，功能上与and指令类似，但不保存结果，只影响相关标志位的值\n\n```assembly\n; 检查ax的最高位是否为 1\ntest ax,10000000b\nje isNotOne      ; 最高位是 0\njne isOne\t\t ; 最高位是 1\n```\n\n\n\n### 与标志位相关的条件转移指令\n\n[详细见此处](#有条件转移指令)\n\n### DF 标志 & 串传送指令\n\n+   DF 标志位于第 ==10== 位\n+   方向标志位，在串处理指令中，控制每次操作后 SI 与 DI 的增减\n+   若 DF = 0，则每次操作后 SI & DI 递增\n+   若 DF = 1，则每次操作后 SI & DI 递减\n\n#### MOVSB 指令\n\nmovsb 指令功能是将ds:si指向的内存单元中的一个字节型数据送入es:di；相当于:\n\n```assembly\n; if DF = 1\nmov es:[di],byte ptr ds:[si]\ndec si\ndec di\n\n; if DF = 0\nmov es:[di],byte ptr ds:[si]\ninc si\ninc di\n```\n\n#### MOVSW 指令\n\nmovsw 指令与 movsb 指令类似，只是把字节型数据改为字型数据，si 与 di 每次变化两个单位\n\n#### 与 REP 的配合\n\n上述两种指令都需要与 rep 相配和，实现数据从 DS段 **连续**传送到 ES段 中，本质是由loop循环的实现，循环次数由 CX 的值决定\n\n``` assembly\nrep movsb\n====>\ns: \n\tmovsb\n\tloop s\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nrep movsw\n====>\ns: \n\tmovsw\n\tloop s\n```\n\n#### CLD & STD 指令\n\n+   sld 指令：将DF置 0，实现 si 与 di 的自增\n+   std 指令：将DF置 1，实现 si 与 di 的自减\n\n### PUSHF & POPF 指令\n\npushf的功能是将标志寄存器中的值压栈，而popf是将栈中的数据弹出并送入标志寄存器中\n\n### 标志寄存器在Debug中的表示\n\n| 标志 | 置一 | 置零 |\n| :--: | :--: | :--: |\n|  OF  |  OV  |  NV  |\n|  SF  |  NG  |  PL  |\n|  ZF  |  ZR  |  NZ  |\n|  PF  |  PE  |  PO  |\n|  CF  |  CY  |  NC  |\n|  DF  |  DN  |  UP  |\n\n---\n\n\n\n## 内中断\n\n\n\n# 32位逆向\n\n## 小端序&大端序\n\n地址高位存数据高位 ===》 小端序\n\n地址高位存地址低位 ===》 大端序\n\n## IA-32寄存器\n\n### 基本程序运行寄存器\n\n+   通用寄存器{EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP}\n+   段寄存器{CS，DS，SS，ES，FS，GS}\n+   程序状态与控制寄存器{EFLAGS}\n+   指令指针寄存器{EIP}\n\n>Tips:\n>\n>1.   EAX一般用于函数返回值中，所有Win32 API函数都会先把返回值保存在EAX中再返回\n>2.   ES，FS，GS：附加数据段\n\n## 栈帧\n\n+   cdecl：调用者负责清理栈中的参数\n+   stdcall：被调用者负责清理栈中的参数\n\n## PE文件格式\n\n<img src=\"https://img-blog.csdnimg.cn/20201210163828181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nX2Nt,size_16,color_FFFFFF,t_70\" alt=\"img\" style=\"zoom:100%;\" />\n\n### DOS 头\n\n```c\n//注释掉的不需要重点分析\nstruct _IMAGE_DOS_HEADER{\n    0X00 WORD e_magic;      //※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件\n    //0X02 WORD e_cblp;     //Bytes on last page of file\n    //0X04 WORD e_cp;       //Pages in file\n    //0X06 WORD e_crlc;     //Relocations\n    //0X08 WORD e_cparhdr;  //Size of header in paragraphs\n    //0X0A WORD e_minalloc; //Minimun extra paragraphs needs\n    //0X0C WORD e_maxalloc; //Maximun extra paragraphs needs\n    //0X0E WORD e_ss;       //intial(relative)SS value\n    //0X10 WORD e_sp;       //intial SP value\n    //0X12 WORD e_csum;     //Checksum\n    //0X14 WORD e_ip;       //intial IP value\n    //0X16 WORD e_cs;       //intial(relative)CS value\n    //0X18 WORD e_lfarlc;   //File Address of relocation table\n    //0X1A WORD e_ovno;     //Overlay number\n    //0x1C WORD e_res[4];   //Reserved words\n    //0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)\n    //0x26 WORD e_oeminfo;  //OEM information;e_oemid specific\n    //0x28 WORD e_res2[10]; //Reserved words\n    0x3C DWORD e_lfanew;    //※Offset to start of PE header:定位PE文件，NT头相对于文件的偏移量\n};\n```\n\ne_magic : 固定为 ‘MZ’\n\ne_lfanew：NT头的文件偏移位置\n\n### DOS stub\n\n​\t由代码与数据混合而成，大小不固定，可没有，可存储在16位汇编指令，在dos环境下运行\n\n### NT 头\n\n```c\n//x86\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;                       // 文件头\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      \t   // 可选头\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n\n//x64\ntypedef struct _IMAGE_NT_HEADERS64 {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER64 OptionalHeader;\n} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;\n```\n\nSignature: 签名，50450000H ===>  \"PE00\"\n\n### NT ：文件头\n\n```c\n//x86 x64相同\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;                           // 运行平台  \n    WORD    NumberOfSections;\t\t\t\t// 节的数量\n    DWORD   TimeDateStamp;\t\t\t\t\t// 时间戳\n    DWORD   PointerToSymbolTable;\t\t\t// 符号表指针\n    DWORD   NumberOfSymbols;\t\t\t\t// 符号数量\n    WORD    SizeOfOptionalHeader;\t\t\t// 可选头大小\n    WORD    Characteristics;                 // 文件属性\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\n+   Machine：\n    +   0x014cH\tx86\n    +   0x0200H    Intel 64\n    +   0x8664H    x64\n\n+   Characteristics:\n    +   0x0002H\t可执行文件\n    +   0x2000H    动态链接库\n    +   0x1000H    系统文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 编译过程\n\n<img src=\"https://img-blog.csdn.net/20170611205306090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFpZGUyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"C_complie\" style=\"zoom:125%;\" />\n\n## 预处理\n\n- 使用程序\n\n    ​\t**cpp.exe**\n\n    ```sh\n    gcc -E main.c -o main.i\n    ```\n\n- 作用\n\n    1. 宏替换\n    2. 包含头文件\n    3. 条件编译\n    4. 处理预处理关键字\n\n- 结果\n\n    ​\t扩展的c源码，生成扩展名为 ‘.i ’ 的ASCII文件\n\n    ---\n\n## 编译\n\n- 使用程序\n\n    ​\t**cc1.exe**\n\n    ```sh\n    gcc -S main.i\n    ```\n\n- 结果\n\n    ​\t将c源码翻译为汇编源码，生成扩展名为 ‘ .s ’的ASCII文件\n\n    ​\t\n\n    ---\n\n## 汇编\n\n- 使用程序\n\n    ​\t**as.exe**\n\n    ```sh\n    gcc -c main.s\n    ```\n\n- 结果\n\n    ​\t将汇编源码翻译为二进制代码，生成扩展名为 ‘ .o’ 的二进制文件 \n\n- 注意\n\n    ​\t无法直接运行，需要链接（*单个文件也需要链接*）\n\n    ---\n\n## 链接\n\n- 使用程序\n\n    ​\t**collect2.exe** / **ld.exe**  （静态链接器）\n\n    ```sh\n    gcc main.o -o main\n    ```\n\n- 作用\n\n    1. 将众多.o文件合成为一个完整的可执行文件\n    2. 链接时，需要加入由编译器提供的启动代码，来调用main函数\n    3. 链接时，需要进行符号解析与地址重定位\n\n- 结果\n\n    ​\t在Windows环境下生成‘.exe’ 文件，在linux环境下没有固定扩展名\n\n### 静态链接\n\n- 定义\n\n    ​\t在编译时完成的链接，调用 **ld** / **collect2** 链接程序，将所有.o文件整合\n\n- 缺点\n\n    ​\t重复代码较多，浪费计算机资源\n\n- 具体过程\n\n    1.  符号解析\n\n         +  作用\n\n            ​\t符号解析的目的是将符号的引用与符号的定义练习起来（如：函数的声明与实现）\n\n         +  实现\n\n            ​\t在每一个.o文件中都会包含一张符号表(.symtab)，用来记录：\t\t\n\n            ​\t\t\n\n            ```tex\n            （1） 本模块定义了哪些符号\n            （2） 本模块引用了哪些符号\n            ```\n\n            ​\t\t\n\n         +  注意\n\n            ​\t单个.c文件即为一个模块，整个工程以模块为单位进行组织\n\n            ​\t\n\n    2.  地址重定位\n\n         +  作用  \n\n            ​\t将.o文件中的每个机器指令的逻辑地址，重定位为实际运行的地址\n\n            ```tex\n            1. 如果是裸机运行的，运行的地址就是内存的物理地址\n            2. 如果是基于OS运行的，运行地址就是虚拟内存的地址\n            ```\n\n         +  逻辑地址\n\n            ​\t在每个节中，从零开始标号\n\n         +  虚拟地址\n\n            1. 在32位Linux操作系统下，虚拟地址为32位，从<u>0x08048000</u>开始\n                \t2. 在64位Linux操作系统下，虚拟地址为64位，从0x00000000000400000开始\n\n### 动态链接\n\n+ 定义\n\n    ​\t在编译时只留下调用接口，当程序真正运行起来的时候，才去链接执行\n\n+ 使用时机\n\n    ​\t使用动态链接库（DLL）时\n\n    ​\t如printf函数由动态链接库提供，程序编译后，代码中不存在printf函数代码，只有其接口，当程序运行时，再去动态链接其所在的DLL，这里的接口是二进制代码，实质为该函数第一条指令的地址(相对地址 + 绝对地址)\n\n    ```\n    相对地址: 某成员在DLL中的相对位置； 绝对地址: DLL被加载到内存中后的物理地址\n    ```\n\n    \n\n+ 动态链接器。。。\n\n+ 链接过程与优点\n\n    ​\t程序运行时，将**<u>整个</u>**DLL加载到内存之中，内存中所有相关进程共享该DLL的代码，减少了代码的冗余，提高了计算机空间资源的利用率\n\n    > 因为DLL并不知道用户的程序需要该库中哪个变量或函数，所以需要将其完整加载到内存中\n\n---\n\n# 目标文件\n\n## 目标文件类型\n\n### \t可重定位目标文件\n\n  + 定义\n\n​\t被用于静态链接的文件，都是看重定位目标文件\n\n```tex\n什么是可重定位？\n\t因为采用静态链接，逻辑地址需要被重定位为运行地址后才能被运行\n```\n\n+ 类型\n\n    ​\t以‘‘**.a 、.lib**’’ 为扩展名的静态库文件以及以‘‘ **.o** ’’为扩展名的二进制文件都是<u>可重定位目标文件</u>\n\n\n### \t可执行目标文件\n\n​\t\t就是可执行的文件\n\n### \t共享目标文件\n\n​\t\t本质就是动态库文件DLL，DLL也被称为共享库\n\n---\n\n## 目标文件格式\n\n\t### 裸机（无OS）\n\n​\t“ .bin ” 文件格式，直接运行在**arm**裸机上\n\n### UNIX系统\n\n 1.  早期unix操作系统\n\n     ​\t使用“ **.out**  ” 文件格式，在UNIX操作系统上编译程序后，若不指定可执行文件名，会默认命名为 “ a.out ”\n\n 2.  system V unix\n\n     ​\ta.out 文件格式变为 **COFF** ( Common Object File Format : 一般目标文件格式) \n\n 3.  线代Unix\n\n     ​\t改用 **ELF**（Executable and Linkable Format：可执行、可链接格式）\n\n### Windows系统\n\n​\t采用 **PE** （Portable Executable：可移植、可执行格式）\n\n```tex\n这里的可移植并非指PE格式文件可跨平台执行，而是指兼容多种语言\n```\n\n### Linux系统\n\n​\t与现代Unix相同，与使用**ELF**格式，linux操作系统脱胎于unix，因此在linux操作系统编译得到的可执行文件上也默认命名为“ a.out ”，但是文件格式与早期Unix并不一致\n\n```tex\n如何理解ELF（可执行、可链接）的含义？\n1. 可重定位目标文件、共享目标文件：可以被链接\n2. 可执行目标文件：能被执行\n```\n\n### ELF格式可重定位目标文件\n\n#### 组成结构图\n\n<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo10%2Fcd31ce13972e4a6a82284b1b07faabae.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647693494&t=81dd5f93e3a64f75b1a77e522cad6df5\" alt=\"点击查看图片来源\" style=\"zoom: 67%;\" />\n\n#### ELF Header\n\n```shell\n使用 readelf -h 查看elf头信息\nreadelf -h file\n```\n\n![img](file:///C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\956489228\\QQ\\WinTemp\\RichOle\\YQZ8(L~D)SSOQ65HK]0YTDS.png)\n\n```c\ntypedef struct {\n  unsigned char e_ident[16];        /* ELF \"magic number\" */\n  unsigned char e_type[2];      /* Identifies object file type */\n  unsigned char e_machine[2];       /* Specifies required architecture */\n  unsigned char e_version[4];       /* Identifies object file version */\n  unsigned char e_entry[4];     /* Entry point virtual address */\n  unsigned char e_phoff[4];     /* Program header table file offset */\n  unsigned char e_shoff[4];     /* Section header table file offset */\n  unsigned char e_flags[4];     /* Processor-specific flags */\n  unsigned char e_ehsize[2];        /* ELF header size in bytes */\n  unsigned char e_phentsize[2];     /* Program header table entry size */\n  unsigned char e_phnum[2];     /* Program header table entry count */\n  unsigned char e_shentsize[2];     /* Section header table entry size */\n  unsigned char e_shnum[2];     /* Section header table entry count */\n  unsigned char e_shstrndx[2];      /* Section header string table index */\n} Elf32_External_Ehdr;\n```\n\n##### **e_ident**\n\ne_ident 是一个包含 16 字节的数组成员，对应 readelf -h 给出的 magic 部分.\n\nmagic 部分就是我们所说的魔数，魔数通常就是自定义的识别码，对于 32 位的 elf 文件而言，magic 部分有 16 个字节.\n\n大部分的文件组织形式都是这样的，头部是一串特殊的识别码，标识该文件的一些概要信息，主要用于外部程序快速地对这个文件进行识别，快速地判断文件类型.\n\n但是 readelf 命令仅仅是显示了对应的二进制码，并没有进一步显示整个魔数字段的详细信息，关于这一部分就需要参考 readelf 源码来进行分析了，分析结果如下:\n\n-   前四个字节:7f 45 4c 46，识别码， 0x45，0x4c，0x46 三个字节的 ascii 码对应 ELF 字母，通过这四个字节就可以判断文件是不是 elf 文件.\n-   第五个字节:其中 01 表示 32 位 elf 文件，02 表示 64 位.\n-   第六个字节:其中 01 表示 小端模式，02 表示 大端模式.\n-   第七个字节:表示 EI_version，1 表示 EV_CURRENT，只有 1 才是合理的(代码中是 EI_versoin，但是博主没有进一步具体研究).\n-   第八个字节: 00 表示 OS_ABI\n-   第九个字节: 00 表示 ABI version\n-   其它字段，源码中没有找到对应的解析，暂定为reserver.\n\n+ xx\n\n##### e_type\n\ntype 表示 elf 文件的细分类型，总共有四种:\n\n-   可重定位的目标文件\n-   可执行文件\n-   动态链接文件\n-   coredump 文件，这是系统生成的调试文件.\n\n这四种类型的文件各有各的特点，比如可重定位的目标文件针对的是链接器.\n\n而可执行文件针对加载器，需要被静态加载到内存中执行，而动态链接文件则是运行过程中的加载.\n\ncoredump 文件主要保存的是系统出错时的运行断点信息，方便人为地或者借助 gdb 分析 bug.\n\n##### e_machine\n\n标识指定的机器，比如 40 代表 ARM.\n\n其它的比如 x86，mips 等都对应不同的编码.\n\n##### e_version\n\n四个字节的 version code\n\n##### e_entry\n\n程序的入口虚拟地址，对于可重定位的目标文件默认是0，而对于可执行文件而言是真实的程序入口.\n\n程序入口是被加载器使用的，在程序加载过程中会读取该程序入口，作为应用程序的开始执行地址，在实际的加载过程中，内核加载完当前 elf 可执行文件之后其实并不是跳到该入口地址，而是先执行动态链接器代码，在动态链接完成之后才会跳到该入口地址。\n\n##### e_phoff\n\n program header table 的起始偏移地址，\n\n##### e_shoff\n\n section header table 的起始偏移地址，\n\n##### e_flags\n\n和处理器相关的标志位集合，不同的处理器有不同的参数，根据 e_machine 进行解析.\n\n##### e_ehsize\n\n指示 elf header 的 size，对于 arm 而言，52 或者 64.\n\n##### e_phentsize\n\n每一个 program header 的 size，在可重定位目标文件中为 0.\n\n##### e_phnum\n\n该文件中一共有多少个 program header，在可重定位目标文件中为0.\n\n##### e_shentsize\n\n文件中每一个section header 的大小，通常是 40.\n\n##### e_shnum\n\n该文件中一共有多少个 section header，上述的示例文件中为 10 个.\n\n##### e_shstrndx\n\n在 elf 格式的文件中，符号，section，文件的命名通常是字符串，这些字符串并不会保存在其对应的 section 中，而是统一地使用一个字符串表来保存，该字段指示节标题字符串所在的 section，在上面的示例中，section 标题(.text，.data，...)对应的 e_shstrndx 即段序号为 7，即保存在 .shstrtab 段中.这些 section 标题在链接的过程中需要使用到，在程序执行时是无用的，所以分开有利于精简 section 内容的大小，从而程序加载运行时需要更小的空间.\n\n除了 section 标题，还有符号名，文件名等字符串，这些默认会被保存在 .strtab section 中.\n\n```mathematica\nELF文件大小：\nSize = e_shoff + e_shnum * e_shentsize\n```\n\n\n\n#### .text Section\n\n​\t<u>**==只读==**</u> **代码**节，存放所有函数的机器指令即程序代码，有些常量也会与指令一起存放在此节中（如字面量）\n\n```c\nint main()\n{\n    int a = 10;\n    a = a + 100;     // 此处的100会与指令一并存放在该节\n}\n```\n\n#### .rodata Section\n\n​\t**<u>==只读==</u>** **数据**节，存放常量数据（如字符串常量）\n\n```c\nint main()\n{\n    char *str = \"HelloWorld!\";\n    printf(\"%s\",str);        // 这里的“%s” 与 “HelloWorld！”会存放在该节\n}\n```\n\n#### .data Section\n\n​\t<u>**==可写==**</u> **数据**节，存放：\n\n 1.    已初始化的全局变量\n\n       ```c\n       int global = 10;\n       int main(){\n           printf(\"%d\",global + 10);\n       }\n       ```\n\n 2.    已初始化的静态局部变量\n\n       ```c\n       int getCount(char *arr)\n       {\n           static int count = 0;         // 该静态局部变量已被初始化\n           count += strlen(arr);\n           return count;\n       }\n       ```\n\n#### .bss Section\n\n​\t<u>**==可写==**</u> **数据**节\n\n1.   未初始化的全局变量\n\n     ```c\n     int global;\n     int main(){\n         printf(\"%d\",global + 10);\n     }\n     ```\n\n2.   未初始化的静态局部变量\n\n     ```c\n     int getCount(char *arr)\n     {\n         static int count;         // 该静态局部变量未被初始化\n         count = strlen(arr);\n         return count;\n     }\n     ```\n\n     由于.bss节存放没有初始化的数据，所以其并不占有真实地存储空间，.bss 节在可重定位目标文件中只作占位符，当程序真正运行起来时才会在内存中开辟.bss节的空间，并为其中的数据赋上初始值（0）\n\n---\n\n#### .symtab Section\n\n​\t**符号表**（symbol table），用于存放可重定位目标文件中的 **==定义==** 与 **==引用==** 的全局符号信息，包括全局变量、函数.symtab\n\n```sh\nreadelf -s main.o     # 查看符号表\n\ngcc -s main.o -o main      # 编译时剔除符号信息与重定位信息\nstrip main.o   # 丢弃目标文件中的符号\n```\n\n符号表包含很多条目，每个条目记录的就是一个符号的基本信息。\n\n```c\ntypedef struct\n{\n  Elf32_Word    st_name;                /* Symbol name (string tbl index) */\n  Elf32_Addr    st_value;               /* Symbol value */\n  Elf32_Word    st_size;                /* Symbol size */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf32_Section st_shndx;               /* Section index */\n} Elf32_Sym;\n \ntypedef struct\n{\n  Elf64_Word    st_name;                /* Symbol name (string tbl index) */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf64_Section st_shndx;               /* Section index */\n  Elf64_Addr    st_value;               /* Symbol value */\n  Elf64_Xword   st_size;                /* Symbol size */\n} Elf64_Sym;\n```\n\n​\t**1）name**\n\n​\t\t\t\t\tname中记录的并不是名字的字符串，我们前面说过所有的字符串都是放在了.strtab中。name里面只记录字符\t\t\t串在 **.strtab** 中的偏移，通过这个偏移就能在 **.strtab** 中索引到符号的名字。\n\n​\t\t\te.g.\n\n​\t\t\t\tname = 5 //偏移5\n​\t\t\t\t假如.strtab中的内容为main\\0fun2\\0a_va\\0......\n​\t\t\t\t使用偏移5到.strtab中进行搜索，当遇到\\0时就截止，那么取出来的就是符号fun2。\n\n​\t**2）value**\n\n​\t\t\t放的是地址：指向符号所代表的空间。不过对于.o（可重定位目标文件）和可执行目标文件来说，value的值有所不\t\t同。\n\n+   可重定位目标文件\n\n​\t\t\t\t\tvalue总中放的只是相对于节起始地址的偏移。\n\n+   可执行目标文件\n\n​\t\t\t\t\tvalue中放的是绝对地址。“可重定位目标文件”被连接在一起后，value中放的是链接时重定位后的绝对地址。\n\n​\t**3）size**\n\n​\t\t\tsize代表的是value所指向空间的大小，毕竟value只是起始地址，不能说明空间的大小。\n\n​\t\t\t比如：\n\n+   ​\t如果符号是初始化了的全局变量的话\n    ​     size代表的全局变量在.data中所占字节数。\n\n+   如果符号是函数的话\n         size代表的是函数指令在.text中所占空间的大小\n\n​\t**4）type**\n\n​\t\t符号类型，大致有如下几种类型。\n\n+   FUNC：符号代表的是函数\n+   OBJECT：符号代表的是全局变量\n+   FILE：符号是源文件的名字\n+   SECTION：该符号关联的实体是个节，用于重定位\n+   COMMON：未初始化的全局变量，储存在.bss节\n+   NOTYPE：未知或未指定类型\n+   WEAK：弱符号，在链接时忽略弱符号的声明，采纳强符号的定义，可用来解决多文件符号冲突问题\n\n​\t**5）bind**\n\n​\t\t\t就两种情况，LCOAL、GLOBAL\n\n+   bind=LOCAL\n\n​\t\t\t\t\t表示符号是本地的：符号在模块中定义后，只能由本模块引用，static修饰的全局变量和函数就是这种情况。\n\n+   bind=CLOBAL(全局符号)\n\n​\t\t\t\t\t表示符号在本模块定义，但是可以被其它模块引用（使用），extern修饰的全局变量和函数就是这种情况。\n\n​\t**6）section**\n\n​\t\tsection的值有四种情况，节索引号、ABS、UNDEF、COM\n\n+   section=节索引号\n\n​\t\t\t\t说明符号所对应的空间在哪个节里面。\n\n+   section=ABS\n\n​\t\t\t\t表示该符号不需要被“链接程序”处理。\n\n​\t\t\t\t比如，如果符号名是***.c，这个符号不是全局变量、不是函数，只是一个源文件名而已，链接器（ld/collect2）\t\t\t在链接“可重定位目标文件”时，这个符号不需要被处理。\n\n+   section=UNDEF\n\n​\t\t\t\t表示这个符号，只是在本模块中被引用了，这个符号并不是由本模块定义的，表示这个符号被定义在了其它模块\t\t\t中，链接时要到其它模块中去找搜寻它的定义。\n\n+   section=COM\n\n    表示还未被分配空间（位置）的未初始化的数据目标，比如未初始化的全局变量(.bss)。\n\n​\t.symtab 所记录的符号，严格说起来就两种：\n\n1.   全局符号（由extern修饰的全局变量或函数）\n     +   在本地文件声明，在其他文件中被引用\n     +   在其他文件声明，在本地文件中被引用\n2.   本地符号（由static修饰的静态变量或函数）\n     +   在本地文件声明，且只能在本模块中使用\n\n\n\n---\n\n#### .rel.text Section 及 .rel.data Section\n\n​\t用于多个.o文件链接在一起时，需要根据这两个节中的重定位信息，将各个文件中的 .text节 与 data节分别整合 \n\n#### .debug Section 及 .line Section\n\n​\t前者存放调试信息，后者存放代码行号信息，编译时需要加入 -g 选项后，才会在这两节中存放相关调试信息\n\n```sh\ngcc -g main.c -o main\n```\n\n#### .strtab Section\n\n​\t字符串表，挨个存放：\n\n+   .symtab 所用的符号名字\n+   .debug 所用到的符号名字\n+   每个节的段名\n+   源文件名字\n+   等等\n\n#### Section Header Table\n\n```c\ntypedef struct\n{\n  Elf32_Word sh_name; /* Section name (string tbl index) */\n  Elf32_Word sh_type; /* Section type */\n  Elf32_Word sh_flags; /* Section flags */\n  Elf32_Addr sh_addr; /* Section virtual addr at execution */\n  Elf32_Off sh_offset; /* Section file offset */\n  Elf32_Word sh_size; /* Section size in bytes */\n  Elf32_Word sh_link; /* Link to another section */\n  Elf32_Word sh_info; /* Additional section information */\n  Elf32_Word sh_addralign; /* Section alignment */\n  Elf32_Word sh_entsize; /* Entry size if section holds table */\n} Elf32_Shdr;\n```\n\n```sh\nreadelf -S main.o\n```\n\n\n\n1.   节名称\n\n2.   节的类型\n\n3.   节的属性（读写权限）\n\n4.   节在ELF文件中所占的长度\n\n5.   节的对齐方式\n\n6.   偏移量\n\n---\n\n### ELF格式可执行目标文件\n\n![ELF和sectionheadertable(节头表)](https://img-blog.csdnimg.cn/img_convert/494d134bb25941bf46aba57ba98b4f5c.png)\n","source":"_posts/汇编语言.md","raw":"---\ntitle: 汇编语言\ntags:\n  - 汇编语言\ncategories:\n  - 计算机底层\nabbrlink: 8e41db39\ndate: 2022-09-08 21:27:48\n---\n\n# 汇编知识\n\n#### 汇编语言的组成\n\n1.   汇编指令：机器码的助记符，有对应的机器码\n2.   伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行\n3.   其他符号：由编译器识别，没有对应的机器码\n\n#### 8086PC 内存地址分配\n\n8086PC 具有宽度为20的地址总线，宽度为16的数据总线\n\n00000 ~ 9FFFF     主存储器RAM\n\nA0000 ~ BFFFF    显存地址\n\nC0000 ~ FFFFF    各类ROM\n\n#### Debug程序\n\n+   -u : check a memory segment in assembly way    以数据的形式查看一段内存\n+   -d : check a memory segment in data way             以代码的形式查看一段内存\n+   -e : edit a memory segment                    编辑一段内存地址，使用空格进行后移                   \n+   -a : input a series of assembly code              默认在cs:ip位置处编写一段汇编代码，可指定其他内存位置\n+   -r : check all registers or update a register       查看所用通用寄存器或者修改某寄存器的值\n+   -t : debug a programme step by step with going into sub programme          单步调试，进入子程序\n+   -p : debug a programme step by step without going into sub programme      单步调试，不进入子程序，跳过循环\n+   -n : rename a file           文件重命名\n+   -g : don't stop executing the programme until the target address you set comes           运行程序到你设定的地址\n\n## 通用寄存器\n\n​\t是CPU内部的存储器，是用来暂存计算数据及结果，是程序员可以进行操纵的空间，通过操纵寄存器进而达到操纵CPU的目的\n\n对于8086CPU来说，总共有14个\n\n### 数据寄存器\n\n其中通用寄存器有4个{AX，BX，CX，DX}，用来存放数据，每一个通用寄存器是由高低两个8位寄存器组成的16位寄存器{AX = AH + AL}；\n\n>EAX : 32位寄存器                  RAX : 64位寄存器 \n>\n>EAX 位于 RAX 的低32位\n>\n>AX 位于 EAX 的低16位\n\n进行8位运算时，两个8位寄存器互不影响，不进位不借位，进位值与借位值存在标志寄存器的**CF标志位**中\n\n进行16位运算时，  高位溢出舍弃\n\n#### MOV & ADD & SUB 指令\n\n```assembly\nmov ax,bx      ; 将ax中的数据与bx相加后结果送入ax\nmov ax,5FC5    ; 将ax的值改为5fc5\nmov al,bh      ; 将ax的低8位的值改为bx高8位的值\nadd ax,05A6    ; ax的值加上05a6后，送入ax中\nadd bh,al      ; 将bx的高8位加上ax的低8位\nsub ax,ax      ; 减法运算\n```\n\n### 地址寄存器\n\n+   段地址寄存器\n\n    {CS，DS，SS，ES} = {代码段，数据段，堆栈段，其他段}\n\n+   偏移地址寄存器\n\n    {SP，BP，SI，DI，IP，BX} = {，，，，指令指针，}\n\n+   设计目的\n\n    8086CPU地址总线宽度为20，而寄存器位长16，那么就需要用两个寄存器来存一个物理地址\n\n```mathematica\nPhysicalAddr = SegmentAddr * 10h + OffsetAddr\n```\n\n### CS : IP 代码段\n\n>   代码段寄存器 : 指令指针寄存器\n\nCPU将CS:IP指向的内存单元中的内容当做代码执行 \n\n指令执行过程：\n\n```tex\n1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲区\n2. IP = IP + Length(Instruction) 从而指向下一条指令的地址\n3. 执行指令，转到步骤 1\n```\n\n在8086CPU加电启动或复位后，CS被置为FFFFH，IP被置为0000H\n\n#### JMP 指令\n\n转移指令，修改CS:IP的值\n\n```assembly\njmp 2000:0010    ; 修改CS为2000，修改IP为0010\njmp ax           ; 修改IP为AX中存储的值\n```\n\n### DS : [Offset] 数据段\n\n>   数据段寄存器 : [偏移地址]\n\nCPU将DS:[Offset]指向的内存地址中的内容当做数据读写（<u>**需要注意小端序还是大端序**</u>）\n\n```assembly\nmov bx,3001\nmov ds,bx         ; 将BX中存储的段地址送入DS数据段寄存器中，8086不允许使用MOV指令直接给段寄存器赋值\nmov ax,[0101]     ; 将内存中地址为 DS * 10h + 0101h 中的数据送入AX中\nmov [0102],ax     ; 将AX中的数据送入到内存地位为 DS * 10h + 0102h 的地方\n```\n\n### SS : SP 堆栈段\n\n>   堆栈段寄存器 : 栈顶指针寄存器\n\n8086CPU的入栈操作和出栈操作都是以**字**为单位进行的；入栈时，栈顶由高地址向低地址的方向增长(小端序)\n\n#### PUSH & POP 指令\n\n出栈 & 入栈\n\n```assembly\n;指定栈顶界限，假定栈段范围为10000 ~ 1001F\nmov ax,1000\nmov ss,ax\n;设置栈顶指针,空栈时,栈顶指针指向栈底后一位地址\nmov sp,0020\n;入栈：\n;\tSP = SP - 2       \nmov bx,3FFF\npush bx\npush ds\npush [0]\n;出栈：\n;\tSP = SP + 2\npop [0]\npop ds\npop bx\n```\n\n**当执行修改SS堆栈段寄存器的值时，下一条指令也会紧接着执行**\n\n## 源代码\n\n```assembly\nassume cs:code,ds:data,ss:stack\n\n; 数据段\ndata segment\ndate ends\n; 堆栈段\nstack segment stack\nstack ends\n; 代码段\ncode segment\n\t\n\tmov ax,4500H\n\tmov ds,ax\n\tmov ax,1000H\n\tmov ss,ax\n\tmov sp,0020H\n\t\n\tmov ax,0D200H      ; 在汇编源程序中，数据不能以字母开头，若最高位＞9时，需要在前面补0\n\tmov ds:[0],ax\n    push ds:[0]\n    pop bx\n    mov ds:[2],bx\n\t\n\t; 返回上级程序\n\tmov ax,4c00H\n\tint 21H\ncode ends\n\nend\n```\n\n## [BX] & LOOP 指令\n\n```assembly\nmov bx,0010H   \nmov ax,50F0H\nmov ds:[bx],ax   ; 将bx寄存器中的数据当做地址偏移量\n```\n\n​\t\tCX寄存器中的值可作为loop指令循环次数，每次减一，知道减为零结束循环\n\n```assembly\nassume cs:code\ncode segment\n\tmov ax,1000H\n\tmov ds,ax\n\tmov bx,5H\n\t\n\tmov al,ds:[bx]\n\tmov ah,0H\n\tmov dx,0H\n\t\n\tmov cx,5            ; 初始化循环次数\ns: \tadd dx,ax           ; 定义循环体\n\tloop s              ; 开始循环\n\t\n\tmov ax,004cH\n\tint 21H\ncode ends\nend\n```\n\n综合运用[bx]&loop\n\n### INC 指令\n\n​\t数值自增一\n\n### DEC 指令\n\n​\t数值自减一\n\n```assembly\n; \t计算从10000H ~ 1000aH地址中所有数值的和，储存在dx中\n\t\n\tmov ax,1000H\n\tmov ds,ax\n\tmov bx,0H\n\n\tmov dx,0H\n\tmov cx,0aH\n\ns: \tmov al,ds:[bx]\n\tmov ah,0H\n\tadd dx,ax\n\tinc bx\n\tloop s\n\t\n```\n\n\n\n## DW 伪指令 & start 标号\n\n定义字型数据(define word)，可在代码段中存放提前定义好的数据\n\n**start** 标号用来标识程序的入口，即是初始化CS:IP的值，用 **end** 指令来声明**start**标号的作用（程序入口）\n\n```assembly\nassume cs:code\ncode segment\n\t\n\t; 定义数据\n\tdw 0123H,0a446H,5FF6H\n\t\n\t; 代码\nstart:\tmov bx,0\n\t\tmov ax,0\n\t\tmov cx,3\n\t\t\ns:\t\tadd ax,cs:[bx]\n\t\tadd bx,2H\n\t\tloop s\n\t\n\t\tmov ax,4c00H\n\t\tint 21H\ncode ends\nend start\n```\n\n### 分段\n\n​\t将数据、代码、栈三段分立，方便管理\n\n```assembly\nassume cs:code,ds:data,ss:stack\n\ndata segment\n\tdw 0123H,0456H,0789H,0abcH,0defH\ndata ends\n\nstack segment stack\n\tdw 0H,0H,0H,0,0,0,0\nstack ends\n\ncode segment\nstart:\t\n\t\tmov ax,data\n\t\tmov ds,ax         ; 分配数据段\n\t\tmov ax,stack\n\t\tmov ss,ax         ; 分配栈段\n\t\tmov sp,0eH\n\t\t\n\t\tmov ax,4c00H\n\t\tint 21H\ncode ends\n\nend start\n\t\t\n```\n\n## 地址定位与数据处理\n\n### AND & OR 指令\n\n​\t二进制逻辑与或运算\n\n### XOR 指令\n\n​\t异或运算，常用于main函数设置返回值0\n\n```assembly\nxor eax,eax     ; 该命令执行速度比 mov ax,0 要快\n```\n\n### 字符串型数据 & DB 伪指令\n\n```assembly\ndata segment\n\tdb 'string'\ndata ends\n; low -> up\nor al,00100000\n; up -> low\nand al,11011111\n```\n\n### 灵活定位 & DI & SI & BP\n\n```assembly\nmov ax,ds:[bx+100]\nmov ax,ds:[bx+di]\nmov ax,ds:[bx][si]\nmov ax,ds:[bx+si+100]\nmov ax,ds:[bx][si].100\nmov ax,ds:[bp+si+100]\nmov ax,ds:[bp][si].100\n```\n\nSI & DI ：16位寄存器，无法分割为两个8位寄存器\n\nBP：[见此处](#BP寄存器)\n\n\n\n### X PTR\n\n**指明数据长度的方式**：\n\n+   通过寄存器名指明数据长度\n\n    ```assembly\n    mov ax,1H\n    mov al,1H\n    ```\n\n    \n\n+   通过操作符 X PTR 指明数据长度\n\n```assembly\nmov word ptr ds:[0],1H\nmov byte ptr ds:[2],1H\nmov byte ptr ds:[bx+si+10],'F'\n```\n\n### DIV 指令\n\n1.   除数：在寄存器或内存\n2.   被除数：默认在AX或DX\n     +   除数为8位，被除数为16位，则被除数放在AX\n     +   除数为16位，被除数为32位，则被除数在DX与AX，DX放高位，AX放低位\n3.   结果：\n     +   若除数为8位，则al存放商，ah存放余数\n     +   若除数为16位，则ax存放商，dx存放余数\n\n```assembly\n; 计算 100001 / 100\n; 100001 => 186a1H\nmov dx,1H\nmov ax,86a1H\nmov word ptr ds:[bx+si+10],100\ndiv word ptr ds:[bx+si+10]\n```\n\n### DD 伪指令\n\n用来定义DWORD（double word）双字型数据\n\n### DUP 伪指令\n\n与db、dw、dd等数据定义伪指令配合使用，进行重复数据的定义\n\n+   db 重复次数 dup (被重复的字节型数据)\n+   dw 重复次数 dup (被重复的字型数据)\n+   dd 重复次数 dup (被重复的双字型数据)\n\n```assembly\ndb 3 dup ('12')    ;   db '121212'\ndb 5 dup (10H)     ;   db 10h,10h,10h,10h,10h\ndw 2 dup (5f5fH)   ;   dw 5f5fH,5f5fH\ndd 2 dup(12H)      ;   dd 00000012H,00000012H\n```\n\n## JMP指令原理\n\n### OFFSET 伪指令\n\n取得标号的偏移地址，**不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编**\n\n``` assembly\ncode segment\nstart:\t\n\t\tmov ax,offset start\n```\n\n### JMP指令的用法\n\n1.   数值指明目的地址\n\n     +   同时修改cs : ip\n\n         ```assembly\n         jmp 1000:0000\n         ```\n\n2.   段内短转移（机器码中不出现目的地址，只出现相对位移，**<u>==该相对位移在编译时确定==</u>**）\n\n     转移位移为8位，-128,127\n\n     ```assembly\n     code segment\n     s:\n     \tmov ax,10H\n     \tjmp short s          ; 使用相对距离差修改ip的值，ip = ip + (标号地址 - jmp后下一条指令初地址) \n     \tmov bx,11H\n     ```\n\n3.   段内近转移\n\n     转移位移为16位，-32768,32767（机器码中不出现目的地址，......同短转移）\n\n     ```assembly\n     code segment\n     s:\n     \tmov ax,10H\n     \tjmp near ptr s\n     \tmov bx,11H\n     ```\n\n4.   段间转移（远转移）\n\n     同时修改CS:IP，cs = 标号所在段的段地址，ip = 标号在所在段的偏移地址\n\n     ```assembly\n     acode segment\n     sa:\n     \tmov ax,10H\n     \tjmp far ptr sb\n     acode ends\n     \n     bcode segment\n     sb:\n     \tmov bx,11H\n     bcode ends\n     ```\n\n     \n\n5.   转移地址在寄存器中\n\n     ```assembly\n     mov ax,10F1H\n     jmp ax\n     ```\n\n     \n\n6.   转移地址在内存中\n\n     +   内存单元中存有一个字型数据，即为目的地址的偏移地址（段内转移但非近转移）\n\n         ```assembly\n         mov ax,1000H\n         mov ds:[1],ax\n         jmp word ptr ds:[1]\n         ```\n\n     +   内存单元中存有一个双字型数据，高位为目的地址的段地址，低位为偏移地址（段间转移）\n\n         ```assembly\n         mov ax,1000H\n         mov ds:[0],ax\n         mov word ptr ds:[2],0H\n         jmp dword ptr ds:[0]\n         ```\n\n### 有条件转移指令\n\n所有的条件转移指令都是短转移，在对应机器码中不出现目的地址，只出现相对位移，在编译时确定\n\n+   jcxz 指令\n\n    功能上等同于在段内短转移之前判断CX是否等于0，若cx == 0，则跳转，若cx != 0，则不跳转\n\n+   loop 指令\n\n    本质上也是条件转移指令，条件与jcxz相反，且伴随着cx的递减\n\n+   检测比较结果的条件转移指令（根据**<u>==无符号数==</u>**的比较结果进行转移）\n\n    | 指令 |     含义     |      相关标志位      |\n    | :--: | :----------: | :------------------: |\n    |  JE  |  等于则转移  |        ZF = 1        |\n    | JNE  | 不等于则转移 |        ZF = 0        |\n    |  JB  |  低于则转移  |        CF = 1        |\n    | JNB  | 不低于则转移 |        CF = 0        |\n    |  JA  |  高于则转移  |  CF = 0  &&  ZF = 0  |\n    | JNA  | 不高于则转移 | CF = 1  \\|\\|  ZF = 1 |\n\n    \n\n```assembly\njcxz 标号\n```\n\n\n\n## 栈操作\n\n### RET & RETF 指令\n\nret：用栈中的数据修改ip的内容，实现近转移\n\n```assembly\nret \n====>   \npop ip\n```\n\nretf：用栈中的数据修改 cs : ip，实现远转移\n\n```assembly\nretf \n====>\npop ip\npop cs\n====>\nmov bx,sp\njmp dword ptr ss:[bx]\nadd sp,4\n```\n\n### CALL 指令\n\ncall：将当前 ip 或 cs : ip 压入栈中，再转移\n\n+   进行近转移的call指令\n\n    ```assembly\n    call fun     ; fun 为本段内某标号\n    ====>\n    push ip\n    jmp near ptr fun\n    ```\n\n+   进行远转移的call指令\n\n    ```assembly\n    call far ptr fun     ; fun 为非本段内某标号\n    ====>\n    push cs\n    push ip\n    jmp far ptr fun\n    ```\n\n+   目的地址在寄存器的call指令\n\n    ```assembly\n    call ax      \n    ====>\n    push ip\n    jmp ax\n    ```\n\n+   目的地址在内存中的call指令\n\n    ```assembly\n    call word ptr ds:[bx]              ; 段内转移\n    ====>\n    push ip\n    jmp word ptr ds:[bx]\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    call dword ptr ds:[bx]             ; 段间转移（远转移）\n    ====>\n    push cs\n    push ip\n    jmp dword ptr ds:[bx]\n    ```\n\n### BP寄存器\n\n+   当没有显式指出段地址且偏移量寄存器使用bp时，则段地址默认为SS寄存器中的值，无法分割bp为基址寄存器\n+   和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到\n+   一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：\n\n```assembly\n;在函数进入时:\npush bp     ;\t保存bp指针\nmov bp,sp \t;\t将sp指针传给bp，此时bp指向sp的基地址。\n\n;;;;   函数体   ;;;;\n\nmov sp,bp   ;\tsp回到栈顶\npop bp      ;\tbp恢复初始值\nret         ; \t函数返回\n```\n\n### 参数压栈\n\n​\t调用某些带有参数的函数时，先按参数顺序将参数压栈(参数位于栈高位)，然后再执行**CALL**命令将CS:IP压栈(CS:IP位于栈低位)\n\n### LEA 指令\n\n​\tLEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。\n\n```assembly\nmakeArray PROC\n    push ebp\n    mov ebp,esp\n    sub esp, 32            ;myString 位于 EBP-30 的位置\n    lea esi, [ebp-30]      ;加载 myString 的地址\n    mov ecx, 30            ;循环计数器\nLI: mov BYTE PTR [esi]     ;填充一个位置\n    inc esi                ;指向下一个元素\n    loop LI                ;循环，直到 ECX=0\n    add esp, 32            ;删除数组(恢复ESP)\n    pop ebp\n    ret\nmakeArray ENDP\n```\n\n\n\n### MUL 指令\n\n+   两数相乘，要么都是8位，要么都是16位\n+   若是8位，一个默认在AL，另一个在8位寄存器或内存，结果在AX\n+   若是16位，一个默认在AX，另一个在16位寄存器或内存，高位在DX，低位在AX\n\n### 寄存器冲突问题\n\n若计数器寄存器 CX 另有用途，无法存放循环次数，那么可以用 jmp 与 jcxz 指令配合代替loop指令，实现有限循环\n\n---\n\n## 标志寄存器\n\n### 作用\n\n+   用来存储相关指令的某些执行结果\n+   用来为CPU执行相关指令提供行为依据\n+   用来控制CPU的相关工作方式\n\n>   8086CPU的标志寄存器时16位寄存器，其信息是按起作用，每一个位存储的信息通常被称为程序状态字(PSW)\n\n|  15  |  14  |  13  |  12  |  11  |  10  |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|      |      |      |      |  OF  |  DF  |  IF  |  TF  |  SF  |  ZF  |      |  AF  |      |  PF  |      |  CF  |\n\n### ZF 标志\n\n+   位于第  **==6==** 位\n+   零标志位，记录相关指令执行后，其结果是否为0，若为 ==0== 则ZF = 1，否则ZF = 0；\n+   在8086CPU指令集中，add、sub、mul、div、inc、or、and 等运算指令一般影响ZF\n\n### PF 标志\n\n+   位于第 **==2==** 位\n+   奇偶标志位，记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若 ==偶== 则 ==1==，若 ==奇== 则 ==0==\n\n### SF 标志\n\n+   位于第 **==7==** 位\n+   符号标志位，记录相关指令执行后，其结果是否为负，若 ==负== 则 ==1==，若 ==非负== 则 ==0==\n\n### CF 标志\n\n+   位于第 **==0==** 位\n+   进位标志位，一般情况下，在进行 <u>无符号数</u> 运算的时候，记录了运算结果的最高有效位向更高位的进位值，或借位值\n\n### OF 标志\n\n+   位于第 **==11==** 位\n+   CPU在进行 <u>有符号数</u> 运算时，若溢出则为 1 ，若未溢出，则为 0 \n\n### ADC 指令\n\nadc指令是带进位的加法指令，利用了CF标志位\n\n```assembly\nadc ax,bx    ;  ax = ax + bx + CF\n```\n\n### SBB 指令\n\nsbb指令是带借位减法指令，同样利用了CF标志位\n\n```assembly\nsbb ax,bx    ; ax = ax - bx - CF\n```\n\n### CMP 指令\n\ncmp是比较指令，功能上相当于减法指令，但不保存结果，只影响相关标志位的值\n\n```assembly\nmov ax,3\nmov bx,4\ncmp ax,bx\n; 相当于执行减法，执行后 ZF = 0，PF = 1，SF = 1,CF = 1,OF = 0\n```\n\n+   ZF = 1  ==>  ax == bx\n+   ZF = 0  ==>  ax != bx\n+   CF = 1  ==>  ax < bx\n+   CF = 0  ==>  ax >= bx\n\n### TEST 指令\n\ntest 对两个操作数进行逻辑（按位）与操作，功能上与and指令类似，但不保存结果，只影响相关标志位的值\n\n```assembly\n; 检查ax的最高位是否为 1\ntest ax,10000000b\nje isNotOne      ; 最高位是 0\njne isOne\t\t ; 最高位是 1\n```\n\n\n\n### 与标志位相关的条件转移指令\n\n[详细见此处](#有条件转移指令)\n\n### DF 标志 & 串传送指令\n\n+   DF 标志位于第 ==10== 位\n+   方向标志位，在串处理指令中，控制每次操作后 SI 与 DI 的增减\n+   若 DF = 0，则每次操作后 SI & DI 递增\n+   若 DF = 1，则每次操作后 SI & DI 递减\n\n#### MOVSB 指令\n\nmovsb 指令功能是将ds:si指向的内存单元中的一个字节型数据送入es:di；相当于:\n\n```assembly\n; if DF = 1\nmov es:[di],byte ptr ds:[si]\ndec si\ndec di\n\n; if DF = 0\nmov es:[di],byte ptr ds:[si]\ninc si\ninc di\n```\n\n#### MOVSW 指令\n\nmovsw 指令与 movsb 指令类似，只是把字节型数据改为字型数据，si 与 di 每次变化两个单位\n\n#### 与 REP 的配合\n\n上述两种指令都需要与 rep 相配和，实现数据从 DS段 **连续**传送到 ES段 中，本质是由loop循环的实现，循环次数由 CX 的值决定\n\n``` assembly\nrep movsb\n====>\ns: \n\tmovsb\n\tloop s\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nrep movsw\n====>\ns: \n\tmovsw\n\tloop s\n```\n\n#### CLD & STD 指令\n\n+   sld 指令：将DF置 0，实现 si 与 di 的自增\n+   std 指令：将DF置 1，实现 si 与 di 的自减\n\n### PUSHF & POPF 指令\n\npushf的功能是将标志寄存器中的值压栈，而popf是将栈中的数据弹出并送入标志寄存器中\n\n### 标志寄存器在Debug中的表示\n\n| 标志 | 置一 | 置零 |\n| :--: | :--: | :--: |\n|  OF  |  OV  |  NV  |\n|  SF  |  NG  |  PL  |\n|  ZF  |  ZR  |  NZ  |\n|  PF  |  PE  |  PO  |\n|  CF  |  CY  |  NC  |\n|  DF  |  DN  |  UP  |\n\n---\n\n\n\n## 内中断\n\n\n\n# 32位逆向\n\n## 小端序&大端序\n\n地址高位存数据高位 ===》 小端序\n\n地址高位存地址低位 ===》 大端序\n\n## IA-32寄存器\n\n### 基本程序运行寄存器\n\n+   通用寄存器{EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP}\n+   段寄存器{CS，DS，SS，ES，FS，GS}\n+   程序状态与控制寄存器{EFLAGS}\n+   指令指针寄存器{EIP}\n\n>Tips:\n>\n>1.   EAX一般用于函数返回值中，所有Win32 API函数都会先把返回值保存在EAX中再返回\n>2.   ES，FS，GS：附加数据段\n\n## 栈帧\n\n+   cdecl：调用者负责清理栈中的参数\n+   stdcall：被调用者负责清理栈中的参数\n\n## PE文件格式\n\n<img src=\"https://img-blog.csdnimg.cn/20201210163828181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nX2Nt,size_16,color_FFFFFF,t_70\" alt=\"img\" style=\"zoom:100%;\" />\n\n### DOS 头\n\n```c\n//注释掉的不需要重点分析\nstruct _IMAGE_DOS_HEADER{\n    0X00 WORD e_magic;      //※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件\n    //0X02 WORD e_cblp;     //Bytes on last page of file\n    //0X04 WORD e_cp;       //Pages in file\n    //0X06 WORD e_crlc;     //Relocations\n    //0X08 WORD e_cparhdr;  //Size of header in paragraphs\n    //0X0A WORD e_minalloc; //Minimun extra paragraphs needs\n    //0X0C WORD e_maxalloc; //Maximun extra paragraphs needs\n    //0X0E WORD e_ss;       //intial(relative)SS value\n    //0X10 WORD e_sp;       //intial SP value\n    //0X12 WORD e_csum;     //Checksum\n    //0X14 WORD e_ip;       //intial IP value\n    //0X16 WORD e_cs;       //intial(relative)CS value\n    //0X18 WORD e_lfarlc;   //File Address of relocation table\n    //0X1A WORD e_ovno;     //Overlay number\n    //0x1C WORD e_res[4];   //Reserved words\n    //0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)\n    //0x26 WORD e_oeminfo;  //OEM information;e_oemid specific\n    //0x28 WORD e_res2[10]; //Reserved words\n    0x3C DWORD e_lfanew;    //※Offset to start of PE header:定位PE文件，NT头相对于文件的偏移量\n};\n```\n\ne_magic : 固定为 ‘MZ’\n\ne_lfanew：NT头的文件偏移位置\n\n### DOS stub\n\n​\t由代码与数据混合而成，大小不固定，可没有，可存储在16位汇编指令，在dos环境下运行\n\n### NT 头\n\n```c\n//x86\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;                       // 文件头\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      \t   // 可选头\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n\n//x64\ntypedef struct _IMAGE_NT_HEADERS64 {\n    DWORD Signature;\n    IMAGE_FILE_HEADER FileHeader;\n    IMAGE_OPTIONAL_HEADER64 OptionalHeader;\n} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;\n```\n\nSignature: 签名，50450000H ===>  \"PE00\"\n\n### NT ：文件头\n\n```c\n//x86 x64相同\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine;                           // 运行平台  \n    WORD    NumberOfSections;\t\t\t\t// 节的数量\n    DWORD   TimeDateStamp;\t\t\t\t\t// 时间戳\n    DWORD   PointerToSymbolTable;\t\t\t// 符号表指针\n    DWORD   NumberOfSymbols;\t\t\t\t// 符号数量\n    WORD    SizeOfOptionalHeader;\t\t\t// 可选头大小\n    WORD    Characteristics;                 // 文件属性\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\n+   Machine：\n    +   0x014cH\tx86\n    +   0x0200H    Intel 64\n    +   0x8664H    x64\n\n+   Characteristics:\n    +   0x0002H\t可执行文件\n    +   0x2000H    动态链接库\n    +   0x1000H    系统文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 编译过程\n\n<img src=\"https://img-blog.csdn.net/20170611205306090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFpZGUyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"C_complie\" style=\"zoom:125%;\" />\n\n## 预处理\n\n- 使用程序\n\n    ​\t**cpp.exe**\n\n    ```sh\n    gcc -E main.c -o main.i\n    ```\n\n- 作用\n\n    1. 宏替换\n    2. 包含头文件\n    3. 条件编译\n    4. 处理预处理关键字\n\n- 结果\n\n    ​\t扩展的c源码，生成扩展名为 ‘.i ’ 的ASCII文件\n\n    ---\n\n## 编译\n\n- 使用程序\n\n    ​\t**cc1.exe**\n\n    ```sh\n    gcc -S main.i\n    ```\n\n- 结果\n\n    ​\t将c源码翻译为汇编源码，生成扩展名为 ‘ .s ’的ASCII文件\n\n    ​\t\n\n    ---\n\n## 汇编\n\n- 使用程序\n\n    ​\t**as.exe**\n\n    ```sh\n    gcc -c main.s\n    ```\n\n- 结果\n\n    ​\t将汇编源码翻译为二进制代码，生成扩展名为 ‘ .o’ 的二进制文件 \n\n- 注意\n\n    ​\t无法直接运行，需要链接（*单个文件也需要链接*）\n\n    ---\n\n## 链接\n\n- 使用程序\n\n    ​\t**collect2.exe** / **ld.exe**  （静态链接器）\n\n    ```sh\n    gcc main.o -o main\n    ```\n\n- 作用\n\n    1. 将众多.o文件合成为一个完整的可执行文件\n    2. 链接时，需要加入由编译器提供的启动代码，来调用main函数\n    3. 链接时，需要进行符号解析与地址重定位\n\n- 结果\n\n    ​\t在Windows环境下生成‘.exe’ 文件，在linux环境下没有固定扩展名\n\n### 静态链接\n\n- 定义\n\n    ​\t在编译时完成的链接，调用 **ld** / **collect2** 链接程序，将所有.o文件整合\n\n- 缺点\n\n    ​\t重复代码较多，浪费计算机资源\n\n- 具体过程\n\n    1.  符号解析\n\n         +  作用\n\n            ​\t符号解析的目的是将符号的引用与符号的定义练习起来（如：函数的声明与实现）\n\n         +  实现\n\n            ​\t在每一个.o文件中都会包含一张符号表(.symtab)，用来记录：\t\t\n\n            ​\t\t\n\n            ```tex\n            （1） 本模块定义了哪些符号\n            （2） 本模块引用了哪些符号\n            ```\n\n            ​\t\t\n\n         +  注意\n\n            ​\t单个.c文件即为一个模块，整个工程以模块为单位进行组织\n\n            ​\t\n\n    2.  地址重定位\n\n         +  作用  \n\n            ​\t将.o文件中的每个机器指令的逻辑地址，重定位为实际运行的地址\n\n            ```tex\n            1. 如果是裸机运行的，运行的地址就是内存的物理地址\n            2. 如果是基于OS运行的，运行地址就是虚拟内存的地址\n            ```\n\n         +  逻辑地址\n\n            ​\t在每个节中，从零开始标号\n\n         +  虚拟地址\n\n            1. 在32位Linux操作系统下，虚拟地址为32位，从<u>0x08048000</u>开始\n                \t2. 在64位Linux操作系统下，虚拟地址为64位，从0x00000000000400000开始\n\n### 动态链接\n\n+ 定义\n\n    ​\t在编译时只留下调用接口，当程序真正运行起来的时候，才去链接执行\n\n+ 使用时机\n\n    ​\t使用动态链接库（DLL）时\n\n    ​\t如printf函数由动态链接库提供，程序编译后，代码中不存在printf函数代码，只有其接口，当程序运行时，再去动态链接其所在的DLL，这里的接口是二进制代码，实质为该函数第一条指令的地址(相对地址 + 绝对地址)\n\n    ```\n    相对地址: 某成员在DLL中的相对位置； 绝对地址: DLL被加载到内存中后的物理地址\n    ```\n\n    \n\n+ 动态链接器。。。\n\n+ 链接过程与优点\n\n    ​\t程序运行时，将**<u>整个</u>**DLL加载到内存之中，内存中所有相关进程共享该DLL的代码，减少了代码的冗余，提高了计算机空间资源的利用率\n\n    > 因为DLL并不知道用户的程序需要该库中哪个变量或函数，所以需要将其完整加载到内存中\n\n---\n\n# 目标文件\n\n## 目标文件类型\n\n### \t可重定位目标文件\n\n  + 定义\n\n​\t被用于静态链接的文件，都是看重定位目标文件\n\n```tex\n什么是可重定位？\n\t因为采用静态链接，逻辑地址需要被重定位为运行地址后才能被运行\n```\n\n+ 类型\n\n    ​\t以‘‘**.a 、.lib**’’ 为扩展名的静态库文件以及以‘‘ **.o** ’’为扩展名的二进制文件都是<u>可重定位目标文件</u>\n\n\n### \t可执行目标文件\n\n​\t\t就是可执行的文件\n\n### \t共享目标文件\n\n​\t\t本质就是动态库文件DLL，DLL也被称为共享库\n\n---\n\n## 目标文件格式\n\n\t### 裸机（无OS）\n\n​\t“ .bin ” 文件格式，直接运行在**arm**裸机上\n\n### UNIX系统\n\n 1.  早期unix操作系统\n\n     ​\t使用“ **.out**  ” 文件格式，在UNIX操作系统上编译程序后，若不指定可执行文件名，会默认命名为 “ a.out ”\n\n 2.  system V unix\n\n     ​\ta.out 文件格式变为 **COFF** ( Common Object File Format : 一般目标文件格式) \n\n 3.  线代Unix\n\n     ​\t改用 **ELF**（Executable and Linkable Format：可执行、可链接格式）\n\n### Windows系统\n\n​\t采用 **PE** （Portable Executable：可移植、可执行格式）\n\n```tex\n这里的可移植并非指PE格式文件可跨平台执行，而是指兼容多种语言\n```\n\n### Linux系统\n\n​\t与现代Unix相同，与使用**ELF**格式，linux操作系统脱胎于unix，因此在linux操作系统编译得到的可执行文件上也默认命名为“ a.out ”，但是文件格式与早期Unix并不一致\n\n```tex\n如何理解ELF（可执行、可链接）的含义？\n1. 可重定位目标文件、共享目标文件：可以被链接\n2. 可执行目标文件：能被执行\n```\n\n### ELF格式可重定位目标文件\n\n#### 组成结构图\n\n<img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo10%2Fcd31ce13972e4a6a82284b1b07faabae.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647693494&t=81dd5f93e3a64f75b1a77e522cad6df5\" alt=\"点击查看图片来源\" style=\"zoom: 67%;\" />\n\n#### ELF Header\n\n```shell\n使用 readelf -h 查看elf头信息\nreadelf -h file\n```\n\n![img](file:///C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\956489228\\QQ\\WinTemp\\RichOle\\YQZ8(L~D)SSOQ65HK]0YTDS.png)\n\n```c\ntypedef struct {\n  unsigned char e_ident[16];        /* ELF \"magic number\" */\n  unsigned char e_type[2];      /* Identifies object file type */\n  unsigned char e_machine[2];       /* Specifies required architecture */\n  unsigned char e_version[4];       /* Identifies object file version */\n  unsigned char e_entry[4];     /* Entry point virtual address */\n  unsigned char e_phoff[4];     /* Program header table file offset */\n  unsigned char e_shoff[4];     /* Section header table file offset */\n  unsigned char e_flags[4];     /* Processor-specific flags */\n  unsigned char e_ehsize[2];        /* ELF header size in bytes */\n  unsigned char e_phentsize[2];     /* Program header table entry size */\n  unsigned char e_phnum[2];     /* Program header table entry count */\n  unsigned char e_shentsize[2];     /* Section header table entry size */\n  unsigned char e_shnum[2];     /* Section header table entry count */\n  unsigned char e_shstrndx[2];      /* Section header string table index */\n} Elf32_External_Ehdr;\n```\n\n##### **e_ident**\n\ne_ident 是一个包含 16 字节的数组成员，对应 readelf -h 给出的 magic 部分.\n\nmagic 部分就是我们所说的魔数，魔数通常就是自定义的识别码，对于 32 位的 elf 文件而言，magic 部分有 16 个字节.\n\n大部分的文件组织形式都是这样的，头部是一串特殊的识别码，标识该文件的一些概要信息，主要用于外部程序快速地对这个文件进行识别，快速地判断文件类型.\n\n但是 readelf 命令仅仅是显示了对应的二进制码，并没有进一步显示整个魔数字段的详细信息，关于这一部分就需要参考 readelf 源码来进行分析了，分析结果如下:\n\n-   前四个字节:7f 45 4c 46，识别码， 0x45，0x4c，0x46 三个字节的 ascii 码对应 ELF 字母，通过这四个字节就可以判断文件是不是 elf 文件.\n-   第五个字节:其中 01 表示 32 位 elf 文件，02 表示 64 位.\n-   第六个字节:其中 01 表示 小端模式，02 表示 大端模式.\n-   第七个字节:表示 EI_version，1 表示 EV_CURRENT，只有 1 才是合理的(代码中是 EI_versoin，但是博主没有进一步具体研究).\n-   第八个字节: 00 表示 OS_ABI\n-   第九个字节: 00 表示 ABI version\n-   其它字段，源码中没有找到对应的解析，暂定为reserver.\n\n+ xx\n\n##### e_type\n\ntype 表示 elf 文件的细分类型，总共有四种:\n\n-   可重定位的目标文件\n-   可执行文件\n-   动态链接文件\n-   coredump 文件，这是系统生成的调试文件.\n\n这四种类型的文件各有各的特点，比如可重定位的目标文件针对的是链接器.\n\n而可执行文件针对加载器，需要被静态加载到内存中执行，而动态链接文件则是运行过程中的加载.\n\ncoredump 文件主要保存的是系统出错时的运行断点信息，方便人为地或者借助 gdb 分析 bug.\n\n##### e_machine\n\n标识指定的机器，比如 40 代表 ARM.\n\n其它的比如 x86，mips 等都对应不同的编码.\n\n##### e_version\n\n四个字节的 version code\n\n##### e_entry\n\n程序的入口虚拟地址，对于可重定位的目标文件默认是0，而对于可执行文件而言是真实的程序入口.\n\n程序入口是被加载器使用的，在程序加载过程中会读取该程序入口，作为应用程序的开始执行地址，在实际的加载过程中，内核加载完当前 elf 可执行文件之后其实并不是跳到该入口地址，而是先执行动态链接器代码，在动态链接完成之后才会跳到该入口地址。\n\n##### e_phoff\n\n program header table 的起始偏移地址，\n\n##### e_shoff\n\n section header table 的起始偏移地址，\n\n##### e_flags\n\n和处理器相关的标志位集合，不同的处理器有不同的参数，根据 e_machine 进行解析.\n\n##### e_ehsize\n\n指示 elf header 的 size，对于 arm 而言，52 或者 64.\n\n##### e_phentsize\n\n每一个 program header 的 size，在可重定位目标文件中为 0.\n\n##### e_phnum\n\n该文件中一共有多少个 program header，在可重定位目标文件中为0.\n\n##### e_shentsize\n\n文件中每一个section header 的大小，通常是 40.\n\n##### e_shnum\n\n该文件中一共有多少个 section header，上述的示例文件中为 10 个.\n\n##### e_shstrndx\n\n在 elf 格式的文件中，符号，section，文件的命名通常是字符串，这些字符串并不会保存在其对应的 section 中，而是统一地使用一个字符串表来保存，该字段指示节标题字符串所在的 section，在上面的示例中，section 标题(.text，.data，...)对应的 e_shstrndx 即段序号为 7，即保存在 .shstrtab 段中.这些 section 标题在链接的过程中需要使用到，在程序执行时是无用的，所以分开有利于精简 section 内容的大小，从而程序加载运行时需要更小的空间.\n\n除了 section 标题，还有符号名，文件名等字符串，这些默认会被保存在 .strtab section 中.\n\n```mathematica\nELF文件大小：\nSize = e_shoff + e_shnum * e_shentsize\n```\n\n\n\n#### .text Section\n\n​\t<u>**==只读==**</u> **代码**节，存放所有函数的机器指令即程序代码，有些常量也会与指令一起存放在此节中（如字面量）\n\n```c\nint main()\n{\n    int a = 10;\n    a = a + 100;     // 此处的100会与指令一并存放在该节\n}\n```\n\n#### .rodata Section\n\n​\t**<u>==只读==</u>** **数据**节，存放常量数据（如字符串常量）\n\n```c\nint main()\n{\n    char *str = \"HelloWorld!\";\n    printf(\"%s\",str);        // 这里的“%s” 与 “HelloWorld！”会存放在该节\n}\n```\n\n#### .data Section\n\n​\t<u>**==可写==**</u> **数据**节，存放：\n\n 1.    已初始化的全局变量\n\n       ```c\n       int global = 10;\n       int main(){\n           printf(\"%d\",global + 10);\n       }\n       ```\n\n 2.    已初始化的静态局部变量\n\n       ```c\n       int getCount(char *arr)\n       {\n           static int count = 0;         // 该静态局部变量已被初始化\n           count += strlen(arr);\n           return count;\n       }\n       ```\n\n#### .bss Section\n\n​\t<u>**==可写==**</u> **数据**节\n\n1.   未初始化的全局变量\n\n     ```c\n     int global;\n     int main(){\n         printf(\"%d\",global + 10);\n     }\n     ```\n\n2.   未初始化的静态局部变量\n\n     ```c\n     int getCount(char *arr)\n     {\n         static int count;         // 该静态局部变量未被初始化\n         count = strlen(arr);\n         return count;\n     }\n     ```\n\n     由于.bss节存放没有初始化的数据，所以其并不占有真实地存储空间，.bss 节在可重定位目标文件中只作占位符，当程序真正运行起来时才会在内存中开辟.bss节的空间，并为其中的数据赋上初始值（0）\n\n---\n\n#### .symtab Section\n\n​\t**符号表**（symbol table），用于存放可重定位目标文件中的 **==定义==** 与 **==引用==** 的全局符号信息，包括全局变量、函数.symtab\n\n```sh\nreadelf -s main.o     # 查看符号表\n\ngcc -s main.o -o main      # 编译时剔除符号信息与重定位信息\nstrip main.o   # 丢弃目标文件中的符号\n```\n\n符号表包含很多条目，每个条目记录的就是一个符号的基本信息。\n\n```c\ntypedef struct\n{\n  Elf32_Word    st_name;                /* Symbol name (string tbl index) */\n  Elf32_Addr    st_value;               /* Symbol value */\n  Elf32_Word    st_size;                /* Symbol size */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf32_Section st_shndx;               /* Section index */\n} Elf32_Sym;\n \ntypedef struct\n{\n  Elf64_Word    st_name;                /* Symbol name (string tbl index) */\n  unsigned char st_info;                /* Symbol type and binding */\n  unsigned char st_other;               /* Symbol visibility */\n  Elf64_Section st_shndx;               /* Section index */\n  Elf64_Addr    st_value;               /* Symbol value */\n  Elf64_Xword   st_size;                /* Symbol size */\n} Elf64_Sym;\n```\n\n​\t**1）name**\n\n​\t\t\t\t\tname中记录的并不是名字的字符串，我们前面说过所有的字符串都是放在了.strtab中。name里面只记录字符\t\t\t串在 **.strtab** 中的偏移，通过这个偏移就能在 **.strtab** 中索引到符号的名字。\n\n​\t\t\te.g.\n\n​\t\t\t\tname = 5 //偏移5\n​\t\t\t\t假如.strtab中的内容为main\\0fun2\\0a_va\\0......\n​\t\t\t\t使用偏移5到.strtab中进行搜索，当遇到\\0时就截止，那么取出来的就是符号fun2。\n\n​\t**2）value**\n\n​\t\t\t放的是地址：指向符号所代表的空间。不过对于.o（可重定位目标文件）和可执行目标文件来说，value的值有所不\t\t同。\n\n+   可重定位目标文件\n\n​\t\t\t\t\tvalue总中放的只是相对于节起始地址的偏移。\n\n+   可执行目标文件\n\n​\t\t\t\t\tvalue中放的是绝对地址。“可重定位目标文件”被连接在一起后，value中放的是链接时重定位后的绝对地址。\n\n​\t**3）size**\n\n​\t\t\tsize代表的是value所指向空间的大小，毕竟value只是起始地址，不能说明空间的大小。\n\n​\t\t\t比如：\n\n+   ​\t如果符号是初始化了的全局变量的话\n    ​     size代表的全局变量在.data中所占字节数。\n\n+   如果符号是函数的话\n         size代表的是函数指令在.text中所占空间的大小\n\n​\t**4）type**\n\n​\t\t符号类型，大致有如下几种类型。\n\n+   FUNC：符号代表的是函数\n+   OBJECT：符号代表的是全局变量\n+   FILE：符号是源文件的名字\n+   SECTION：该符号关联的实体是个节，用于重定位\n+   COMMON：未初始化的全局变量，储存在.bss节\n+   NOTYPE：未知或未指定类型\n+   WEAK：弱符号，在链接时忽略弱符号的声明，采纳强符号的定义，可用来解决多文件符号冲突问题\n\n​\t**5）bind**\n\n​\t\t\t就两种情况，LCOAL、GLOBAL\n\n+   bind=LOCAL\n\n​\t\t\t\t\t表示符号是本地的：符号在模块中定义后，只能由本模块引用，static修饰的全局变量和函数就是这种情况。\n\n+   bind=CLOBAL(全局符号)\n\n​\t\t\t\t\t表示符号在本模块定义，但是可以被其它模块引用（使用），extern修饰的全局变量和函数就是这种情况。\n\n​\t**6）section**\n\n​\t\tsection的值有四种情况，节索引号、ABS、UNDEF、COM\n\n+   section=节索引号\n\n​\t\t\t\t说明符号所对应的空间在哪个节里面。\n\n+   section=ABS\n\n​\t\t\t\t表示该符号不需要被“链接程序”处理。\n\n​\t\t\t\t比如，如果符号名是***.c，这个符号不是全局变量、不是函数，只是一个源文件名而已，链接器（ld/collect2）\t\t\t在链接“可重定位目标文件”时，这个符号不需要被处理。\n\n+   section=UNDEF\n\n​\t\t\t\t表示这个符号，只是在本模块中被引用了，这个符号并不是由本模块定义的，表示这个符号被定义在了其它模块\t\t\t中，链接时要到其它模块中去找搜寻它的定义。\n\n+   section=COM\n\n    表示还未被分配空间（位置）的未初始化的数据目标，比如未初始化的全局变量(.bss)。\n\n​\t.symtab 所记录的符号，严格说起来就两种：\n\n1.   全局符号（由extern修饰的全局变量或函数）\n     +   在本地文件声明，在其他文件中被引用\n     +   在其他文件声明，在本地文件中被引用\n2.   本地符号（由static修饰的静态变量或函数）\n     +   在本地文件声明，且只能在本模块中使用\n\n\n\n---\n\n#### .rel.text Section 及 .rel.data Section\n\n​\t用于多个.o文件链接在一起时，需要根据这两个节中的重定位信息，将各个文件中的 .text节 与 data节分别整合 \n\n#### .debug Section 及 .line Section\n\n​\t前者存放调试信息，后者存放代码行号信息，编译时需要加入 -g 选项后，才会在这两节中存放相关调试信息\n\n```sh\ngcc -g main.c -o main\n```\n\n#### .strtab Section\n\n​\t字符串表，挨个存放：\n\n+   .symtab 所用的符号名字\n+   .debug 所用到的符号名字\n+   每个节的段名\n+   源文件名字\n+   等等\n\n#### Section Header Table\n\n```c\ntypedef struct\n{\n  Elf32_Word sh_name; /* Section name (string tbl index) */\n  Elf32_Word sh_type; /* Section type */\n  Elf32_Word sh_flags; /* Section flags */\n  Elf32_Addr sh_addr; /* Section virtual addr at execution */\n  Elf32_Off sh_offset; /* Section file offset */\n  Elf32_Word sh_size; /* Section size in bytes */\n  Elf32_Word sh_link; /* Link to another section */\n  Elf32_Word sh_info; /* Additional section information */\n  Elf32_Word sh_addralign; /* Section alignment */\n  Elf32_Word sh_entsize; /* Entry size if section holds table */\n} Elf32_Shdr;\n```\n\n```sh\nreadelf -S main.o\n```\n\n\n\n1.   节名称\n\n2.   节的类型\n\n3.   节的属性（读写权限）\n\n4.   节在ELF文件中所占的长度\n\n5.   节的对齐方式\n\n6.   偏移量\n\n---\n\n### ELF格式可执行目标文件\n\n![ELF和sectionheadertable(节头表)](https://img-blog.csdnimg.cn/img_convert/494d134bb25941bf46aba57ba98b4f5c.png)\n","slug":"汇编语言","published":1,"updated":"2022-10-13T03:31:57.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clggc2xk3002eecwd68kibljr","content":"<h1 id=\"汇编知识\"><a href=\"#汇编知识\" class=\"headerlink\" title=\"汇编知识\"></a>汇编知识</h1><h4 id=\"汇编语言的组成\"><a href=\"#汇编语言的组成\" class=\"headerlink\" title=\"汇编语言的组成\"></a>汇编语言的组成</h4><ol>\n<li>  汇编指令：机器码的助记符，有对应的机器码</li>\n<li>  伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行</li>\n<li>  其他符号：由编译器识别，没有对应的机器码</li>\n</ol>\n<h4 id=\"8086PC-内存地址分配\"><a href=\"#8086PC-内存地址分配\" class=\"headerlink\" title=\"8086PC 内存地址分配\"></a>8086PC 内存地址分配</h4><p>8086PC 具有宽度为20的地址总线，宽度为16的数据总线</p>\n<p>00000 ~ 9FFFF     主存储器RAM</p>\n<p>A0000 ~ BFFFF    显存地址</p>\n<p>C0000 ~ FFFFF    各类ROM</p>\n<h4 id=\"Debug程序\"><a href=\"#Debug程序\" class=\"headerlink\" title=\"Debug程序\"></a>Debug程序</h4><ul>\n<li>  -u : check a memory segment in assembly way    以数据的形式查看一段内存</li>\n<li>  -d : check a memory segment in data way             以代码的形式查看一段内存</li>\n<li>  -e : edit a memory segment                    编辑一段内存地址，使用空格进行后移                   </li>\n<li>  -a : input a series of assembly code              默认在cs:ip位置处编写一段汇编代码，可指定其他内存位置</li>\n<li>  -r : check all registers or update a register       查看所用通用寄存器或者修改某寄存器的值</li>\n<li>  -t : debug a programme step by step with going into sub programme          单步调试，进入子程序</li>\n<li>  -p : debug a programme step by step without going into sub programme      单步调试，不进入子程序，跳过循环</li>\n<li>  -n : rename a file           文件重命名</li>\n<li>  -g : don’t stop executing the programme until the target address you set comes           运行程序到你设定的地址</li>\n</ul>\n<h2 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h2><p>​    是CPU内部的存储器，是用来暂存计算数据及结果，是程序员可以进行操纵的空间，通过操纵寄存器进而达到操纵CPU的目的</p>\n<p>对于8086CPU来说，总共有14个</p>\n<h3 id=\"数据寄存器\"><a href=\"#数据寄存器\" class=\"headerlink\" title=\"数据寄存器\"></a>数据寄存器</h3><p>其中通用寄存器有4个{AX，BX，CX，DX}，用来存放数据，每一个通用寄存器是由高低两个8位寄存器组成的16位寄存器{AX = AH + AL}；</p>\n<blockquote>\n<p>EAX : 32位寄存器                  RAX : 64位寄存器 </p>\n<p>EAX 位于 RAX 的低32位</p>\n<p>AX 位于 EAX 的低16位</p>\n</blockquote>\n<p>进行8位运算时，两个8位寄存器互不影响，不进位不借位，进位值与借位值存在标志寄存器的<strong>CF标志位</strong>中</p>\n<p>进行16位运算时，  高位溢出舍弃</p>\n<h4 id=\"MOV-amp-ADD-amp-SUB-指令\"><a href=\"#MOV-amp-ADD-amp-SUB-指令\" class=\"headerlink\" title=\"MOV &amp; ADD &amp; SUB 指令\"></a>MOV &amp; ADD &amp; SUB 指令</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,bx      ; 将ax中的数据与bx相加后结果送入ax</span><br><span class=\"line\">mov ax,5FC5    ; 将ax的值改为5fc5</span><br><span class=\"line\">mov al,bh      ; 将ax的低8位的值改为bx高8位的值</span><br><span class=\"line\">add ax,05A6    ; ax的值加上05a6后，送入ax中</span><br><span class=\"line\">add bh,al      ; 将bx的高8位加上ax的低8位</span><br><span class=\"line\">sub ax,ax      ; 减法运算</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"地址寄存器\"><a href=\"#地址寄存器\" class=\"headerlink\" title=\"地址寄存器\"></a>地址寄存器</h3><ul>\n<li><p>段地址寄存器</p>\n<p>  {CS，DS，SS，ES} = {代码段，数据段，堆栈段，其他段}</p>\n</li>\n<li><p>偏移地址寄存器</p>\n<p>  {SP，BP，SI，DI，IP，BX} = {，，，，指令指针，}</p>\n</li>\n<li><p>设计目的</p>\n<p>  8086CPU地址总线宽度为20，而寄存器位长16，那么就需要用两个寄存器来存一个物理地址</p>\n</li>\n</ul>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">PhysicalAddr</span> <span class=\"operator\">=</span> <span class=\"variable\">SegmentAddr</span> <span class=\"operator\">*</span> <span class=\"number\">10</span><span class=\"variable\">h</span> <span class=\"operator\">+</span> <span class=\"variable\">OffsetAddr</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CS-IP-代码段\"><a href=\"#CS-IP-代码段\" class=\"headerlink\" title=\"CS : IP 代码段\"></a>CS : IP 代码段</h3><blockquote>\n<p>  代码段寄存器 : 指令指针寄存器</p>\n</blockquote>\n<p>CPU将CS:IP指向的内存单元中的内容当做代码执行 </p>\n<p>指令执行过程：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲区</span><br><span class=\"line\">2. IP = IP + Length(Instruction) 从而指向下一条指令的地址</span><br><span class=\"line\">3. 执行指令，转到步骤 1</span><br></pre></td></tr></table></figure>\n\n<p>在8086CPU加电启动或复位后，CS被置为FFFFH，IP被置为0000H</p>\n<h4 id=\"JMP-指令\"><a href=\"#JMP-指令\" class=\"headerlink\" title=\"JMP 指令\"></a>JMP 指令</h4><p>转移指令，修改CS:IP的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2000:0010    ; 修改CS为2000，修改IP为0010</span><br><span class=\"line\">jmp ax           ; 修改IP为AX中存储的值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DS-Offset-数据段\"><a href=\"#DS-Offset-数据段\" class=\"headerlink\" title=\"DS : [Offset] 数据段\"></a>DS : [Offset] 数据段</h3><blockquote>\n<p>  数据段寄存器 : [偏移地址]</p>\n</blockquote>\n<p>CPU将DS:[Offset]指向的内存地址中的内容当做数据读写（<u><strong>需要注意小端序还是大端序</strong></u>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx,3001</span><br><span class=\"line\">mov ds,bx         ; 将BX中存储的段地址送入DS数据段寄存器中，8086不允许使用MOV指令直接给段寄存器赋值</span><br><span class=\"line\">mov ax,[0101]     ; 将内存中地址为 DS * 10h + 0101h 中的数据送入AX中</span><br><span class=\"line\">mov [0102],ax     ; 将AX中的数据送入到内存地位为 DS * 10h + 0102h 的地方</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SS-SP-堆栈段\"><a href=\"#SS-SP-堆栈段\" class=\"headerlink\" title=\"SS : SP 堆栈段\"></a>SS : SP 堆栈段</h3><blockquote>\n<p>  堆栈段寄存器 : 栈顶指针寄存器</p>\n</blockquote>\n<p>8086CPU的入栈操作和出栈操作都是以<strong>字</strong>为单位进行的；入栈时，栈顶由高地址向低地址的方向增长(小端序)</p>\n<h4 id=\"PUSH-amp-POP-指令\"><a href=\"#PUSH-amp-POP-指令\" class=\"headerlink\" title=\"PUSH &amp; POP 指令\"></a>PUSH &amp; POP 指令</h4><p>出栈 &amp; 入栈</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;指定栈顶界限，假定栈段范围为10000 ~ 1001F</span><br><span class=\"line\">mov ax,1000</span><br><span class=\"line\">mov ss,ax</span><br><span class=\"line\">;设置栈顶指针,空栈时,栈顶指针指向栈底后一位地址</span><br><span class=\"line\">mov sp,0020</span><br><span class=\"line\">;入栈：</span><br><span class=\"line\">;\tSP = SP - 2       </span><br><span class=\"line\">mov bx,3FFF</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">push [0]</span><br><span class=\"line\">;出栈：</span><br><span class=\"line\">;\tSP = SP + 2</span><br><span class=\"line\">pop [0]</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop bx</span><br></pre></td></tr></table></figure>\n\n<p><strong>当执行修改SS堆栈段寄存器的值时，下一条指令也会紧接着执行</strong></p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">; 数据段</span><br><span class=\"line\">data segment</span><br><span class=\"line\">date ends</span><br><span class=\"line\">; 堆栈段</span><br><span class=\"line\">stack segment stack</span><br><span class=\"line\">stack ends</span><br><span class=\"line\">; 代码段</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,4500H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ss,ax</span><br><span class=\"line\">\tmov sp,0020H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,0D200H      ; 在汇编源程序中，数据不能以字母开头，若最高位＞9时，需要在前面补0</span><br><span class=\"line\">\tmov ds:[0],ax</span><br><span class=\"line\">    push ds:[0]</span><br><span class=\"line\">    pop bx</span><br><span class=\"line\">    mov ds:[2],bx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 返回上级程序</span><br><span class=\"line\">\tmov ax,4c00H</span><br><span class=\"line\">\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BX-amp-LOOP-指令\"><a href=\"#BX-amp-LOOP-指令\" class=\"headerlink\" title=\"[BX] &amp; LOOP 指令\"></a>[BX] &amp; LOOP 指令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx,0010H   </span><br><span class=\"line\">mov ax,50F0H</span><br><span class=\"line\">mov ds:[bx],ax   ; 将bx寄存器中的数据当做地址偏移量</span><br></pre></td></tr></table></figure>\n\n<p>​        CX寄存器中的值可作为loop指令循环次数，每次减一，知道减为零结束循环</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov bx,5H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov al,ds:[bx]</span><br><span class=\"line\">\tmov ah,0H</span><br><span class=\"line\">\tmov dx,0H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov cx,5            ; 初始化循环次数</span><br><span class=\"line\">s: \tadd dx,ax           ; 定义循环体</span><br><span class=\"line\">\tloop s              ; 开始循环</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,004cH</span><br><span class=\"line\">\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>综合运用[bx]&amp;loop</p>\n<h3 id=\"INC-指令\"><a href=\"#INC-指令\" class=\"headerlink\" title=\"INC 指令\"></a>INC 指令</h3><p>​    数值自增一</p>\n<h3 id=\"DEC-指令\"><a href=\"#DEC-指令\" class=\"headerlink\" title=\"DEC 指令\"></a>DEC 指令</h3><p>​    数值自减一</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; \t计算从10000H ~ 1000aH地址中所有数值的和，储存在dx中</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov bx,0H</span><br><span class=\"line\"></span><br><span class=\"line\">\tmov dx,0H</span><br><span class=\"line\">\tmov cx,0aH</span><br><span class=\"line\"></span><br><span class=\"line\">s: \tmov al,ds:[bx]</span><br><span class=\"line\">\tmov ah,0H</span><br><span class=\"line\">\tadd dx,ax</span><br><span class=\"line\">\tinc bx</span><br><span class=\"line\">\tloop s</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"DW-伪指令-amp-start-标号\"><a href=\"#DW-伪指令-amp-start-标号\" class=\"headerlink\" title=\"DW 伪指令 &amp; start 标号\"></a>DW 伪指令 &amp; start 标号</h2><p>定义字型数据(define word)，可在代码段中存放提前定义好的数据</p>\n<p><strong>start</strong> 标号用来标识程序的入口，即是初始化CS:IP的值，用 <strong>end</strong> 指令来声明<strong>start</strong>标号的作用（程序入口）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 定义数据</span><br><span class=\"line\">\tdw 0123H,0a446H,5FF6H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 代码</span><br><span class=\"line\">start:\tmov bx,0</span><br><span class=\"line\">\t\tmov ax,0</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tadd ax,cs:[bx]</span><br><span class=\"line\">\t\tadd bx,2H</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h3><p>​    将数据、代码、栈三段分立，方便管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdw 0123H,0456H,0789H,0abcH,0defH</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment stack</span><br><span class=\"line\">\tdw 0H,0H,0H,0,0,0,0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\t</span><br><span class=\"line\">\t\tmov ax,data</span><br><span class=\"line\">\t\tmov ds,ax         ; 分配数据段</span><br><span class=\"line\">\t\tmov ax,stack</span><br><span class=\"line\">\t\tmov ss,ax         ; 分配栈段</span><br><span class=\"line\">\t\tmov sp,0eH</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\">\t\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"地址定位与数据处理\"><a href=\"#地址定位与数据处理\" class=\"headerlink\" title=\"地址定位与数据处理\"></a>地址定位与数据处理</h2><h3 id=\"AND-amp-OR-指令\"><a href=\"#AND-amp-OR-指令\" class=\"headerlink\" title=\"AND &amp; OR 指令\"></a>AND &amp; OR 指令</h3><p>​    二进制逻辑与或运算</p>\n<h3 id=\"XOR-指令\"><a href=\"#XOR-指令\" class=\"headerlink\" title=\"XOR 指令\"></a>XOR 指令</h3><p>​    异或运算，常用于main函数设置返回值0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xor eax,eax     ; 该命令执行速度比 mov ax,0 要快</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串型数据-amp-DB-伪指令\"><a href=\"#字符串型数据-amp-DB-伪指令\" class=\"headerlink\" title=\"字符串型数据 &amp; DB 伪指令\"></a>字符串型数据 &amp; DB 伪指令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data segment</span><br><span class=\"line\">\tdb &#x27;string&#x27;</span><br><span class=\"line\">data ends</span><br><span class=\"line\">; low -&gt; up</span><br><span class=\"line\">or al,00100000</span><br><span class=\"line\">; up -&gt; low</span><br><span class=\"line\">and al,11011111</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"灵活定位-amp-DI-amp-SI-amp-BP\"><a href=\"#灵活定位-amp-DI-amp-SI-amp-BP\" class=\"headerlink\" title=\"灵活定位 &amp; DI &amp; SI &amp; BP\"></a>灵活定位 &amp; DI &amp; SI &amp; BP</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,ds:[bx+100]</span><br><span class=\"line\">mov ax,ds:[bx+di]</span><br><span class=\"line\">mov ax,ds:[bx][si]</span><br><span class=\"line\">mov ax,ds:[bx+si+100]</span><br><span class=\"line\">mov ax,ds:[bx][si].100</span><br><span class=\"line\">mov ax,ds:[bp+si+100]</span><br><span class=\"line\">mov ax,ds:[bp][si].100</span><br></pre></td></tr></table></figure>\n\n<p>SI &amp; DI ：16位寄存器，无法分割为两个8位寄存器</p>\n<p>BP：<a href=\"#BP%E5%AF%84%E5%AD%98%E5%99%A8\">见此处</a></p>\n<h3 id=\"X-PTR\"><a href=\"#X-PTR\" class=\"headerlink\" title=\"X PTR\"></a>X PTR</h3><p><strong>指明数据长度的方式</strong>：</p>\n<ul>\n<li><p>通过寄存器名指明数据长度</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1H</span><br><span class=\"line\">mov al,1H</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>  通过操作符 X PTR 指明数据长度</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov word ptr ds:[0],1H</span><br><span class=\"line\">mov byte ptr ds:[2],1H</span><br><span class=\"line\">mov byte ptr ds:[bx+si+10],&#x27;F&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DIV-指令\"><a href=\"#DIV-指令\" class=\"headerlink\" title=\"DIV 指令\"></a>DIV 指令</h3><ol>\n<li>  除数：在寄存器或内存</li>\n<li>被除数：默认在AX或DX<ul>\n<li>  除数为8位，被除数为16位，则被除数放在AX</li>\n<li>  除数为16位，被除数为32位，则被除数在DX与AX，DX放高位，AX放低位</li>\n</ul>\n</li>\n<li>结果：<ul>\n<li>  若除数为8位，则al存放商，ah存放余数</li>\n<li>  若除数为16位，则ax存放商，dx存放余数</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; 计算 100001 / 100</span><br><span class=\"line\">; 100001 =&gt; 186a1H</span><br><span class=\"line\">mov dx,1H</span><br><span class=\"line\">mov ax,86a1H</span><br><span class=\"line\">mov word ptr ds:[bx+si+10],100</span><br><span class=\"line\">div word ptr ds:[bx+si+10]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DD-伪指令\"><a href=\"#DD-伪指令\" class=\"headerlink\" title=\"DD 伪指令\"></a>DD 伪指令</h3><p>用来定义DWORD（double word）双字型数据</p>\n<h3 id=\"DUP-伪指令\"><a href=\"#DUP-伪指令\" class=\"headerlink\" title=\"DUP 伪指令\"></a>DUP 伪指令</h3><p>与db、dw、dd等数据定义伪指令配合使用，进行重复数据的定义</p>\n<ul>\n<li>  db 重复次数 dup (被重复的字节型数据)</li>\n<li>  dw 重复次数 dup (被重复的字型数据)</li>\n<li>  dd 重复次数 dup (被重复的双字型数据)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db 3 dup (&#x27;12&#x27;)    ;   db &#x27;121212&#x27;</span><br><span class=\"line\">db 5 dup (10H)     ;   db 10h,10h,10h,10h,10h</span><br><span class=\"line\">dw 2 dup (5f5fH)   ;   dw 5f5fH,5f5fH</span><br><span class=\"line\">dd 2 dup(12H)      ;   dd 00000012H,00000012H</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JMP指令原理\"><a href=\"#JMP指令原理\" class=\"headerlink\" title=\"JMP指令原理\"></a>JMP指令原理</h2><h3 id=\"OFFSET-伪指令\"><a href=\"#OFFSET-伪指令\" class=\"headerlink\" title=\"OFFSET 伪指令\"></a>OFFSET 伪指令</h3><p>取得标号的偏移地址，<strong>不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">start:\t</span><br><span class=\"line\">\t\tmov ax,offset start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JMP指令的用法\"><a href=\"#JMP指令的用法\" class=\"headerlink\" title=\"JMP指令的用法\"></a>JMP指令的用法</h3><ol>\n<li><p>数值指明目的地址</p>\n<ul>\n<li><p>同时修改cs : ip</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 1000:0000</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>段内短转移（机器码中不出现目的地址，只出现相对位移，**<u>==该相对位移在编译时确定==</u>**）</p>\n<p>  转移位移为8位，-128,127</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">s:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp short s          ; 使用相对距离差修改ip的值，ip = ip + (标号地址 - jmp后下一条指令初地址) </span><br><span class=\"line\">\tmov bx,11H</span><br></pre></td></tr></table></figure></li>\n<li><p>段内近转移</p>\n<p>  转移位移为16位，-32768,32767（机器码中不出现目的地址，……同短转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">s:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp near ptr s</span><br><span class=\"line\">\tmov bx,11H</span><br></pre></td></tr></table></figure></li>\n<li><p>段间转移（远转移）</p>\n<p>  同时修改CS:IP，cs = 标号所在段的段地址，ip = 标号在所在段的偏移地址</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acode segment</span><br><span class=\"line\">sa:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp far ptr sb</span><br><span class=\"line\">acode ends</span><br><span class=\"line\"></span><br><span class=\"line\">bcode segment</span><br><span class=\"line\">sb:</span><br><span class=\"line\">\tmov bx,11H</span><br><span class=\"line\">bcode ends</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>转移地址在寄存器中</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,10F1H</span><br><span class=\"line\">jmp ax</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>转移地址在内存中</p>\n<ul>\n<li><p>内存单元中存有一个字型数据，即为目的地址的偏移地址（段内转移但非近转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1000H</span><br><span class=\"line\">mov ds:[1],ax</span><br><span class=\"line\">jmp word ptr ds:[1]</span><br></pre></td></tr></table></figure></li>\n<li><p>内存单元中存有一个双字型数据，高位为目的地址的段地址，低位为偏移地址（段间转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1000H</span><br><span class=\"line\">mov ds:[0],ax</span><br><span class=\"line\">mov word ptr ds:[2],0H</span><br><span class=\"line\">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"有条件转移指令\"><a href=\"#有条件转移指令\" class=\"headerlink\" title=\"有条件转移指令\"></a>有条件转移指令</h3><p>所有的条件转移指令都是短转移，在对应机器码中不出现目的地址，只出现相对位移，在编译时确定</p>\n<ul>\n<li><p>jcxz 指令</p>\n<p>  功能上等同于在段内短转移之前判断CX是否等于0，若cx == 0，则跳转，若cx != 0，则不跳转</p>\n</li>\n<li><p>loop 指令</p>\n<p>  本质上也是条件转移指令，条件与jcxz相反，且伴随着cx的递减</p>\n</li>\n<li><p>检测比较结果的条件转移指令（根据**<u>==无符号数==</u>**的比较结果进行转移）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">相关标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">JE</td>\n<td align=\"center\">等于则转移</td>\n<td align=\"center\">ZF = 1</td>\n</tr>\n<tr>\n<td align=\"center\">JNE</td>\n<td align=\"center\">不等于则转移</td>\n<td align=\"center\">ZF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JB</td>\n<td align=\"center\">低于则转移</td>\n<td align=\"center\">CF = 1</td>\n</tr>\n<tr>\n<td align=\"center\">JNB</td>\n<td align=\"center\">不低于则转移</td>\n<td align=\"center\">CF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JA</td>\n<td align=\"center\">高于则转移</td>\n<td align=\"center\">CF = 0  &amp;&amp;  ZF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JNA</td>\n<td align=\"center\">不高于则转移</td>\n<td align=\"center\">CF = 1  ||  ZF = 1</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcxz 标号</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"栈操作\"><a href=\"#栈操作\" class=\"headerlink\" title=\"栈操作\"></a>栈操作</h2><h3 id=\"RET-amp-RETF-指令\"><a href=\"#RET-amp-RETF-指令\" class=\"headerlink\" title=\"RET &amp; RETF 指令\"></a>RET &amp; RETF 指令</h3><p>ret：用栈中的数据修改ip的内容，实现近转移</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret </span><br><span class=\"line\">====&gt;   </span><br><span class=\"line\">pop ip</span><br></pre></td></tr></table></figure>\n\n<p>retf：用栈中的数据修改 cs : ip，实现远转移</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retf </span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">pop ip</span><br><span class=\"line\">pop cs</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">mov bx,sp</span><br><span class=\"line\">jmp dword ptr ss:[bx]</span><br><span class=\"line\">add sp,4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CALL-指令\"><a href=\"#CALL-指令\" class=\"headerlink\" title=\"CALL 指令\"></a>CALL 指令</h3><p>call：将当前 ip 或 cs : ip 压入栈中，再转移</p>\n<ul>\n<li><p>进行近转移的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call fun     ; fun 为本段内某标号</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp near ptr fun</span><br></pre></td></tr></table></figure></li>\n<li><p>进行远转移的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call far ptr fun     ; fun 为非本段内某标号</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push cs</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp far ptr fun</span><br></pre></td></tr></table></figure></li>\n<li><p>目的地址在寄存器的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call ax      </span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp ax</span><br></pre></td></tr></table></figure></li>\n<li><p>目的地址在内存中的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call word ptr ds:[bx]              ; 段内转移</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp word ptr ds:[bx]</span><br><span class=\"line\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class=\"line\">call dword ptr ds:[bx]             ; 段间转移（远转移）</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push cs</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp dword ptr ds:[bx]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"BP寄存器\"><a href=\"#BP寄存器\" class=\"headerlink\" title=\"BP寄存器\"></a>BP寄存器</h3><ul>\n<li>  当没有显式指出段地址且偏移量寄存器使用bp时，则段地址默认为SS寄存器中的值，无法分割bp为基址寄存器</li>\n<li>  和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到</li>\n<li>  一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;在函数进入时:</span><br><span class=\"line\">push bp     ;\t保存bp指针</span><br><span class=\"line\">mov bp,sp \t;\t将sp指针传给bp，此时bp指向sp的基地址。</span><br><span class=\"line\"></span><br><span class=\"line\">;;;;   函数体   ;;;;</span><br><span class=\"line\"></span><br><span class=\"line\">mov sp,bp   ;\tsp回到栈顶</span><br><span class=\"line\">pop bp      ;\tbp恢复初始值</span><br><span class=\"line\">ret         ; \t函数返回</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数压栈\"><a href=\"#参数压栈\" class=\"headerlink\" title=\"参数压栈\"></a>参数压栈</h3><p>​    调用某些带有参数的函数时，先按参数顺序将参数压栈(参数位于栈高位)，然后再执行<strong>CALL</strong>命令将CS:IP压栈(CS:IP位于栈低位)</p>\n<h3 id=\"LEA-指令\"><a href=\"#LEA-指令\" class=\"headerlink\" title=\"LEA 指令\"></a>LEA 指令</h3><p>​    LEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">makeArray PROC</span><br><span class=\"line\">    push ebp</span><br><span class=\"line\">    mov ebp,esp</span><br><span class=\"line\">    sub esp, 32            ;myString 位于 EBP-30 的位置</span><br><span class=\"line\">    lea esi, [ebp-30]      ;加载 myString 的地址</span><br><span class=\"line\">    mov ecx, 30            ;循环计数器</span><br><span class=\"line\">LI: mov BYTE PTR [esi]     ;填充一个位置</span><br><span class=\"line\">    inc esi                ;指向下一个元素</span><br><span class=\"line\">    loop LI                ;循环，直到 ECX=0</span><br><span class=\"line\">    add esp, 32            ;删除数组(恢复ESP)</span><br><span class=\"line\">    pop ebp</span><br><span class=\"line\">    ret</span><br><span class=\"line\">makeArray ENDP</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MUL-指令\"><a href=\"#MUL-指令\" class=\"headerlink\" title=\"MUL 指令\"></a>MUL 指令</h3><ul>\n<li>  两数相乘，要么都是8位，要么都是16位</li>\n<li>  若是8位，一个默认在AL，另一个在8位寄存器或内存，结果在AX</li>\n<li>  若是16位，一个默认在AX，另一个在16位寄存器或内存，高位在DX，低位在AX</li>\n</ul>\n<h3 id=\"寄存器冲突问题\"><a href=\"#寄存器冲突问题\" class=\"headerlink\" title=\"寄存器冲突问题\"></a>寄存器冲突问题</h3><p>若计数器寄存器 CX 另有用途，无法存放循环次数，那么可以用 jmp 与 jcxz 指令配合代替loop指令，实现有限循环</p>\n<hr>\n<h2 id=\"标志寄存器\"><a href=\"#标志寄存器\" class=\"headerlink\" title=\"标志寄存器\"></a>标志寄存器</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>  用来存储相关指令的某些执行结果</li>\n<li>  用来为CPU执行相关指令提供行为依据</li>\n<li>  用来控制CPU的相关工作方式</li>\n</ul>\n<blockquote>\n<p>  8086CPU的标志寄存器时16位寄存器，其信息是按起作用，每一个位存储的信息通常被称为程序状态字(PSW)</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">15</th>\n<th align=\"center\">14</th>\n<th align=\"center\">13</th>\n<th align=\"center\">12</th>\n<th align=\"center\">11</th>\n<th align=\"center\">10</th>\n<th align=\"center\">9</th>\n<th align=\"center\">8</th>\n<th align=\"center\">7</th>\n<th align=\"center\">6</th>\n<th align=\"center\">5</th>\n<th align=\"center\">4</th>\n<th align=\"center\">3</th>\n<th align=\"center\">2</th>\n<th align=\"center\">1</th>\n<th align=\"center\">0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">OF</td>\n<td align=\"center\">DF</td>\n<td align=\"center\">IF</td>\n<td align=\"center\">TF</td>\n<td align=\"center\">SF</td>\n<td align=\"center\">ZF</td>\n<td align=\"center\"></td>\n<td align=\"center\">AF</td>\n<td align=\"center\"></td>\n<td align=\"center\">PF</td>\n<td align=\"center\"></td>\n<td align=\"center\">CF</td>\n</tr>\n</tbody></table>\n<h3 id=\"ZF-标志\"><a href=\"#ZF-标志\" class=\"headerlink\" title=\"ZF 标志\"></a>ZF 标志</h3><ul>\n<li>  位于第  <strong>==6==</strong> 位</li>\n<li>  零标志位，记录相关指令执行后，其结果是否为0，若为 ==0== 则ZF = 1，否则ZF = 0；</li>\n<li>  在8086CPU指令集中，add、sub、mul、div、inc、or、and 等运算指令一般影响ZF</li>\n</ul>\n<h3 id=\"PF-标志\"><a href=\"#PF-标志\" class=\"headerlink\" title=\"PF 标志\"></a>PF 标志</h3><ul>\n<li>  位于第 <strong>==2==</strong> 位</li>\n<li>  奇偶标志位，记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若 ==偶== 则 ==1==，若 ==奇== 则 ==0==</li>\n</ul>\n<h3 id=\"SF-标志\"><a href=\"#SF-标志\" class=\"headerlink\" title=\"SF 标志\"></a>SF 标志</h3><ul>\n<li>  位于第 <strong>==7==</strong> 位</li>\n<li>  符号标志位，记录相关指令执行后，其结果是否为负，若 ==负== 则 ==1==，若 ==非负== 则 ==0==</li>\n</ul>\n<h3 id=\"CF-标志\"><a href=\"#CF-标志\" class=\"headerlink\" title=\"CF 标志\"></a>CF 标志</h3><ul>\n<li>  位于第 <strong>==0==</strong> 位</li>\n<li>  进位标志位，一般情况下，在进行 <u>无符号数</u> 运算的时候，记录了运算结果的最高有效位向更高位的进位值，或借位值</li>\n</ul>\n<h3 id=\"OF-标志\"><a href=\"#OF-标志\" class=\"headerlink\" title=\"OF 标志\"></a>OF 标志</h3><ul>\n<li>  位于第 <strong>==11==</strong> 位</li>\n<li>  CPU在进行 <u>有符号数</u> 运算时，若溢出则为 1 ，若未溢出，则为 0 </li>\n</ul>\n<h3 id=\"ADC-指令\"><a href=\"#ADC-指令\" class=\"headerlink\" title=\"ADC 指令\"></a>ADC 指令</h3><p>adc指令是带进位的加法指令，利用了CF标志位</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adc ax,bx    ;  ax = ax + bx + CF</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SBB-指令\"><a href=\"#SBB-指令\" class=\"headerlink\" title=\"SBB 指令\"></a>SBB 指令</h3><p>sbb指令是带借位减法指令，同样利用了CF标志位</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbb ax,bx    ; ax = ax - bx - CF</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CMP-指令\"><a href=\"#CMP-指令\" class=\"headerlink\" title=\"CMP 指令\"></a>CMP 指令</h3><p>cmp是比较指令，功能上相当于减法指令，但不保存结果，只影响相关标志位的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,3</span><br><span class=\"line\">mov bx,4</span><br><span class=\"line\">cmp ax,bx</span><br><span class=\"line\">; 相当于执行减法，执行后 ZF = 0，PF = 1，SF = 1,CF = 1,OF = 0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  ZF = 1  ==&gt;  ax == bx</li>\n<li>  ZF = 0  ==&gt;  ax != bx</li>\n<li>  CF = 1  ==&gt;  ax &lt; bx</li>\n<li>  CF = 0  ==&gt;  ax &gt;= bx</li>\n</ul>\n<h3 id=\"TEST-指令\"><a href=\"#TEST-指令\" class=\"headerlink\" title=\"TEST 指令\"></a>TEST 指令</h3><p>test 对两个操作数进行逻辑（按位）与操作，功能上与and指令类似，但不保存结果，只影响相关标志位的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; 检查ax的最高位是否为 1</span><br><span class=\"line\">test ax,10000000b</span><br><span class=\"line\">je isNotOne      ; 最高位是 0</span><br><span class=\"line\">jne isOne\t\t ; 最高位是 1</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"与标志位相关的条件转移指令\"><a href=\"#与标志位相关的条件转移指令\" class=\"headerlink\" title=\"与标志位相关的条件转移指令\"></a>与标志位相关的条件转移指令</h3><p><a href=\"#%E6%9C%89%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4\">详细见此处</a></p>\n<h3 id=\"DF-标志-amp-串传送指令\"><a href=\"#DF-标志-amp-串传送指令\" class=\"headerlink\" title=\"DF 标志 &amp; 串传送指令\"></a>DF 标志 &amp; 串传送指令</h3><ul>\n<li>  DF 标志位于第 ==10== 位</li>\n<li>  方向标志位，在串处理指令中，控制每次操作后 SI 与 DI 的增减</li>\n<li>  若 DF = 0，则每次操作后 SI &amp; DI 递增</li>\n<li>  若 DF = 1，则每次操作后 SI &amp; DI 递减</li>\n</ul>\n<h4 id=\"MOVSB-指令\"><a href=\"#MOVSB-指令\" class=\"headerlink\" title=\"MOVSB 指令\"></a>MOVSB 指令</h4><p>movsb 指令功能是将ds:si指向的内存单元中的一个字节型数据送入es:di；相当于:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; if DF = 1</span><br><span class=\"line\">mov es:[di],byte ptr ds:[si]</span><br><span class=\"line\">dec si</span><br><span class=\"line\">dec di</span><br><span class=\"line\"></span><br><span class=\"line\">; if DF = 0</span><br><span class=\"line\">mov es:[di],byte ptr ds:[si]</span><br><span class=\"line\">inc si</span><br><span class=\"line\">inc di</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MOVSW-指令\"><a href=\"#MOVSW-指令\" class=\"headerlink\" title=\"MOVSW 指令\"></a>MOVSW 指令</h4><p>movsw 指令与 movsb 指令类似，只是把字节型数据改为字型数据，si 与 di 每次变化两个单位</p>\n<h4 id=\"与-REP-的配合\"><a href=\"#与-REP-的配合\" class=\"headerlink\" title=\"与 REP 的配合\"></a>与 REP 的配合</h4><p>上述两种指令都需要与 rep 相配和，实现数据从 DS段 <strong>连续</strong>传送到 ES段 中，本质是由loop循环的实现，循环次数由 CX 的值决定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rep movsb</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">s: </span><br><span class=\"line\">\tmovsb</span><br><span class=\"line\">\tloop s</span><br><span class=\"line\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class=\"line\">rep movsw</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">s: </span><br><span class=\"line\">\tmovsw</span><br><span class=\"line\">\tloop s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CLD-amp-STD-指令\"><a href=\"#CLD-amp-STD-指令\" class=\"headerlink\" title=\"CLD &amp; STD 指令\"></a>CLD &amp; STD 指令</h4><ul>\n<li>  sld 指令：将DF置 0，实现 si 与 di 的自增</li>\n<li>  std 指令：将DF置 1，实现 si 与 di 的自减</li>\n</ul>\n<h3 id=\"PUSHF-amp-POPF-指令\"><a href=\"#PUSHF-amp-POPF-指令\" class=\"headerlink\" title=\"PUSHF &amp; POPF 指令\"></a>PUSHF &amp; POPF 指令</h3><p>pushf的功能是将标志寄存器中的值压栈，而popf是将栈中的数据弹出并送入标志寄存器中</p>\n<h3 id=\"标志寄存器在Debug中的表示\"><a href=\"#标志寄存器在Debug中的表示\" class=\"headerlink\" title=\"标志寄存器在Debug中的表示\"></a>标志寄存器在Debug中的表示</h3><table>\n<thead>\n<tr>\n<th align=\"center\">标志</th>\n<th align=\"center\">置一</th>\n<th align=\"center\">置零</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">OF</td>\n<td align=\"center\">OV</td>\n<td align=\"center\">NV</td>\n</tr>\n<tr>\n<td align=\"center\">SF</td>\n<td align=\"center\">NG</td>\n<td align=\"center\">PL</td>\n</tr>\n<tr>\n<td align=\"center\">ZF</td>\n<td align=\"center\">ZR</td>\n<td align=\"center\">NZ</td>\n</tr>\n<tr>\n<td align=\"center\">PF</td>\n<td align=\"center\">PE</td>\n<td align=\"center\">PO</td>\n</tr>\n<tr>\n<td align=\"center\">CF</td>\n<td align=\"center\">CY</td>\n<td align=\"center\">NC</td>\n</tr>\n<tr>\n<td align=\"center\">DF</td>\n<td align=\"center\">DN</td>\n<td align=\"center\">UP</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h2><h1 id=\"32位逆向\"><a href=\"#32位逆向\" class=\"headerlink\" title=\"32位逆向\"></a>32位逆向</h1><h2 id=\"小端序-amp-大端序\"><a href=\"#小端序-amp-大端序\" class=\"headerlink\" title=\"小端序&amp;大端序\"></a>小端序&amp;大端序</h2><p>地址高位存数据高位 ===》 小端序</p>\n<p>地址高位存地址低位 ===》 大端序</p>\n<h2 id=\"IA-32寄存器\"><a href=\"#IA-32寄存器\" class=\"headerlink\" title=\"IA-32寄存器\"></a>IA-32寄存器</h2><h3 id=\"基本程序运行寄存器\"><a href=\"#基本程序运行寄存器\" class=\"headerlink\" title=\"基本程序运行寄存器\"></a>基本程序运行寄存器</h3><ul>\n<li>  通用寄存器{EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP}</li>\n<li>  段寄存器{CS，DS，SS，ES，FS，GS}</li>\n<li>  程序状态与控制寄存器{EFLAGS}</li>\n<li>  指令指针寄存器{EIP}</li>\n</ul>\n<blockquote>\n<p>Tips:</p>\n<ol>\n<li>  EAX一般用于函数返回值中，所有Win32 API函数都会先把返回值保存在EAX中再返回</li>\n<li>  ES，FS，GS：附加数据段</li>\n</ol>\n</blockquote>\n<h2 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h2><ul>\n<li>  cdecl：调用者负责清理栈中的参数</li>\n<li>  stdcall：被调用者负责清理栈中的参数</li>\n</ul>\n<h2 id=\"PE文件格式\"><a href=\"#PE文件格式\" class=\"headerlink\" title=\"PE文件格式\"></a>PE文件格式</h2><img src=\"https://img-blog.csdnimg.cn/20201210163828181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nX2Nt,size_16,color_FFFFFF,t_70\" alt=\"img\" style=\"zoom:100%;\">\n\n<h3 id=\"DOS-头\"><a href=\"#DOS-头\" class=\"headerlink\" title=\"DOS 头\"></a>DOS 头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注释掉的不需要重点分析</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class=\"line\">    <span class=\"number\">0X00</span> WORD e_magic;      <span class=\"comment\">//※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件</span></span><br><span class=\"line\">    <span class=\"comment\">//0X02 WORD e_cblp;     //Bytes on last page of file</span></span><br><span class=\"line\">    <span class=\"comment\">//0X04 WORD e_cp;       //Pages in file</span></span><br><span class=\"line\">    <span class=\"comment\">//0X06 WORD e_crlc;     //Relocations</span></span><br><span class=\"line\">    <span class=\"comment\">//0X08 WORD e_cparhdr;  //Size of header in paragraphs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0A WORD e_minalloc; //Minimun extra paragraphs needs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0C WORD e_maxalloc; //Maximun extra paragraphs needs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0E WORD e_ss;       //intial(relative)SS value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X10 WORD e_sp;       //intial SP value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X12 WORD e_csum;     //Checksum</span></span><br><span class=\"line\">    <span class=\"comment\">//0X14 WORD e_ip;       //intial IP value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X16 WORD e_cs;       //intial(relative)CS value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X18 WORD e_lfarlc;   //File Address of relocation table</span></span><br><span class=\"line\">    <span class=\"comment\">//0X1A WORD e_ovno;     //Overlay number</span></span><br><span class=\"line\">    <span class=\"comment\">//0x1C WORD e_res[4];   //Reserved words</span></span><br><span class=\"line\">    <span class=\"comment\">//0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)</span></span><br><span class=\"line\">    <span class=\"comment\">//0x26 WORD e_oeminfo;  //OEM information;e_oemid specific</span></span><br><span class=\"line\">    <span class=\"comment\">//0x28 WORD e_res2[10]; //Reserved words</span></span><br><span class=\"line\">    <span class=\"number\">0x3C</span> DWORD e_lfanew;    <span class=\"comment\">//※Offset to start of PE header:定位PE文件，NT头相对于文件的偏移量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>e_magic : 固定为 ‘MZ’</p>\n<p>e_lfanew：NT头的文件偏移位置</p>\n<h3 id=\"DOS-stub\"><a href=\"#DOS-stub\" class=\"headerlink\" title=\"DOS stub\"></a>DOS stub</h3><p>​    由代码与数据混合而成，大小不固定，可没有，可存储在16位汇编指令，在dos环境下运行</p>\n<h3 id=\"NT-头\"><a href=\"#NT-头\" class=\"headerlink\" title=\"NT 头\"></a>NT 头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x86</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class=\"line\">    DWORD Signature;</span><br><span class=\"line\">    IMAGE_FILE_HEADER FileHeader;                       <span class=\"comment\">// 文件头</span></span><br><span class=\"line\">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      \t   <span class=\"comment\">// 可选头</span></span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//x64</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class=\"line\">    DWORD Signature;</span><br><span class=\"line\">    IMAGE_FILE_HEADER FileHeader;</span><br><span class=\"line\">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>\n\n<p>Signature: 签名，50450000H ===&gt;  “PE00”</p>\n<h3 id=\"NT-：文件头\"><a href=\"#NT-：文件头\" class=\"headerlink\" title=\"NT ：文件头\"></a>NT ：文件头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x86 x64相同</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD    Machine;                           <span class=\"comment\">// 运行平台  </span></span><br><span class=\"line\">    WORD    NumberOfSections;\t\t\t\t<span class=\"comment\">// 节的数量</span></span><br><span class=\"line\">    DWORD   TimeDateStamp;\t\t\t\t\t<span class=\"comment\">// 时间戳</span></span><br><span class=\"line\">    DWORD   PointerToSymbolTable;\t\t\t<span class=\"comment\">// 符号表指针</span></span><br><span class=\"line\">    DWORD   NumberOfSymbols;\t\t\t\t<span class=\"comment\">// 符号数量</span></span><br><span class=\"line\">    WORD    SizeOfOptionalHeader;\t\t\t<span class=\"comment\">// 可选头大小</span></span><br><span class=\"line\">    WORD    Characteristics;                 <span class=\"comment\">// 文件属性</span></span><br><span class=\"line\">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Machine：</p>\n<ul>\n<li>  0x014cH    x86</li>\n<li>  0x0200H    Intel 64</li>\n<li>  0x8664H    x64</li>\n</ul>\n</li>\n<li><p>Characteristics:</p>\n<ul>\n<li>  0x0002H    可执行文件</li>\n<li>  0x2000H    动态链接库</li>\n<li>  0x1000H    系统文件</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h1><img src=\"https://img-blog.csdn.net/20170611205306090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFpZGUyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"C_complie\" style=\"zoom:125%;\">\n\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>cpp.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure></li>\n<li><p>作用</p>\n<ol>\n<li>宏替换</li>\n<li>包含头文件</li>\n<li>条件编译</li>\n<li>处理预处理关键字</li>\n</ol>\n</li>\n<li><p>结果</p>\n<p>  ​    扩展的c源码，生成扩展名为 ‘.i ’ 的ASCII文件</p>\n<hr>\n</li>\n</ul>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>cc1.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -S main.i</span><br></pre></td></tr></table></figure></li>\n<li><p>结果</p>\n<p>  ​    将c源码翻译为汇编源码，生成扩展名为 ‘ .s ’的ASCII文件</p>\n<p>  ​    </p>\n<hr>\n</li>\n</ul>\n<h2 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>as.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c main.s</span><br></pre></td></tr></table></figure></li>\n<li><p>结果</p>\n<p>  ​    将汇编源码翻译为二进制代码，生成扩展名为 ‘ .o’ 的二进制文件 </p>\n</li>\n<li><p>注意</p>\n<p>  ​    无法直接运行，需要链接（<em>单个文件也需要链接</em>）</p>\n<hr>\n</li>\n</ul>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>collect2.exe</strong> / <strong>ld.exe</strong>  （静态链接器）</p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc main.o -o main</span><br></pre></td></tr></table></figure></li>\n<li><p>作用</p>\n<ol>\n<li>将众多.o文件合成为一个完整的可执行文件</li>\n<li>链接时，需要加入由编译器提供的启动代码，来调用main函数</li>\n<li>链接时，需要进行符号解析与地址重定位</li>\n</ol>\n</li>\n<li><p>结果</p>\n<p>  ​    在Windows环境下生成‘.exe’ 文件，在linux环境下没有固定扩展名</p>\n</li>\n</ul>\n<h3 id=\"静态链接\"><a href=\"#静态链接\" class=\"headerlink\" title=\"静态链接\"></a>静态链接</h3><ul>\n<li><p>定义</p>\n<p>  ​    在编译时完成的链接，调用 <strong>ld</strong> / <strong>collect2</strong> 链接程序，将所有.o文件整合</p>\n</li>\n<li><p>缺点</p>\n<p>  ​    重复代码较多，浪费计算机资源</p>\n</li>\n<li><p>具体过程</p>\n<ol>\n<li><p>符号解析</p>\n<ul>\n<li><p>作用</p>\n<p> ​    符号解析的目的是将符号的引用与符号的定义练习起来（如：函数的声明与实现）</p>\n</li>\n<li><p>实现</p>\n<p> ​    在每一个.o文件中都会包含一张符号表(.symtab)，用来记录：        </p>\n<p> ​        </p>\n <figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 本模块定义了哪些符号</span><br><span class=\"line\">（2） 本模块引用了哪些符号</span><br></pre></td></tr></table></figure>\n\n<p> ​        </p>\n</li>\n<li><p>注意</p>\n<p> ​    单个.c文件即为一个模块，整个工程以模块为单位进行组织</p>\n<p> ​    </p>\n</li>\n</ul>\n</li>\n<li><p>地址重定位</p>\n<ul>\n<li><p>作用  </p>\n<p> ​    将.o文件中的每个机器指令的逻辑地址，重定位为实际运行的地址</p>\n <figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果是裸机运行的，运行的地址就是内存的物理地址</span><br><span class=\"line\">2. 如果是基于OS运行的，运行地址就是虚拟内存的地址</span><br></pre></td></tr></table></figure></li>\n<li><p>逻辑地址</p>\n<p> ​    在每个节中，从零开始标号</p>\n</li>\n<li><p>虚拟地址</p>\n<ol>\n<li>在32位Linux操作系统下，虚拟地址为32位，从<u>0x08048000</u>开始<pre><code> 2. 在64位Linux操作系统下，虚拟地址为64位，从0x00000000000400000开始\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><ul>\n<li><p>定义</p>\n<p>  ​    在编译时只留下调用接口，当程序真正运行起来的时候，才去链接执行</p>\n</li>\n<li><p>使用时机</p>\n<p>  ​    使用动态链接库（DLL）时</p>\n<p>  ​    如printf函数由动态链接库提供，程序编译后，代码中不存在printf函数代码，只有其接口，当程序运行时，再去动态链接其所在的DLL，这里的接口是二进制代码，实质为该函数第一条指令的地址(相对地址 + 绝对地址)</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相对地址: 某成员在DLL中的相对位置； 绝对地址: DLL被加载到内存中后的物理地址</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>动态链接器。。。</p>\n</li>\n<li><p>链接过程与优点</p>\n<p>  ​    程序运行时，将**<u>整个</u>**DLL加载到内存之中，内存中所有相关进程共享该DLL的代码，减少了代码的冗余，提高了计算机空间资源的利用率</p>\n<blockquote>\n<p>因为DLL并不知道用户的程序需要该库中哪个变量或函数，所以需要将其完整加载到内存中</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"目标文件\"><a href=\"#目标文件\" class=\"headerlink\" title=\"目标文件\"></a>目标文件</h1><h2 id=\"目标文件类型\"><a href=\"#目标文件类型\" class=\"headerlink\" title=\"目标文件类型\"></a>目标文件类型</h2><h3 id=\"可重定位目标文件\"><a href=\"#可重定位目标文件\" class=\"headerlink\" title=\"可重定位目标文件\"></a>可重定位目标文件</h3><ul>\n<li>定义</li>\n</ul>\n<p>​    被用于静态链接的文件，都是看重定位目标文件</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是可重定位？</span><br><span class=\"line\">\t因为采用静态链接，逻辑地址需要被重定位为运行地址后才能被运行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>类型</p>\n<p>  ​    以‘‘**.a 、.lib**’’ 为扩展名的静态库文件以及以‘‘ <strong>.o</strong> ’’为扩展名的二进制文件都是<u>可重定位目标文件</u></p>\n</li>\n</ul>\n<h3 id=\"可执行目标文件\"><a href=\"#可执行目标文件\" class=\"headerlink\" title=\"可执行目标文件\"></a>可执行目标文件</h3><p>​        就是可执行的文件</p>\n<h3 id=\"共享目标文件\"><a href=\"#共享目标文件\" class=\"headerlink\" title=\"共享目标文件\"></a>共享目标文件</h3><p>​        本质就是动态库文件DLL，DLL也被称为共享库</p>\n<hr>\n<h2 id=\"目标文件格式\"><a href=\"#目标文件格式\" class=\"headerlink\" title=\"目标文件格式\"></a>目标文件格式</h2><pre><code>### 裸机（无OS）\n</code></pre>\n<p>​    “ .bin ” 文件格式，直接运行在<strong>arm</strong>裸机上</p>\n<h3 id=\"UNIX系统\"><a href=\"#UNIX系统\" class=\"headerlink\" title=\"UNIX系统\"></a>UNIX系统</h3><ol>\n<li><p>早期unix操作系统</p>\n<p> ​    使用“ <strong>.out</strong>  ” 文件格式，在UNIX操作系统上编译程序后，若不指定可执行文件名，会默认命名为 “ a.out ”</p>\n</li>\n<li><p>system V unix</p>\n<p> ​    a.out 文件格式变为 <strong>COFF</strong> ( Common Object File Format : 一般目标文件格式) </p>\n</li>\n<li><p>线代Unix</p>\n<p> ​    改用 <strong>ELF</strong>（Executable and Linkable Format：可执行、可链接格式）</p>\n</li>\n</ol>\n<h3 id=\"Windows系统\"><a href=\"#Windows系统\" class=\"headerlink\" title=\"Windows系统\"></a>Windows系统</h3><p>​    采用 <strong>PE</strong> （Portable Executable：可移植、可执行格式）</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里的可移植并非指PE格式文件可跨平台执行，而是指兼容多种语言</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Linux系统\"><a href=\"#Linux系统\" class=\"headerlink\" title=\"Linux系统\"></a>Linux系统</h3><p>​    与现代Unix相同，与使用<strong>ELF</strong>格式，linux操作系统脱胎于unix，因此在linux操作系统编译得到的可执行文件上也默认命名为“ a.out ”，但是文件格式与早期Unix并不一致</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如何理解ELF（可执行、可链接）的含义？</span><br><span class=\"line\">1. 可重定位目标文件、共享目标文件：可以被链接</span><br><span class=\"line\">2. 可执行目标文件：能被执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ELF格式可重定位目标文件\"><a href=\"#ELF格式可重定位目标文件\" class=\"headerlink\" title=\"ELF格式可重定位目标文件\"></a>ELF格式可重定位目标文件</h3><h4 id=\"组成结构图\"><a href=\"#组成结构图\" class=\"headerlink\" title=\"组成结构图\"></a>组成结构图</h4><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo10%2Fcd31ce13972e4a6a82284b1b07faabae.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647693494&t=81dd5f93e3a64f75b1a77e522cad6df5\" alt=\"点击查看图片来源\" style=\"zoom: 67%;\">\n\n<h4 id=\"ELF-Header\"><a href=\"#ELF-Header\" class=\"headerlink\" title=\"ELF Header\"></a>ELF Header</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 readelf -h 查看elf头信息</span><br><span class=\"line\">readelf -h file</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"file:///C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\956489228\\QQ\\WinTemp\\RichOle\\YQZ8(L~D)SSOQ65HK]0YTDS.png\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ident[<span class=\"number\">16</span>];        <span class=\"comment\">/* ELF &quot;magic number&quot; */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_type[<span class=\"number\">2</span>];      <span class=\"comment\">/* Identifies object file type */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_machine[<span class=\"number\">2</span>];       <span class=\"comment\">/* Specifies required architecture */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_version[<span class=\"number\">4</span>];       <span class=\"comment\">/* Identifies object file version */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_entry[<span class=\"number\">4</span>];     <span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phoff[<span class=\"number\">4</span>];     <span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shoff[<span class=\"number\">4</span>];     <span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_flags[<span class=\"number\">4</span>];     <span class=\"comment\">/* Processor-specific flags */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ehsize[<span class=\"number\">2</span>];        <span class=\"comment\">/* ELF header size in bytes */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phentsize[<span class=\"number\">2</span>];     <span class=\"comment\">/* Program header table entry size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phnum[<span class=\"number\">2</span>];     <span class=\"comment\">/* Program header table entry count */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shentsize[<span class=\"number\">2</span>];     <span class=\"comment\">/* Section header table entry size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shnum[<span class=\"number\">2</span>];     <span class=\"comment\">/* Section header table entry count */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shstrndx[<span class=\"number\">2</span>];      <span class=\"comment\">/* Section header string table index */</span></span><br><span class=\"line\">&#125; Elf32_External_Ehdr;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"e-ident\"><a href=\"#e-ident\" class=\"headerlink\" title=\"e_ident\"></a><strong>e_ident</strong></h5><p>e_ident 是一个包含 16 字节的数组成员，对应 readelf -h 给出的 magic 部分.</p>\n<p>magic 部分就是我们所说的魔数，魔数通常就是自定义的识别码，对于 32 位的 elf 文件而言，magic 部分有 16 个字节.</p>\n<p>大部分的文件组织形式都是这样的，头部是一串特殊的识别码，标识该文件的一些概要信息，主要用于外部程序快速地对这个文件进行识别，快速地判断文件类型.</p>\n<p>但是 readelf 命令仅仅是显示了对应的二进制码，并没有进一步显示整个魔数字段的详细信息，关于这一部分就需要参考 readelf 源码来进行分析了，分析结果如下:</p>\n<ul>\n<li>  前四个字节:7f 45 4c 46，识别码， 0x45，0x4c，0x46 三个字节的 ascii 码对应 ELF 字母，通过这四个字节就可以判断文件是不是 elf 文件.</li>\n<li>  第五个字节:其中 01 表示 32 位 elf 文件，02 表示 64 位.</li>\n<li>  第六个字节:其中 01 表示 小端模式，02 表示 大端模式.</li>\n<li>  第七个字节:表示 EI_version，1 表示 EV_CURRENT，只有 1 才是合理的(代码中是 EI_versoin，但是博主没有进一步具体研究).</li>\n<li>  第八个字节: 00 表示 OS_ABI</li>\n<li>  第九个字节: 00 表示 ABI version</li>\n<li>  其它字段，源码中没有找到对应的解析，暂定为reserver.</li>\n</ul>\n<ul>\n<li>xx</li>\n</ul>\n<h5 id=\"e-type\"><a href=\"#e-type\" class=\"headerlink\" title=\"e_type\"></a>e_type</h5><p>type 表示 elf 文件的细分类型，总共有四种:</p>\n<ul>\n<li>  可重定位的目标文件</li>\n<li>  可执行文件</li>\n<li>  动态链接文件</li>\n<li>  coredump 文件，这是系统生成的调试文件.</li>\n</ul>\n<p>这四种类型的文件各有各的特点，比如可重定位的目标文件针对的是链接器.</p>\n<p>而可执行文件针对加载器，需要被静态加载到内存中执行，而动态链接文件则是运行过程中的加载.</p>\n<p>coredump 文件主要保存的是系统出错时的运行断点信息，方便人为地或者借助 gdb 分析 bug.</p>\n<h5 id=\"e-machine\"><a href=\"#e-machine\" class=\"headerlink\" title=\"e_machine\"></a>e_machine</h5><p>标识指定的机器，比如 40 代表 ARM.</p>\n<p>其它的比如 x86，mips 等都对应不同的编码.</p>\n<h5 id=\"e-version\"><a href=\"#e-version\" class=\"headerlink\" title=\"e_version\"></a>e_version</h5><p>四个字节的 version code</p>\n<h5 id=\"e-entry\"><a href=\"#e-entry\" class=\"headerlink\" title=\"e_entry\"></a>e_entry</h5><p>程序的入口虚拟地址，对于可重定位的目标文件默认是0，而对于可执行文件而言是真实的程序入口.</p>\n<p>程序入口是被加载器使用的，在程序加载过程中会读取该程序入口，作为应用程序的开始执行地址，在实际的加载过程中，内核加载完当前 elf 可执行文件之后其实并不是跳到该入口地址，而是先执行动态链接器代码，在动态链接完成之后才会跳到该入口地址。</p>\n<h5 id=\"e-phoff\"><a href=\"#e-phoff\" class=\"headerlink\" title=\"e_phoff\"></a>e_phoff</h5><p> program header table 的起始偏移地址，</p>\n<h5 id=\"e-shoff\"><a href=\"#e-shoff\" class=\"headerlink\" title=\"e_shoff\"></a>e_shoff</h5><p> section header table 的起始偏移地址，</p>\n<h5 id=\"e-flags\"><a href=\"#e-flags\" class=\"headerlink\" title=\"e_flags\"></a>e_flags</h5><p>和处理器相关的标志位集合，不同的处理器有不同的参数，根据 e_machine 进行解析.</p>\n<h5 id=\"e-ehsize\"><a href=\"#e-ehsize\" class=\"headerlink\" title=\"e_ehsize\"></a>e_ehsize</h5><p>指示 elf header 的 size，对于 arm 而言，52 或者 64.</p>\n<h5 id=\"e-phentsize\"><a href=\"#e-phentsize\" class=\"headerlink\" title=\"e_phentsize\"></a>e_phentsize</h5><p>每一个 program header 的 size，在可重定位目标文件中为 0.</p>\n<h5 id=\"e-phnum\"><a href=\"#e-phnum\" class=\"headerlink\" title=\"e_phnum\"></a>e_phnum</h5><p>该文件中一共有多少个 program header，在可重定位目标文件中为0.</p>\n<h5 id=\"e-shentsize\"><a href=\"#e-shentsize\" class=\"headerlink\" title=\"e_shentsize\"></a>e_shentsize</h5><p>文件中每一个section header 的大小，通常是 40.</p>\n<h5 id=\"e-shnum\"><a href=\"#e-shnum\" class=\"headerlink\" title=\"e_shnum\"></a>e_shnum</h5><p>该文件中一共有多少个 section header，上述的示例文件中为 10 个.</p>\n<h5 id=\"e-shstrndx\"><a href=\"#e-shstrndx\" class=\"headerlink\" title=\"e_shstrndx\"></a>e_shstrndx</h5><p>在 elf 格式的文件中，符号，section，文件的命名通常是字符串，这些字符串并不会保存在其对应的 section 中，而是统一地使用一个字符串表来保存，该字段指示节标题字符串所在的 section，在上面的示例中，section 标题(.text，.data，…)对应的 e_shstrndx 即段序号为 7，即保存在 .shstrtab 段中.这些 section 标题在链接的过程中需要使用到，在程序执行时是无用的，所以分开有利于精简 section 内容的大小，从而程序加载运行时需要更小的空间.</p>\n<p>除了 section 标题，还有符号名，文件名等字符串，这些默认会被保存在 .strtab section 中.</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">ELF</span>文件大小：</span><br><span class=\"line\"><span class=\"variable\">Size</span> <span class=\"operator\">=</span> <span class=\"type\">e_shoff</span> <span class=\"operator\">+</span> <span class=\"type\">e_shnum</span> <span class=\"operator\">*</span> <span class=\"type\">e_shentsize</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"text-Section\"><a href=\"#text-Section\" class=\"headerlink\" title=\".text Section\"></a>.text Section</h4><p>​    <u><strong>==只读==</strong></u> <strong>代码</strong>节，存放所有函数的机器指令即程序代码，有些常量也会与指令一起存放在此节中（如字面量）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a = a + <span class=\"number\">100</span>;     <span class=\"comment\">// 此处的100会与指令一并存放在该节</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rodata-Section\"><a href=\"#rodata-Section\" class=\"headerlink\" title=\".rodata Section\"></a>.rodata Section</h4><p>​    <strong><u>==只读==</u></strong> <strong>数据</strong>节，存放常量数据（如字符串常量）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *str = <span class=\"string\">&quot;HelloWorld!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);        <span class=\"comment\">// 这里的“%s” 与 “HelloWorld！”会存放在该节</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"data-Section\"><a href=\"#data-Section\" class=\"headerlink\" title=\".data Section\"></a>.data Section</h4><p>​    <u><strong>==可写==</strong></u> <strong>数据</strong>节，存放：</p>\n<ol>\n<li><p>已初始化的全局变量</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> global = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,global + <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>已初始化的静态局部变量</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getCount</span><span class=\"params\">(<span class=\"type\">char</span> *arr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;         <span class=\"comment\">// 该静态局部变量已被初始化</span></span><br><span class=\"line\">    count += <span class=\"built_in\">strlen</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"bss-Section\"><a href=\"#bss-Section\" class=\"headerlink\" title=\".bss Section\"></a>.bss Section</h4><p>​    <u><strong>==可写==</strong></u> <strong>数据</strong>节</p>\n<ol>\n<li><p>未初始化的全局变量</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> global;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,global + <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>未初始化的静态局部变量</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getCount</span><span class=\"params\">(<span class=\"type\">char</span> *arr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count;         <span class=\"comment\">// 该静态局部变量未被初始化</span></span><br><span class=\"line\">    count = <span class=\"built_in\">strlen</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  由于.bss节存放没有初始化的数据，所以其并不占有真实地存储空间，.bss 节在可重定位目标文件中只作占位符，当程序真正运行起来时才会在内存中开辟.bss节的空间，并为其中的数据赋上初始值（0）</p>\n</li>\n</ol>\n<hr>\n<h4 id=\"symtab-Section\"><a href=\"#symtab-Section\" class=\"headerlink\" title=\".symtab Section\"></a>.symtab Section</h4><p>​    <strong>符号表</strong>（symbol table），用于存放可重定位目标文件中的 <strong>==定义==</strong> 与 <strong>==引用==</strong> 的全局符号信息，包括全局变量、函数.symtab</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -s main.o     <span class=\"comment\"># 查看符号表</span></span><br><span class=\"line\"></span><br><span class=\"line\">gcc -s main.o -o main      <span class=\"comment\"># 编译时剔除符号信息与重定位信息</span></span><br><span class=\"line\">strip main.o   <span class=\"comment\"># 丢弃目标文件中的符号</span></span><br></pre></td></tr></table></figure>\n\n<p>符号表包含很多条目，每个条目记录的就是一个符号的基本信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf32_Word    st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf32_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">&#125; Elf32_Sym;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf64_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">  Elf64_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf64_Xword   st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>1）name</strong></p>\n<p>​                    name中记录的并不是名字的字符串，我们前面说过所有的字符串都是放在了.strtab中。name里面只记录字符            串在 <strong>.strtab</strong> 中的偏移，通过这个偏移就能在 <strong>.strtab</strong> 中索引到符号的名字。</p>\n<p>​            e.g.</p>\n<p>​                name = 5 //偏移5<br>​                假如.strtab中的内容为main\\0fun2\\0a_va\\0……<br>​                使用偏移5到.strtab中进行搜索，当遇到\\0时就截止，那么取出来的就是符号fun2。</p>\n<p>​    <strong>2）value</strong></p>\n<p>​            放的是地址：指向符号所代表的空间。不过对于.o（可重定位目标文件）和可执行目标文件来说，value的值有所不        同。</p>\n<ul>\n<li>  可重定位目标文件</li>\n</ul>\n<p>​                    value总中放的只是相对于节起始地址的偏移。</p>\n<ul>\n<li>  可执行目标文件</li>\n</ul>\n<p>​                    value中放的是绝对地址。“可重定位目标文件”被连接在一起后，value中放的是链接时重定位后的绝对地址。</p>\n<p>​    <strong>3）size</strong></p>\n<p>​            size代表的是value所指向空间的大小，毕竟value只是起始地址，不能说明空间的大小。</p>\n<p>​            比如：</p>\n<ul>\n<li><p>​    如果符号是初始化了的全局变量的话<br>  ​     size代表的全局变量在.data中所占字节数。</p>\n</li>\n<li><p>如果符号是函数的话</p>\n<pre><code>   size代表的是函数指令在.text中所占空间的大小\n</code></pre>\n</li>\n</ul>\n<p>​    <strong>4）type</strong></p>\n<p>​        符号类型，大致有如下几种类型。</p>\n<ul>\n<li>  FUNC：符号代表的是函数</li>\n<li>  OBJECT：符号代表的是全局变量</li>\n<li>  FILE：符号是源文件的名字</li>\n<li>  SECTION：该符号关联的实体是个节，用于重定位</li>\n<li>  COMMON：未初始化的全局变量，储存在.bss节</li>\n<li>  NOTYPE：未知或未指定类型</li>\n<li>  WEAK：弱符号，在链接时忽略弱符号的声明，采纳强符号的定义，可用来解决多文件符号冲突问题</li>\n</ul>\n<p>​    <strong>5）bind</strong></p>\n<p>​            就两种情况，LCOAL、GLOBAL</p>\n<ul>\n<li>  bind=LOCAL</li>\n</ul>\n<p>​                    表示符号是本地的：符号在模块中定义后，只能由本模块引用，static修饰的全局变量和函数就是这种情况。</p>\n<ul>\n<li>  bind=CLOBAL(全局符号)</li>\n</ul>\n<p>​                    表示符号在本模块定义，但是可以被其它模块引用（使用），extern修饰的全局变量和函数就是这种情况。</p>\n<p>​    <strong>6）section</strong></p>\n<p>​        section的值有四种情况，节索引号、ABS、UNDEF、COM</p>\n<ul>\n<li>  section=节索引号</li>\n</ul>\n<p>​                说明符号所对应的空间在哪个节里面。</p>\n<ul>\n<li>  section=ABS</li>\n</ul>\n<p>​                表示该符号不需要被“链接程序”处理。</p>\n<p>​                比如，如果符号名是***.c，这个符号不是全局变量、不是函数，只是一个源文件名而已，链接器（ld/collect2）            在链接“可重定位目标文件”时，这个符号不需要被处理。</p>\n<ul>\n<li>  section=UNDEF</li>\n</ul>\n<p>​                表示这个符号，只是在本模块中被引用了，这个符号并不是由本模块定义的，表示这个符号被定义在了其它模块            中，链接时要到其它模块中去找搜寻它的定义。</p>\n<ul>\n<li><p>section=COM</p>\n<p>  表示还未被分配空间（位置）的未初始化的数据目标，比如未初始化的全局变量(.bss)。</p>\n</li>\n</ul>\n<p>​    .symtab 所记录的符号，严格说起来就两种：</p>\n<ol>\n<li>全局符号（由extern修饰的全局变量或函数）<ul>\n<li>  在本地文件声明，在其他文件中被引用</li>\n<li>  在其他文件声明，在本地文件中被引用</li>\n</ul>\n</li>\n<li>本地符号（由static修饰的静态变量或函数）<ul>\n<li>  在本地文件声明，且只能在本模块中使用</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"rel-text-Section-及-rel-data-Section\"><a href=\"#rel-text-Section-及-rel-data-Section\" class=\"headerlink\" title=\".rel.text Section 及 .rel.data Section\"></a>.rel.text Section 及 .rel.data Section</h4><p>​    用于多个.o文件链接在一起时，需要根据这两个节中的重定位信息，将各个文件中的 .text节 与 data节分别整合 </p>\n<h4 id=\"debug-Section-及-line-Section\"><a href=\"#debug-Section-及-line-Section\" class=\"headerlink\" title=\".debug Section 及 .line Section\"></a>.debug Section 及 .line Section</h4><p>​    前者存放调试信息，后者存放代码行号信息，编译时需要加入 -g 选项后，才会在这两节中存放相关调试信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g main.c -o main</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"strtab-Section\"><a href=\"#strtab-Section\" class=\"headerlink\" title=\".strtab Section\"></a>.strtab Section</h4><p>​    字符串表，挨个存放：</p>\n<ul>\n<li>  .symtab 所用的符号名字</li>\n<li>  .debug 所用到的符号名字</li>\n<li>  每个节的段名</li>\n<li>  源文件名字</li>\n<li>  等等</li>\n</ul>\n<h4 id=\"Section-Header-Table\"><a href=\"#Section-Header-Table\" class=\"headerlink\" title=\"Section Header Table\"></a>Section Header Table</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word sh_name; <span class=\"comment\">/* Section name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Word sh_type; <span class=\"comment\">/* Section type */</span></span><br><span class=\"line\">  Elf32_Word sh_flags; <span class=\"comment\">/* Section flags */</span></span><br><span class=\"line\">  Elf32_Addr sh_addr; <span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf32_Off sh_offset; <span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf32_Word sh_size; <span class=\"comment\">/* Section size in bytes */</span></span><br><span class=\"line\">  Elf32_Word sh_link; <span class=\"comment\">/* Link to another section */</span></span><br><span class=\"line\">  Elf32_Word sh_info; <span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf32_Word sh_addralign; <span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf32_Word sh_entsize; <span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -S main.o</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>  节名称</p>\n</li>\n<li><p>  节的类型</p>\n</li>\n<li><p>  节的属性（读写权限）</p>\n</li>\n<li><p>  节在ELF文件中所占的长度</p>\n</li>\n<li><p>  节的对齐方式</p>\n</li>\n<li><p>  偏移量</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"ELF格式可执行目标文件\"><a href=\"#ELF格式可执行目标文件\" class=\"headerlink\" title=\"ELF格式可执行目标文件\"></a>ELF格式可执行目标文件</h3><p><img src=\"https://img-blog.csdnimg.cn/img_convert/494d134bb25941bf46aba57ba98b4f5c.png\" alt=\"ELF和sectionheadertable(节头表)\"></p>\n","site":{"data":{}},"cover":"/img/c4.png","excerpt":"","more":"<h1 id=\"汇编知识\"><a href=\"#汇编知识\" class=\"headerlink\" title=\"汇编知识\"></a>汇编知识</h1><h4 id=\"汇编语言的组成\"><a href=\"#汇编语言的组成\" class=\"headerlink\" title=\"汇编语言的组成\"></a>汇编语言的组成</h4><ol>\n<li>  汇编指令：机器码的助记符，有对应的机器码</li>\n<li>  伪指令：为汇编过程提供控制信息，没有对应的机器码，计算机并不执行，编译器执行</li>\n<li>  其他符号：由编译器识别，没有对应的机器码</li>\n</ol>\n<h4 id=\"8086PC-内存地址分配\"><a href=\"#8086PC-内存地址分配\" class=\"headerlink\" title=\"8086PC 内存地址分配\"></a>8086PC 内存地址分配</h4><p>8086PC 具有宽度为20的地址总线，宽度为16的数据总线</p>\n<p>00000 ~ 9FFFF     主存储器RAM</p>\n<p>A0000 ~ BFFFF    显存地址</p>\n<p>C0000 ~ FFFFF    各类ROM</p>\n<h4 id=\"Debug程序\"><a href=\"#Debug程序\" class=\"headerlink\" title=\"Debug程序\"></a>Debug程序</h4><ul>\n<li>  -u : check a memory segment in assembly way    以数据的形式查看一段内存</li>\n<li>  -d : check a memory segment in data way             以代码的形式查看一段内存</li>\n<li>  -e : edit a memory segment                    编辑一段内存地址，使用空格进行后移                   </li>\n<li>  -a : input a series of assembly code              默认在cs:ip位置处编写一段汇编代码，可指定其他内存位置</li>\n<li>  -r : check all registers or update a register       查看所用通用寄存器或者修改某寄存器的值</li>\n<li>  -t : debug a programme step by step with going into sub programme          单步调试，进入子程序</li>\n<li>  -p : debug a programme step by step without going into sub programme      单步调试，不进入子程序，跳过循环</li>\n<li>  -n : rename a file           文件重命名</li>\n<li>  -g : don’t stop executing the programme until the target address you set comes           运行程序到你设定的地址</li>\n</ul>\n<h2 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h2><p>​    是CPU内部的存储器，是用来暂存计算数据及结果，是程序员可以进行操纵的空间，通过操纵寄存器进而达到操纵CPU的目的</p>\n<p>对于8086CPU来说，总共有14个</p>\n<h3 id=\"数据寄存器\"><a href=\"#数据寄存器\" class=\"headerlink\" title=\"数据寄存器\"></a>数据寄存器</h3><p>其中通用寄存器有4个{AX，BX，CX，DX}，用来存放数据，每一个通用寄存器是由高低两个8位寄存器组成的16位寄存器{AX = AH + AL}；</p>\n<blockquote>\n<p>EAX : 32位寄存器                  RAX : 64位寄存器 </p>\n<p>EAX 位于 RAX 的低32位</p>\n<p>AX 位于 EAX 的低16位</p>\n</blockquote>\n<p>进行8位运算时，两个8位寄存器互不影响，不进位不借位，进位值与借位值存在标志寄存器的<strong>CF标志位</strong>中</p>\n<p>进行16位运算时，  高位溢出舍弃</p>\n<h4 id=\"MOV-amp-ADD-amp-SUB-指令\"><a href=\"#MOV-amp-ADD-amp-SUB-指令\" class=\"headerlink\" title=\"MOV &amp; ADD &amp; SUB 指令\"></a>MOV &amp; ADD &amp; SUB 指令</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,bx      ; 将ax中的数据与bx相加后结果送入ax</span><br><span class=\"line\">mov ax,5FC5    ; 将ax的值改为5fc5</span><br><span class=\"line\">mov al,bh      ; 将ax的低8位的值改为bx高8位的值</span><br><span class=\"line\">add ax,05A6    ; ax的值加上05a6后，送入ax中</span><br><span class=\"line\">add bh,al      ; 将bx的高8位加上ax的低8位</span><br><span class=\"line\">sub ax,ax      ; 减法运算</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"地址寄存器\"><a href=\"#地址寄存器\" class=\"headerlink\" title=\"地址寄存器\"></a>地址寄存器</h3><ul>\n<li><p>段地址寄存器</p>\n<p>  {CS，DS，SS，ES} = {代码段，数据段，堆栈段，其他段}</p>\n</li>\n<li><p>偏移地址寄存器</p>\n<p>  {SP，BP，SI，DI，IP，BX} = {，，，，指令指针，}</p>\n</li>\n<li><p>设计目的</p>\n<p>  8086CPU地址总线宽度为20，而寄存器位长16，那么就需要用两个寄存器来存一个物理地址</p>\n</li>\n</ul>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">PhysicalAddr</span> <span class=\"operator\">=</span> <span class=\"variable\">SegmentAddr</span> <span class=\"operator\">*</span> <span class=\"number\">10</span><span class=\"variable\">h</span> <span class=\"operator\">+</span> <span class=\"variable\">OffsetAddr</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CS-IP-代码段\"><a href=\"#CS-IP-代码段\" class=\"headerlink\" title=\"CS : IP 代码段\"></a>CS : IP 代码段</h3><blockquote>\n<p>  代码段寄存器 : 指令指针寄存器</p>\n</blockquote>\n<p>CPU将CS:IP指向的内存单元中的内容当做代码执行 </p>\n<p>指令执行过程：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓冲区</span><br><span class=\"line\">2. IP = IP + Length(Instruction) 从而指向下一条指令的地址</span><br><span class=\"line\">3. 执行指令，转到步骤 1</span><br></pre></td></tr></table></figure>\n\n<p>在8086CPU加电启动或复位后，CS被置为FFFFH，IP被置为0000H</p>\n<h4 id=\"JMP-指令\"><a href=\"#JMP-指令\" class=\"headerlink\" title=\"JMP 指令\"></a>JMP 指令</h4><p>转移指令，修改CS:IP的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 2000:0010    ; 修改CS为2000，修改IP为0010</span><br><span class=\"line\">jmp ax           ; 修改IP为AX中存储的值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DS-Offset-数据段\"><a href=\"#DS-Offset-数据段\" class=\"headerlink\" title=\"DS : [Offset] 数据段\"></a>DS : [Offset] 数据段</h3><blockquote>\n<p>  数据段寄存器 : [偏移地址]</p>\n</blockquote>\n<p>CPU将DS:[Offset]指向的内存地址中的内容当做数据读写（<u><strong>需要注意小端序还是大端序</strong></u>）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx,3001</span><br><span class=\"line\">mov ds,bx         ; 将BX中存储的段地址送入DS数据段寄存器中，8086不允许使用MOV指令直接给段寄存器赋值</span><br><span class=\"line\">mov ax,[0101]     ; 将内存中地址为 DS * 10h + 0101h 中的数据送入AX中</span><br><span class=\"line\">mov [0102],ax     ; 将AX中的数据送入到内存地位为 DS * 10h + 0102h 的地方</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SS-SP-堆栈段\"><a href=\"#SS-SP-堆栈段\" class=\"headerlink\" title=\"SS : SP 堆栈段\"></a>SS : SP 堆栈段</h3><blockquote>\n<p>  堆栈段寄存器 : 栈顶指针寄存器</p>\n</blockquote>\n<p>8086CPU的入栈操作和出栈操作都是以<strong>字</strong>为单位进行的；入栈时，栈顶由高地址向低地址的方向增长(小端序)</p>\n<h4 id=\"PUSH-amp-POP-指令\"><a href=\"#PUSH-amp-POP-指令\" class=\"headerlink\" title=\"PUSH &amp; POP 指令\"></a>PUSH &amp; POP 指令</h4><p>出栈 &amp; 入栈</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;指定栈顶界限，假定栈段范围为10000 ~ 1001F</span><br><span class=\"line\">mov ax,1000</span><br><span class=\"line\">mov ss,ax</span><br><span class=\"line\">;设置栈顶指针,空栈时,栈顶指针指向栈底后一位地址</span><br><span class=\"line\">mov sp,0020</span><br><span class=\"line\">;入栈：</span><br><span class=\"line\">;\tSP = SP - 2       </span><br><span class=\"line\">mov bx,3FFF</span><br><span class=\"line\">push bx</span><br><span class=\"line\">push ds</span><br><span class=\"line\">push [0]</span><br><span class=\"line\">;出栈：</span><br><span class=\"line\">;\tSP = SP + 2</span><br><span class=\"line\">pop [0]</span><br><span class=\"line\">pop ds</span><br><span class=\"line\">pop bx</span><br></pre></td></tr></table></figure>\n\n<p><strong>当执行修改SS堆栈段寄存器的值时，下一条指令也会紧接着执行</strong></p>\n<h2 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">; 数据段</span><br><span class=\"line\">data segment</span><br><span class=\"line\">date ends</span><br><span class=\"line\">; 堆栈段</span><br><span class=\"line\">stack segment stack</span><br><span class=\"line\">stack ends</span><br><span class=\"line\">; 代码段</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,4500H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ss,ax</span><br><span class=\"line\">\tmov sp,0020H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,0D200H      ; 在汇编源程序中，数据不能以字母开头，若最高位＞9时，需要在前面补0</span><br><span class=\"line\">\tmov ds:[0],ax</span><br><span class=\"line\">    push ds:[0]</span><br><span class=\"line\">    pop bx</span><br><span class=\"line\">    mov ds:[2],bx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 返回上级程序</span><br><span class=\"line\">\tmov ax,4c00H</span><br><span class=\"line\">\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BX-amp-LOOP-指令\"><a href=\"#BX-amp-LOOP-指令\" class=\"headerlink\" title=\"[BX] &amp; LOOP 指令\"></a>[BX] &amp; LOOP 指令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov bx,0010H   </span><br><span class=\"line\">mov ax,50F0H</span><br><span class=\"line\">mov ds:[bx],ax   ; 将bx寄存器中的数据当做地址偏移量</span><br></pre></td></tr></table></figure>\n\n<p>​        CX寄存器中的值可作为loop指令循环次数，每次减一，知道减为零结束循环</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov bx,5H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov al,ds:[bx]</span><br><span class=\"line\">\tmov ah,0H</span><br><span class=\"line\">\tmov dx,0H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov cx,5            ; 初始化循环次数</span><br><span class=\"line\">s: \tadd dx,ax           ; 定义循环体</span><br><span class=\"line\">\tloop s              ; 开始循环</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,004cH</span><br><span class=\"line\">\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>综合运用[bx]&amp;loop</p>\n<h3 id=\"INC-指令\"><a href=\"#INC-指令\" class=\"headerlink\" title=\"INC 指令\"></a>INC 指令</h3><p>​    数值自增一</p>\n<h3 id=\"DEC-指令\"><a href=\"#DEC-指令\" class=\"headerlink\" title=\"DEC 指令\"></a>DEC 指令</h3><p>​    数值自减一</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; \t计算从10000H ~ 1000aH地址中所有数值的和，储存在dx中</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ax,1000H</span><br><span class=\"line\">\tmov ds,ax</span><br><span class=\"line\">\tmov bx,0H</span><br><span class=\"line\"></span><br><span class=\"line\">\tmov dx,0H</span><br><span class=\"line\">\tmov cx,0aH</span><br><span class=\"line\"></span><br><span class=\"line\">s: \tmov al,ds:[bx]</span><br><span class=\"line\">\tmov ah,0H</span><br><span class=\"line\">\tadd dx,ax</span><br><span class=\"line\">\tinc bx</span><br><span class=\"line\">\tloop s</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"DW-伪指令-amp-start-标号\"><a href=\"#DW-伪指令-amp-start-标号\" class=\"headerlink\" title=\"DW 伪指令 &amp; start 标号\"></a>DW 伪指令 &amp; start 标号</h2><p>定义字型数据(define word)，可在代码段中存放提前定义好的数据</p>\n<p><strong>start</strong> 标号用来标识程序的入口，即是初始化CS:IP的值，用 <strong>end</strong> 指令来声明<strong>start</strong>标号的作用（程序入口）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 定义数据</span><br><span class=\"line\">\tdw 0123H,0a446H,5FF6H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t; 代码</span><br><span class=\"line\">start:\tmov bx,0</span><br><span class=\"line\">\t\tmov ax,0</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tadd ax,cs:[bx]</span><br><span class=\"line\">\t\tadd bx,2H</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分段\"><a href=\"#分段\" class=\"headerlink\" title=\"分段\"></a>分段</h3><p>​    将数据、代码、栈三段分立，方便管理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdw 0123H,0456H,0789H,0abcH,0defH</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment stack</span><br><span class=\"line\">\tdw 0H,0H,0H,0,0,0,0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\t</span><br><span class=\"line\">\t\tmov ax,data</span><br><span class=\"line\">\t\tmov ds,ax         ; 分配数据段</span><br><span class=\"line\">\t\tmov ax,stack</span><br><span class=\"line\">\t\tmov ss,ax         ; 分配栈段</span><br><span class=\"line\">\t\tmov sp,0eH</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\">\t\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"地址定位与数据处理\"><a href=\"#地址定位与数据处理\" class=\"headerlink\" title=\"地址定位与数据处理\"></a>地址定位与数据处理</h2><h3 id=\"AND-amp-OR-指令\"><a href=\"#AND-amp-OR-指令\" class=\"headerlink\" title=\"AND &amp; OR 指令\"></a>AND &amp; OR 指令</h3><p>​    二进制逻辑与或运算</p>\n<h3 id=\"XOR-指令\"><a href=\"#XOR-指令\" class=\"headerlink\" title=\"XOR 指令\"></a>XOR 指令</h3><p>​    异或运算，常用于main函数设置返回值0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xor eax,eax     ; 该命令执行速度比 mov ax,0 要快</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串型数据-amp-DB-伪指令\"><a href=\"#字符串型数据-amp-DB-伪指令\" class=\"headerlink\" title=\"字符串型数据 &amp; DB 伪指令\"></a>字符串型数据 &amp; DB 伪指令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data segment</span><br><span class=\"line\">\tdb &#x27;string&#x27;</span><br><span class=\"line\">data ends</span><br><span class=\"line\">; low -&gt; up</span><br><span class=\"line\">or al,00100000</span><br><span class=\"line\">; up -&gt; low</span><br><span class=\"line\">and al,11011111</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"灵活定位-amp-DI-amp-SI-amp-BP\"><a href=\"#灵活定位-amp-DI-amp-SI-amp-BP\" class=\"headerlink\" title=\"灵活定位 &amp; DI &amp; SI &amp; BP\"></a>灵活定位 &amp; DI &amp; SI &amp; BP</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,ds:[bx+100]</span><br><span class=\"line\">mov ax,ds:[bx+di]</span><br><span class=\"line\">mov ax,ds:[bx][si]</span><br><span class=\"line\">mov ax,ds:[bx+si+100]</span><br><span class=\"line\">mov ax,ds:[bx][si].100</span><br><span class=\"line\">mov ax,ds:[bp+si+100]</span><br><span class=\"line\">mov ax,ds:[bp][si].100</span><br></pre></td></tr></table></figure>\n\n<p>SI &amp; DI ：16位寄存器，无法分割为两个8位寄存器</p>\n<p>BP：<a href=\"#BP%E5%AF%84%E5%AD%98%E5%99%A8\">见此处</a></p>\n<h3 id=\"X-PTR\"><a href=\"#X-PTR\" class=\"headerlink\" title=\"X PTR\"></a>X PTR</h3><p><strong>指明数据长度的方式</strong>：</p>\n<ul>\n<li><p>通过寄存器名指明数据长度</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1H</span><br><span class=\"line\">mov al,1H</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>  通过操作符 X PTR 指明数据长度</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov word ptr ds:[0],1H</span><br><span class=\"line\">mov byte ptr ds:[2],1H</span><br><span class=\"line\">mov byte ptr ds:[bx+si+10],&#x27;F&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DIV-指令\"><a href=\"#DIV-指令\" class=\"headerlink\" title=\"DIV 指令\"></a>DIV 指令</h3><ol>\n<li>  除数：在寄存器或内存</li>\n<li>被除数：默认在AX或DX<ul>\n<li>  除数为8位，被除数为16位，则被除数放在AX</li>\n<li>  除数为16位，被除数为32位，则被除数在DX与AX，DX放高位，AX放低位</li>\n</ul>\n</li>\n<li>结果：<ul>\n<li>  若除数为8位，则al存放商，ah存放余数</li>\n<li>  若除数为16位，则ax存放商，dx存放余数</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; 计算 100001 / 100</span><br><span class=\"line\">; 100001 =&gt; 186a1H</span><br><span class=\"line\">mov dx,1H</span><br><span class=\"line\">mov ax,86a1H</span><br><span class=\"line\">mov word ptr ds:[bx+si+10],100</span><br><span class=\"line\">div word ptr ds:[bx+si+10]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DD-伪指令\"><a href=\"#DD-伪指令\" class=\"headerlink\" title=\"DD 伪指令\"></a>DD 伪指令</h3><p>用来定义DWORD（double word）双字型数据</p>\n<h3 id=\"DUP-伪指令\"><a href=\"#DUP-伪指令\" class=\"headerlink\" title=\"DUP 伪指令\"></a>DUP 伪指令</h3><p>与db、dw、dd等数据定义伪指令配合使用，进行重复数据的定义</p>\n<ul>\n<li>  db 重复次数 dup (被重复的字节型数据)</li>\n<li>  dw 重复次数 dup (被重复的字型数据)</li>\n<li>  dd 重复次数 dup (被重复的双字型数据)</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db 3 dup (&#x27;12&#x27;)    ;   db &#x27;121212&#x27;</span><br><span class=\"line\">db 5 dup (10H)     ;   db 10h,10h,10h,10h,10h</span><br><span class=\"line\">dw 2 dup (5f5fH)   ;   dw 5f5fH,5f5fH</span><br><span class=\"line\">dd 2 dup(12H)      ;   dd 00000012H,00000012H</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JMP指令原理\"><a href=\"#JMP指令原理\" class=\"headerlink\" title=\"JMP指令原理\"></a>JMP指令原理</h2><h3 id=\"OFFSET-伪指令\"><a href=\"#OFFSET-伪指令\" class=\"headerlink\" title=\"OFFSET 伪指令\"></a>OFFSET 伪指令</h3><p>取得标号的偏移地址，<strong>不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">start:\t</span><br><span class=\"line\">\t\tmov ax,offset start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JMP指令的用法\"><a href=\"#JMP指令的用法\" class=\"headerlink\" title=\"JMP指令的用法\"></a>JMP指令的用法</h3><ol>\n<li><p>数值指明目的地址</p>\n<ul>\n<li><p>同时修改cs : ip</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 1000:0000</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>段内短转移（机器码中不出现目的地址，只出现相对位移，**<u>==该相对位移在编译时确定==</u>**）</p>\n<p>  转移位移为8位，-128,127</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">s:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp short s          ; 使用相对距离差修改ip的值，ip = ip + (标号地址 - jmp后下一条指令初地址) </span><br><span class=\"line\">\tmov bx,11H</span><br></pre></td></tr></table></figure></li>\n<li><p>段内近转移</p>\n<p>  转移位移为16位，-32768,32767（机器码中不出现目的地址，……同短转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code segment</span><br><span class=\"line\">s:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp near ptr s</span><br><span class=\"line\">\tmov bx,11H</span><br></pre></td></tr></table></figure></li>\n<li><p>段间转移（远转移）</p>\n<p>  同时修改CS:IP，cs = 标号所在段的段地址，ip = 标号在所在段的偏移地址</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acode segment</span><br><span class=\"line\">sa:</span><br><span class=\"line\">\tmov ax,10H</span><br><span class=\"line\">\tjmp far ptr sb</span><br><span class=\"line\">acode ends</span><br><span class=\"line\"></span><br><span class=\"line\">bcode segment</span><br><span class=\"line\">sb:</span><br><span class=\"line\">\tmov bx,11H</span><br><span class=\"line\">bcode ends</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>转移地址在寄存器中</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,10F1H</span><br><span class=\"line\">jmp ax</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>转移地址在内存中</p>\n<ul>\n<li><p>内存单元中存有一个字型数据，即为目的地址的偏移地址（段内转移但非近转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1000H</span><br><span class=\"line\">mov ds:[1],ax</span><br><span class=\"line\">jmp word ptr ds:[1]</span><br></pre></td></tr></table></figure></li>\n<li><p>内存单元中存有一个双字型数据，高位为目的地址的段地址，低位为偏移地址（段间转移）</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1000H</span><br><span class=\"line\">mov ds:[0],ax</span><br><span class=\"line\">mov word ptr ds:[2],0H</span><br><span class=\"line\">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"有条件转移指令\"><a href=\"#有条件转移指令\" class=\"headerlink\" title=\"有条件转移指令\"></a>有条件转移指令</h3><p>所有的条件转移指令都是短转移，在对应机器码中不出现目的地址，只出现相对位移，在编译时确定</p>\n<ul>\n<li><p>jcxz 指令</p>\n<p>  功能上等同于在段内短转移之前判断CX是否等于0，若cx == 0，则跳转，若cx != 0，则不跳转</p>\n</li>\n<li><p>loop 指令</p>\n<p>  本质上也是条件转移指令，条件与jcxz相反，且伴随着cx的递减</p>\n</li>\n<li><p>检测比较结果的条件转移指令（根据**<u>==无符号数==</u>**的比较结果进行转移）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">相关标志位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">JE</td>\n<td align=\"center\">等于则转移</td>\n<td align=\"center\">ZF = 1</td>\n</tr>\n<tr>\n<td align=\"center\">JNE</td>\n<td align=\"center\">不等于则转移</td>\n<td align=\"center\">ZF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JB</td>\n<td align=\"center\">低于则转移</td>\n<td align=\"center\">CF = 1</td>\n</tr>\n<tr>\n<td align=\"center\">JNB</td>\n<td align=\"center\">不低于则转移</td>\n<td align=\"center\">CF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JA</td>\n<td align=\"center\">高于则转移</td>\n<td align=\"center\">CF = 0  &amp;&amp;  ZF = 0</td>\n</tr>\n<tr>\n<td align=\"center\">JNA</td>\n<td align=\"center\">不高于则转移</td>\n<td align=\"center\">CF = 1  ||  ZF = 1</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcxz 标号</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"栈操作\"><a href=\"#栈操作\" class=\"headerlink\" title=\"栈操作\"></a>栈操作</h2><h3 id=\"RET-amp-RETF-指令\"><a href=\"#RET-amp-RETF-指令\" class=\"headerlink\" title=\"RET &amp; RETF 指令\"></a>RET &amp; RETF 指令</h3><p>ret：用栈中的数据修改ip的内容，实现近转移</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret </span><br><span class=\"line\">====&gt;   </span><br><span class=\"line\">pop ip</span><br></pre></td></tr></table></figure>\n\n<p>retf：用栈中的数据修改 cs : ip，实现远转移</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retf </span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">pop ip</span><br><span class=\"line\">pop cs</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">mov bx,sp</span><br><span class=\"line\">jmp dword ptr ss:[bx]</span><br><span class=\"line\">add sp,4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CALL-指令\"><a href=\"#CALL-指令\" class=\"headerlink\" title=\"CALL 指令\"></a>CALL 指令</h3><p>call：将当前 ip 或 cs : ip 压入栈中，再转移</p>\n<ul>\n<li><p>进行近转移的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call fun     ; fun 为本段内某标号</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp near ptr fun</span><br></pre></td></tr></table></figure></li>\n<li><p>进行远转移的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call far ptr fun     ; fun 为非本段内某标号</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push cs</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp far ptr fun</span><br></pre></td></tr></table></figure></li>\n<li><p>目的地址在寄存器的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call ax      </span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp ax</span><br></pre></td></tr></table></figure></li>\n<li><p>目的地址在内存中的call指令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call word ptr ds:[bx]              ; 段内转移</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp word ptr ds:[bx]</span><br><span class=\"line\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class=\"line\">call dword ptr ds:[bx]             ; 段间转移（远转移）</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">push cs</span><br><span class=\"line\">push ip</span><br><span class=\"line\">jmp dword ptr ds:[bx]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"BP寄存器\"><a href=\"#BP寄存器\" class=\"headerlink\" title=\"BP寄存器\"></a>BP寄存器</h3><ul>\n<li>  当没有显式指出段地址且偏移量寄存器使用bp时，则段地址默认为SS寄存器中的值，无法分割bp为基址寄存器</li>\n<li>  和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到</li>\n<li>  一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;在函数进入时:</span><br><span class=\"line\">push bp     ;\t保存bp指针</span><br><span class=\"line\">mov bp,sp \t;\t将sp指针传给bp，此时bp指向sp的基地址。</span><br><span class=\"line\"></span><br><span class=\"line\">;;;;   函数体   ;;;;</span><br><span class=\"line\"></span><br><span class=\"line\">mov sp,bp   ;\tsp回到栈顶</span><br><span class=\"line\">pop bp      ;\tbp恢复初始值</span><br><span class=\"line\">ret         ; \t函数返回</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数压栈\"><a href=\"#参数压栈\" class=\"headerlink\" title=\"参数压栈\"></a>参数压栈</h3><p>​    调用某些带有参数的函数时，先按参数顺序将参数压栈(参数位于栈高位)，然后再执行<strong>CALL</strong>命令将CS:IP压栈(CS:IP位于栈低位)</p>\n<h3 id=\"LEA-指令\"><a href=\"#LEA-指令\" class=\"headerlink\" title=\"LEA 指令\"></a>LEA 指令</h3><p>​    LEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">makeArray PROC</span><br><span class=\"line\">    push ebp</span><br><span class=\"line\">    mov ebp,esp</span><br><span class=\"line\">    sub esp, 32            ;myString 位于 EBP-30 的位置</span><br><span class=\"line\">    lea esi, [ebp-30]      ;加载 myString 的地址</span><br><span class=\"line\">    mov ecx, 30            ;循环计数器</span><br><span class=\"line\">LI: mov BYTE PTR [esi]     ;填充一个位置</span><br><span class=\"line\">    inc esi                ;指向下一个元素</span><br><span class=\"line\">    loop LI                ;循环，直到 ECX=0</span><br><span class=\"line\">    add esp, 32            ;删除数组(恢复ESP)</span><br><span class=\"line\">    pop ebp</span><br><span class=\"line\">    ret</span><br><span class=\"line\">makeArray ENDP</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"MUL-指令\"><a href=\"#MUL-指令\" class=\"headerlink\" title=\"MUL 指令\"></a>MUL 指令</h3><ul>\n<li>  两数相乘，要么都是8位，要么都是16位</li>\n<li>  若是8位，一个默认在AL，另一个在8位寄存器或内存，结果在AX</li>\n<li>  若是16位，一个默认在AX，另一个在16位寄存器或内存，高位在DX，低位在AX</li>\n</ul>\n<h3 id=\"寄存器冲突问题\"><a href=\"#寄存器冲突问题\" class=\"headerlink\" title=\"寄存器冲突问题\"></a>寄存器冲突问题</h3><p>若计数器寄存器 CX 另有用途，无法存放循环次数，那么可以用 jmp 与 jcxz 指令配合代替loop指令，实现有限循环</p>\n<hr>\n<h2 id=\"标志寄存器\"><a href=\"#标志寄存器\" class=\"headerlink\" title=\"标志寄存器\"></a>标志寄存器</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>  用来存储相关指令的某些执行结果</li>\n<li>  用来为CPU执行相关指令提供行为依据</li>\n<li>  用来控制CPU的相关工作方式</li>\n</ul>\n<blockquote>\n<p>  8086CPU的标志寄存器时16位寄存器，其信息是按起作用，每一个位存储的信息通常被称为程序状态字(PSW)</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">15</th>\n<th align=\"center\">14</th>\n<th align=\"center\">13</th>\n<th align=\"center\">12</th>\n<th align=\"center\">11</th>\n<th align=\"center\">10</th>\n<th align=\"center\">9</th>\n<th align=\"center\">8</th>\n<th align=\"center\">7</th>\n<th align=\"center\">6</th>\n<th align=\"center\">5</th>\n<th align=\"center\">4</th>\n<th align=\"center\">3</th>\n<th align=\"center\">2</th>\n<th align=\"center\">1</th>\n<th align=\"center\">0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">OF</td>\n<td align=\"center\">DF</td>\n<td align=\"center\">IF</td>\n<td align=\"center\">TF</td>\n<td align=\"center\">SF</td>\n<td align=\"center\">ZF</td>\n<td align=\"center\"></td>\n<td align=\"center\">AF</td>\n<td align=\"center\"></td>\n<td align=\"center\">PF</td>\n<td align=\"center\"></td>\n<td align=\"center\">CF</td>\n</tr>\n</tbody></table>\n<h3 id=\"ZF-标志\"><a href=\"#ZF-标志\" class=\"headerlink\" title=\"ZF 标志\"></a>ZF 标志</h3><ul>\n<li>  位于第  <strong>==6==</strong> 位</li>\n<li>  零标志位，记录相关指令执行后，其结果是否为0，若为 ==0== 则ZF = 1，否则ZF = 0；</li>\n<li>  在8086CPU指令集中，add、sub、mul、div、inc、or、and 等运算指令一般影响ZF</li>\n</ul>\n<h3 id=\"PF-标志\"><a href=\"#PF-标志\" class=\"headerlink\" title=\"PF 标志\"></a>PF 标志</h3><ul>\n<li>  位于第 <strong>==2==</strong> 位</li>\n<li>  奇偶标志位，记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，若 ==偶== 则 ==1==，若 ==奇== 则 ==0==</li>\n</ul>\n<h3 id=\"SF-标志\"><a href=\"#SF-标志\" class=\"headerlink\" title=\"SF 标志\"></a>SF 标志</h3><ul>\n<li>  位于第 <strong>==7==</strong> 位</li>\n<li>  符号标志位，记录相关指令执行后，其结果是否为负，若 ==负== 则 ==1==，若 ==非负== 则 ==0==</li>\n</ul>\n<h3 id=\"CF-标志\"><a href=\"#CF-标志\" class=\"headerlink\" title=\"CF 标志\"></a>CF 标志</h3><ul>\n<li>  位于第 <strong>==0==</strong> 位</li>\n<li>  进位标志位，一般情况下，在进行 <u>无符号数</u> 运算的时候，记录了运算结果的最高有效位向更高位的进位值，或借位值</li>\n</ul>\n<h3 id=\"OF-标志\"><a href=\"#OF-标志\" class=\"headerlink\" title=\"OF 标志\"></a>OF 标志</h3><ul>\n<li>  位于第 <strong>==11==</strong> 位</li>\n<li>  CPU在进行 <u>有符号数</u> 运算时，若溢出则为 1 ，若未溢出，则为 0 </li>\n</ul>\n<h3 id=\"ADC-指令\"><a href=\"#ADC-指令\" class=\"headerlink\" title=\"ADC 指令\"></a>ADC 指令</h3><p>adc指令是带进位的加法指令，利用了CF标志位</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adc ax,bx    ;  ax = ax + bx + CF</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SBB-指令\"><a href=\"#SBB-指令\" class=\"headerlink\" title=\"SBB 指令\"></a>SBB 指令</h3><p>sbb指令是带借位减法指令，同样利用了CF标志位</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbb ax,bx    ; ax = ax - bx - CF</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CMP-指令\"><a href=\"#CMP-指令\" class=\"headerlink\" title=\"CMP 指令\"></a>CMP 指令</h3><p>cmp是比较指令，功能上相当于减法指令，但不保存结果，只影响相关标志位的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,3</span><br><span class=\"line\">mov bx,4</span><br><span class=\"line\">cmp ax,bx</span><br><span class=\"line\">; 相当于执行减法，执行后 ZF = 0，PF = 1，SF = 1,CF = 1,OF = 0</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>  ZF = 1  ==&gt;  ax == bx</li>\n<li>  ZF = 0  ==&gt;  ax != bx</li>\n<li>  CF = 1  ==&gt;  ax &lt; bx</li>\n<li>  CF = 0  ==&gt;  ax &gt;= bx</li>\n</ul>\n<h3 id=\"TEST-指令\"><a href=\"#TEST-指令\" class=\"headerlink\" title=\"TEST 指令\"></a>TEST 指令</h3><p>test 对两个操作数进行逻辑（按位）与操作，功能上与and指令类似，但不保存结果，只影响相关标志位的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; 检查ax的最高位是否为 1</span><br><span class=\"line\">test ax,10000000b</span><br><span class=\"line\">je isNotOne      ; 最高位是 0</span><br><span class=\"line\">jne isOne\t\t ; 最高位是 1</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"与标志位相关的条件转移指令\"><a href=\"#与标志位相关的条件转移指令\" class=\"headerlink\" title=\"与标志位相关的条件转移指令\"></a>与标志位相关的条件转移指令</h3><p><a href=\"#%E6%9C%89%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4\">详细见此处</a></p>\n<h3 id=\"DF-标志-amp-串传送指令\"><a href=\"#DF-标志-amp-串传送指令\" class=\"headerlink\" title=\"DF 标志 &amp; 串传送指令\"></a>DF 标志 &amp; 串传送指令</h3><ul>\n<li>  DF 标志位于第 ==10== 位</li>\n<li>  方向标志位，在串处理指令中，控制每次操作后 SI 与 DI 的增减</li>\n<li>  若 DF = 0，则每次操作后 SI &amp; DI 递增</li>\n<li>  若 DF = 1，则每次操作后 SI &amp; DI 递减</li>\n</ul>\n<h4 id=\"MOVSB-指令\"><a href=\"#MOVSB-指令\" class=\"headerlink\" title=\"MOVSB 指令\"></a>MOVSB 指令</h4><p>movsb 指令功能是将ds:si指向的内存单元中的一个字节型数据送入es:di；相当于:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; if DF = 1</span><br><span class=\"line\">mov es:[di],byte ptr ds:[si]</span><br><span class=\"line\">dec si</span><br><span class=\"line\">dec di</span><br><span class=\"line\"></span><br><span class=\"line\">; if DF = 0</span><br><span class=\"line\">mov es:[di],byte ptr ds:[si]</span><br><span class=\"line\">inc si</span><br><span class=\"line\">inc di</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MOVSW-指令\"><a href=\"#MOVSW-指令\" class=\"headerlink\" title=\"MOVSW 指令\"></a>MOVSW 指令</h4><p>movsw 指令与 movsb 指令类似，只是把字节型数据改为字型数据，si 与 di 每次变化两个单位</p>\n<h4 id=\"与-REP-的配合\"><a href=\"#与-REP-的配合\" class=\"headerlink\" title=\"与 REP 的配合\"></a>与 REP 的配合</h4><p>上述两种指令都需要与 rep 相配和，实现数据从 DS段 <strong>连续</strong>传送到 ES段 中，本质是由loop循环的实现，循环次数由 CX 的值决定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rep movsb</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">s: </span><br><span class=\"line\">\tmovsb</span><br><span class=\"line\">\tloop s</span><br><span class=\"line\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class=\"line\">rep movsw</span><br><span class=\"line\">====&gt;</span><br><span class=\"line\">s: </span><br><span class=\"line\">\tmovsw</span><br><span class=\"line\">\tloop s</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CLD-amp-STD-指令\"><a href=\"#CLD-amp-STD-指令\" class=\"headerlink\" title=\"CLD &amp; STD 指令\"></a>CLD &amp; STD 指令</h4><ul>\n<li>  sld 指令：将DF置 0，实现 si 与 di 的自增</li>\n<li>  std 指令：将DF置 1，实现 si 与 di 的自减</li>\n</ul>\n<h3 id=\"PUSHF-amp-POPF-指令\"><a href=\"#PUSHF-amp-POPF-指令\" class=\"headerlink\" title=\"PUSHF &amp; POPF 指令\"></a>PUSHF &amp; POPF 指令</h3><p>pushf的功能是将标志寄存器中的值压栈，而popf是将栈中的数据弹出并送入标志寄存器中</p>\n<h3 id=\"标志寄存器在Debug中的表示\"><a href=\"#标志寄存器在Debug中的表示\" class=\"headerlink\" title=\"标志寄存器在Debug中的表示\"></a>标志寄存器在Debug中的表示</h3><table>\n<thead>\n<tr>\n<th align=\"center\">标志</th>\n<th align=\"center\">置一</th>\n<th align=\"center\">置零</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">OF</td>\n<td align=\"center\">OV</td>\n<td align=\"center\">NV</td>\n</tr>\n<tr>\n<td align=\"center\">SF</td>\n<td align=\"center\">NG</td>\n<td align=\"center\">PL</td>\n</tr>\n<tr>\n<td align=\"center\">ZF</td>\n<td align=\"center\">ZR</td>\n<td align=\"center\">NZ</td>\n</tr>\n<tr>\n<td align=\"center\">PF</td>\n<td align=\"center\">PE</td>\n<td align=\"center\">PO</td>\n</tr>\n<tr>\n<td align=\"center\">CF</td>\n<td align=\"center\">CY</td>\n<td align=\"center\">NC</td>\n</tr>\n<tr>\n<td align=\"center\">DF</td>\n<td align=\"center\">DN</td>\n<td align=\"center\">UP</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"内中断\"><a href=\"#内中断\" class=\"headerlink\" title=\"内中断\"></a>内中断</h2><h1 id=\"32位逆向\"><a href=\"#32位逆向\" class=\"headerlink\" title=\"32位逆向\"></a>32位逆向</h1><h2 id=\"小端序-amp-大端序\"><a href=\"#小端序-amp-大端序\" class=\"headerlink\" title=\"小端序&amp;大端序\"></a>小端序&amp;大端序</h2><p>地址高位存数据高位 ===》 小端序</p>\n<p>地址高位存地址低位 ===》 大端序</p>\n<h2 id=\"IA-32寄存器\"><a href=\"#IA-32寄存器\" class=\"headerlink\" title=\"IA-32寄存器\"></a>IA-32寄存器</h2><h3 id=\"基本程序运行寄存器\"><a href=\"#基本程序运行寄存器\" class=\"headerlink\" title=\"基本程序运行寄存器\"></a>基本程序运行寄存器</h3><ul>\n<li>  通用寄存器{EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP}</li>\n<li>  段寄存器{CS，DS，SS，ES，FS，GS}</li>\n<li>  程序状态与控制寄存器{EFLAGS}</li>\n<li>  指令指针寄存器{EIP}</li>\n</ul>\n<blockquote>\n<p>Tips:</p>\n<ol>\n<li>  EAX一般用于函数返回值中，所有Win32 API函数都会先把返回值保存在EAX中再返回</li>\n<li>  ES，FS，GS：附加数据段</li>\n</ol>\n</blockquote>\n<h2 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h2><ul>\n<li>  cdecl：调用者负责清理栈中的参数</li>\n<li>  stdcall：被调用者负责清理栈中的参数</li>\n</ul>\n<h2 id=\"PE文件格式\"><a href=\"#PE文件格式\" class=\"headerlink\" title=\"PE文件格式\"></a>PE文件格式</h2><img src=\"https://img-blog.csdnimg.cn/20201210163828181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5nX2Nt,size_16,color_FFFFFF,t_70\" alt=\"img\" style=\"zoom:100%;\">\n\n<h3 id=\"DOS-头\"><a href=\"#DOS-头\" class=\"headerlink\" title=\"DOS 头\"></a>DOS 头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注释掉的不需要重点分析</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class=\"line\">    <span class=\"number\">0X00</span> WORD e_magic;      <span class=\"comment\">//※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件</span></span><br><span class=\"line\">    <span class=\"comment\">//0X02 WORD e_cblp;     //Bytes on last page of file</span></span><br><span class=\"line\">    <span class=\"comment\">//0X04 WORD e_cp;       //Pages in file</span></span><br><span class=\"line\">    <span class=\"comment\">//0X06 WORD e_crlc;     //Relocations</span></span><br><span class=\"line\">    <span class=\"comment\">//0X08 WORD e_cparhdr;  //Size of header in paragraphs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0A WORD e_minalloc; //Minimun extra paragraphs needs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0C WORD e_maxalloc; //Maximun extra paragraphs needs</span></span><br><span class=\"line\">    <span class=\"comment\">//0X0E WORD e_ss;       //intial(relative)SS value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X10 WORD e_sp;       //intial SP value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X12 WORD e_csum;     //Checksum</span></span><br><span class=\"line\">    <span class=\"comment\">//0X14 WORD e_ip;       //intial IP value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X16 WORD e_cs;       //intial(relative)CS value</span></span><br><span class=\"line\">    <span class=\"comment\">//0X18 WORD e_lfarlc;   //File Address of relocation table</span></span><br><span class=\"line\">    <span class=\"comment\">//0X1A WORD e_ovno;     //Overlay number</span></span><br><span class=\"line\">    <span class=\"comment\">//0x1C WORD e_res[4];   //Reserved words</span></span><br><span class=\"line\">    <span class=\"comment\">//0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)</span></span><br><span class=\"line\">    <span class=\"comment\">//0x26 WORD e_oeminfo;  //OEM information;e_oemid specific</span></span><br><span class=\"line\">    <span class=\"comment\">//0x28 WORD e_res2[10]; //Reserved words</span></span><br><span class=\"line\">    <span class=\"number\">0x3C</span> DWORD e_lfanew;    <span class=\"comment\">//※Offset to start of PE header:定位PE文件，NT头相对于文件的偏移量</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>e_magic : 固定为 ‘MZ’</p>\n<p>e_lfanew：NT头的文件偏移位置</p>\n<h3 id=\"DOS-stub\"><a href=\"#DOS-stub\" class=\"headerlink\" title=\"DOS stub\"></a>DOS stub</h3><p>​    由代码与数据混合而成，大小不固定，可没有，可存储在16位汇编指令，在dos环境下运行</p>\n<h3 id=\"NT-头\"><a href=\"#NT-头\" class=\"headerlink\" title=\"NT 头\"></a>NT 头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x86</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class=\"line\">    DWORD Signature;</span><br><span class=\"line\">    IMAGE_FILE_HEADER FileHeader;                       <span class=\"comment\">// 文件头</span></span><br><span class=\"line\">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;      \t   <span class=\"comment\">// 可选头</span></span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//x64</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class=\"line\">    DWORD Signature;</span><br><span class=\"line\">    IMAGE_FILE_HEADER FileHeader;</span><br><span class=\"line\">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class=\"line\">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>\n\n<p>Signature: 签名，50450000H ===&gt;  “PE00”</p>\n<h3 id=\"NT-：文件头\"><a href=\"#NT-：文件头\" class=\"headerlink\" title=\"NT ：文件头\"></a>NT ：文件头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x86 x64相同</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class=\"line\">    WORD    Machine;                           <span class=\"comment\">// 运行平台  </span></span><br><span class=\"line\">    WORD    NumberOfSections;\t\t\t\t<span class=\"comment\">// 节的数量</span></span><br><span class=\"line\">    DWORD   TimeDateStamp;\t\t\t\t\t<span class=\"comment\">// 时间戳</span></span><br><span class=\"line\">    DWORD   PointerToSymbolTable;\t\t\t<span class=\"comment\">// 符号表指针</span></span><br><span class=\"line\">    DWORD   NumberOfSymbols;\t\t\t\t<span class=\"comment\">// 符号数量</span></span><br><span class=\"line\">    WORD    SizeOfOptionalHeader;\t\t\t<span class=\"comment\">// 可选头大小</span></span><br><span class=\"line\">    WORD    Characteristics;                 <span class=\"comment\">// 文件属性</span></span><br><span class=\"line\">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Machine：</p>\n<ul>\n<li>  0x014cH    x86</li>\n<li>  0x0200H    Intel 64</li>\n<li>  0x8664H    x64</li>\n</ul>\n</li>\n<li><p>Characteristics:</p>\n<ul>\n<li>  0x0002H    可执行文件</li>\n<li>  0x2000H    动态链接库</li>\n<li>  0x1000H    系统文件</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h1><img src=\"https://img-blog.csdn.net/20170611205306090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFpZGUyMDEy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"C_complie\" style=\"zoom:125%;\">\n\n<h2 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a>预处理</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>cpp.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure></li>\n<li><p>作用</p>\n<ol>\n<li>宏替换</li>\n<li>包含头文件</li>\n<li>条件编译</li>\n<li>处理预处理关键字</li>\n</ol>\n</li>\n<li><p>结果</p>\n<p>  ​    扩展的c源码，生成扩展名为 ‘.i ’ 的ASCII文件</p>\n<hr>\n</li>\n</ul>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>cc1.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -S main.i</span><br></pre></td></tr></table></figure></li>\n<li><p>结果</p>\n<p>  ​    将c源码翻译为汇编源码，生成扩展名为 ‘ .s ’的ASCII文件</p>\n<p>  ​    </p>\n<hr>\n</li>\n</ul>\n<h2 id=\"汇编\"><a href=\"#汇编\" class=\"headerlink\" title=\"汇编\"></a>汇编</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>as.exe</strong></p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -c main.s</span><br></pre></td></tr></table></figure></li>\n<li><p>结果</p>\n<p>  ​    将汇编源码翻译为二进制代码，生成扩展名为 ‘ .o’ 的二进制文件 </p>\n</li>\n<li><p>注意</p>\n<p>  ​    无法直接运行，需要链接（<em>单个文件也需要链接</em>）</p>\n<hr>\n</li>\n</ul>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><p>使用程序</p>\n<p>  ​    <strong>collect2.exe</strong> / <strong>ld.exe</strong>  （静态链接器）</p>\n  <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc main.o -o main</span><br></pre></td></tr></table></figure></li>\n<li><p>作用</p>\n<ol>\n<li>将众多.o文件合成为一个完整的可执行文件</li>\n<li>链接时，需要加入由编译器提供的启动代码，来调用main函数</li>\n<li>链接时，需要进行符号解析与地址重定位</li>\n</ol>\n</li>\n<li><p>结果</p>\n<p>  ​    在Windows环境下生成‘.exe’ 文件，在linux环境下没有固定扩展名</p>\n</li>\n</ul>\n<h3 id=\"静态链接\"><a href=\"#静态链接\" class=\"headerlink\" title=\"静态链接\"></a>静态链接</h3><ul>\n<li><p>定义</p>\n<p>  ​    在编译时完成的链接，调用 <strong>ld</strong> / <strong>collect2</strong> 链接程序，将所有.o文件整合</p>\n</li>\n<li><p>缺点</p>\n<p>  ​    重复代码较多，浪费计算机资源</p>\n</li>\n<li><p>具体过程</p>\n<ol>\n<li><p>符号解析</p>\n<ul>\n<li><p>作用</p>\n<p> ​    符号解析的目的是将符号的引用与符号的定义练习起来（如：函数的声明与实现）</p>\n</li>\n<li><p>实现</p>\n<p> ​    在每一个.o文件中都会包含一张符号表(.symtab)，用来记录：        </p>\n<p> ​        </p>\n <figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 本模块定义了哪些符号</span><br><span class=\"line\">（2） 本模块引用了哪些符号</span><br></pre></td></tr></table></figure>\n\n<p> ​        </p>\n</li>\n<li><p>注意</p>\n<p> ​    单个.c文件即为一个模块，整个工程以模块为单位进行组织</p>\n<p> ​    </p>\n</li>\n</ul>\n</li>\n<li><p>地址重定位</p>\n<ul>\n<li><p>作用  </p>\n<p> ​    将.o文件中的每个机器指令的逻辑地址，重定位为实际运行的地址</p>\n <figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果是裸机运行的，运行的地址就是内存的物理地址</span><br><span class=\"line\">2. 如果是基于OS运行的，运行地址就是虚拟内存的地址</span><br></pre></td></tr></table></figure></li>\n<li><p>逻辑地址</p>\n<p> ​    在每个节中，从零开始标号</p>\n</li>\n<li><p>虚拟地址</p>\n<ol>\n<li>在32位Linux操作系统下，虚拟地址为32位，从<u>0x08048000</u>开始<pre><code> 2. 在64位Linux操作系统下，虚拟地址为64位，从0x00000000000400000开始\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><ul>\n<li><p>定义</p>\n<p>  ​    在编译时只留下调用接口，当程序真正运行起来的时候，才去链接执行</p>\n</li>\n<li><p>使用时机</p>\n<p>  ​    使用动态链接库（DLL）时</p>\n<p>  ​    如printf函数由动态链接库提供，程序编译后，代码中不存在printf函数代码，只有其接口，当程序运行时，再去动态链接其所在的DLL，这里的接口是二进制代码，实质为该函数第一条指令的地址(相对地址 + 绝对地址)</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">相对地址: 某成员在DLL中的相对位置； 绝对地址: DLL被加载到内存中后的物理地址</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>动态链接器。。。</p>\n</li>\n<li><p>链接过程与优点</p>\n<p>  ​    程序运行时，将**<u>整个</u>**DLL加载到内存之中，内存中所有相关进程共享该DLL的代码，减少了代码的冗余，提高了计算机空间资源的利用率</p>\n<blockquote>\n<p>因为DLL并不知道用户的程序需要该库中哪个变量或函数，所以需要将其完整加载到内存中</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"目标文件\"><a href=\"#目标文件\" class=\"headerlink\" title=\"目标文件\"></a>目标文件</h1><h2 id=\"目标文件类型\"><a href=\"#目标文件类型\" class=\"headerlink\" title=\"目标文件类型\"></a>目标文件类型</h2><h3 id=\"可重定位目标文件\"><a href=\"#可重定位目标文件\" class=\"headerlink\" title=\"可重定位目标文件\"></a>可重定位目标文件</h3><ul>\n<li>定义</li>\n</ul>\n<p>​    被用于静态链接的文件，都是看重定位目标文件</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是可重定位？</span><br><span class=\"line\">\t因为采用静态链接，逻辑地址需要被重定位为运行地址后才能被运行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>类型</p>\n<p>  ​    以‘‘**.a 、.lib**’’ 为扩展名的静态库文件以及以‘‘ <strong>.o</strong> ’’为扩展名的二进制文件都是<u>可重定位目标文件</u></p>\n</li>\n</ul>\n<h3 id=\"可执行目标文件\"><a href=\"#可执行目标文件\" class=\"headerlink\" title=\"可执行目标文件\"></a>可执行目标文件</h3><p>​        就是可执行的文件</p>\n<h3 id=\"共享目标文件\"><a href=\"#共享目标文件\" class=\"headerlink\" title=\"共享目标文件\"></a>共享目标文件</h3><p>​        本质就是动态库文件DLL，DLL也被称为共享库</p>\n<hr>\n<h2 id=\"目标文件格式\"><a href=\"#目标文件格式\" class=\"headerlink\" title=\"目标文件格式\"></a>目标文件格式</h2><pre><code>### 裸机（无OS）\n</code></pre>\n<p>​    “ .bin ” 文件格式，直接运行在<strong>arm</strong>裸机上</p>\n<h3 id=\"UNIX系统\"><a href=\"#UNIX系统\" class=\"headerlink\" title=\"UNIX系统\"></a>UNIX系统</h3><ol>\n<li><p>早期unix操作系统</p>\n<p> ​    使用“ <strong>.out</strong>  ” 文件格式，在UNIX操作系统上编译程序后，若不指定可执行文件名，会默认命名为 “ a.out ”</p>\n</li>\n<li><p>system V unix</p>\n<p> ​    a.out 文件格式变为 <strong>COFF</strong> ( Common Object File Format : 一般目标文件格式) </p>\n</li>\n<li><p>线代Unix</p>\n<p> ​    改用 <strong>ELF</strong>（Executable and Linkable Format：可执行、可链接格式）</p>\n</li>\n</ol>\n<h3 id=\"Windows系统\"><a href=\"#Windows系统\" class=\"headerlink\" title=\"Windows系统\"></a>Windows系统</h3><p>​    采用 <strong>PE</strong> （Portable Executable：可移植、可执行格式）</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里的可移植并非指PE格式文件可跨平台执行，而是指兼容多种语言</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Linux系统\"><a href=\"#Linux系统\" class=\"headerlink\" title=\"Linux系统\"></a>Linux系统</h3><p>​    与现代Unix相同，与使用<strong>ELF</strong>格式，linux操作系统脱胎于unix，因此在linux操作系统编译得到的可执行文件上也默认命名为“ a.out ”，但是文件格式与早期Unix并不一致</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如何理解ELF（可执行、可链接）的含义？</span><br><span class=\"line\">1. 可重定位目标文件、共享目标文件：可以被链接</span><br><span class=\"line\">2. 可执行目标文件：能被执行</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ELF格式可重定位目标文件\"><a href=\"#ELF格式可重定位目标文件\" class=\"headerlink\" title=\"ELF格式可重定位目标文件\"></a>ELF格式可重定位目标文件</h3><h4 id=\"组成结构图\"><a href=\"#组成结构图\" class=\"headerlink\" title=\"组成结构图\"></a>组成结构图</h4><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo10%2Fcd31ce13972e4a6a82284b1b07faabae.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647693494&t=81dd5f93e3a64f75b1a77e522cad6df5\" alt=\"点击查看图片来源\" style=\"zoom: 67%;\">\n\n<h4 id=\"ELF-Header\"><a href=\"#ELF-Header\" class=\"headerlink\" title=\"ELF Header\"></a>ELF Header</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用 readelf -h 查看elf头信息</span><br><span class=\"line\">readelf -h file</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"file:///C:\\Users\\lenovo\\AppData\\Roaming\\Tencent\\Users\\956489228\\QQ\\WinTemp\\RichOle\\YQZ8(L~D)SSOQ65HK]0YTDS.png\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ident[<span class=\"number\">16</span>];        <span class=\"comment\">/* ELF &quot;magic number&quot; */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_type[<span class=\"number\">2</span>];      <span class=\"comment\">/* Identifies object file type */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_machine[<span class=\"number\">2</span>];       <span class=\"comment\">/* Specifies required architecture */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_version[<span class=\"number\">4</span>];       <span class=\"comment\">/* Identifies object file version */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_entry[<span class=\"number\">4</span>];     <span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phoff[<span class=\"number\">4</span>];     <span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shoff[<span class=\"number\">4</span>];     <span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_flags[<span class=\"number\">4</span>];     <span class=\"comment\">/* Processor-specific flags */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_ehsize[<span class=\"number\">2</span>];        <span class=\"comment\">/* ELF header size in bytes */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phentsize[<span class=\"number\">2</span>];     <span class=\"comment\">/* Program header table entry size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_phnum[<span class=\"number\">2</span>];     <span class=\"comment\">/* Program header table entry count */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shentsize[<span class=\"number\">2</span>];     <span class=\"comment\">/* Section header table entry size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shnum[<span class=\"number\">2</span>];     <span class=\"comment\">/* Section header table entry count */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> e_shstrndx[<span class=\"number\">2</span>];      <span class=\"comment\">/* Section header string table index */</span></span><br><span class=\"line\">&#125; Elf32_External_Ehdr;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"e-ident\"><a href=\"#e-ident\" class=\"headerlink\" title=\"e_ident\"></a><strong>e_ident</strong></h5><p>e_ident 是一个包含 16 字节的数组成员，对应 readelf -h 给出的 magic 部分.</p>\n<p>magic 部分就是我们所说的魔数，魔数通常就是自定义的识别码，对于 32 位的 elf 文件而言，magic 部分有 16 个字节.</p>\n<p>大部分的文件组织形式都是这样的，头部是一串特殊的识别码，标识该文件的一些概要信息，主要用于外部程序快速地对这个文件进行识别，快速地判断文件类型.</p>\n<p>但是 readelf 命令仅仅是显示了对应的二进制码，并没有进一步显示整个魔数字段的详细信息，关于这一部分就需要参考 readelf 源码来进行分析了，分析结果如下:</p>\n<ul>\n<li>  前四个字节:7f 45 4c 46，识别码， 0x45，0x4c，0x46 三个字节的 ascii 码对应 ELF 字母，通过这四个字节就可以判断文件是不是 elf 文件.</li>\n<li>  第五个字节:其中 01 表示 32 位 elf 文件，02 表示 64 位.</li>\n<li>  第六个字节:其中 01 表示 小端模式，02 表示 大端模式.</li>\n<li>  第七个字节:表示 EI_version，1 表示 EV_CURRENT，只有 1 才是合理的(代码中是 EI_versoin，但是博主没有进一步具体研究).</li>\n<li>  第八个字节: 00 表示 OS_ABI</li>\n<li>  第九个字节: 00 表示 ABI version</li>\n<li>  其它字段，源码中没有找到对应的解析，暂定为reserver.</li>\n</ul>\n<ul>\n<li>xx</li>\n</ul>\n<h5 id=\"e-type\"><a href=\"#e-type\" class=\"headerlink\" title=\"e_type\"></a>e_type</h5><p>type 表示 elf 文件的细分类型，总共有四种:</p>\n<ul>\n<li>  可重定位的目标文件</li>\n<li>  可执行文件</li>\n<li>  动态链接文件</li>\n<li>  coredump 文件，这是系统生成的调试文件.</li>\n</ul>\n<p>这四种类型的文件各有各的特点，比如可重定位的目标文件针对的是链接器.</p>\n<p>而可执行文件针对加载器，需要被静态加载到内存中执行，而动态链接文件则是运行过程中的加载.</p>\n<p>coredump 文件主要保存的是系统出错时的运行断点信息，方便人为地或者借助 gdb 分析 bug.</p>\n<h5 id=\"e-machine\"><a href=\"#e-machine\" class=\"headerlink\" title=\"e_machine\"></a>e_machine</h5><p>标识指定的机器，比如 40 代表 ARM.</p>\n<p>其它的比如 x86，mips 等都对应不同的编码.</p>\n<h5 id=\"e-version\"><a href=\"#e-version\" class=\"headerlink\" title=\"e_version\"></a>e_version</h5><p>四个字节的 version code</p>\n<h5 id=\"e-entry\"><a href=\"#e-entry\" class=\"headerlink\" title=\"e_entry\"></a>e_entry</h5><p>程序的入口虚拟地址，对于可重定位的目标文件默认是0，而对于可执行文件而言是真实的程序入口.</p>\n<p>程序入口是被加载器使用的，在程序加载过程中会读取该程序入口，作为应用程序的开始执行地址，在实际的加载过程中，内核加载完当前 elf 可执行文件之后其实并不是跳到该入口地址，而是先执行动态链接器代码，在动态链接完成之后才会跳到该入口地址。</p>\n<h5 id=\"e-phoff\"><a href=\"#e-phoff\" class=\"headerlink\" title=\"e_phoff\"></a>e_phoff</h5><p> program header table 的起始偏移地址，</p>\n<h5 id=\"e-shoff\"><a href=\"#e-shoff\" class=\"headerlink\" title=\"e_shoff\"></a>e_shoff</h5><p> section header table 的起始偏移地址，</p>\n<h5 id=\"e-flags\"><a href=\"#e-flags\" class=\"headerlink\" title=\"e_flags\"></a>e_flags</h5><p>和处理器相关的标志位集合，不同的处理器有不同的参数，根据 e_machine 进行解析.</p>\n<h5 id=\"e-ehsize\"><a href=\"#e-ehsize\" class=\"headerlink\" title=\"e_ehsize\"></a>e_ehsize</h5><p>指示 elf header 的 size，对于 arm 而言，52 或者 64.</p>\n<h5 id=\"e-phentsize\"><a href=\"#e-phentsize\" class=\"headerlink\" title=\"e_phentsize\"></a>e_phentsize</h5><p>每一个 program header 的 size，在可重定位目标文件中为 0.</p>\n<h5 id=\"e-phnum\"><a href=\"#e-phnum\" class=\"headerlink\" title=\"e_phnum\"></a>e_phnum</h5><p>该文件中一共有多少个 program header，在可重定位目标文件中为0.</p>\n<h5 id=\"e-shentsize\"><a href=\"#e-shentsize\" class=\"headerlink\" title=\"e_shentsize\"></a>e_shentsize</h5><p>文件中每一个section header 的大小，通常是 40.</p>\n<h5 id=\"e-shnum\"><a href=\"#e-shnum\" class=\"headerlink\" title=\"e_shnum\"></a>e_shnum</h5><p>该文件中一共有多少个 section header，上述的示例文件中为 10 个.</p>\n<h5 id=\"e-shstrndx\"><a href=\"#e-shstrndx\" class=\"headerlink\" title=\"e_shstrndx\"></a>e_shstrndx</h5><p>在 elf 格式的文件中，符号，section，文件的命名通常是字符串，这些字符串并不会保存在其对应的 section 中，而是统一地使用一个字符串表来保存，该字段指示节标题字符串所在的 section，在上面的示例中，section 标题(.text，.data，…)对应的 e_shstrndx 即段序号为 7，即保存在 .shstrtab 段中.这些 section 标题在链接的过程中需要使用到，在程序执行时是无用的，所以分开有利于精简 section 内容的大小，从而程序加载运行时需要更小的空间.</p>\n<p>除了 section 标题，还有符号名，文件名等字符串，这些默认会被保存在 .strtab section 中.</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">ELF</span>文件大小：</span><br><span class=\"line\"><span class=\"variable\">Size</span> <span class=\"operator\">=</span> <span class=\"type\">e_shoff</span> <span class=\"operator\">+</span> <span class=\"type\">e_shnum</span> <span class=\"operator\">*</span> <span class=\"type\">e_shentsize</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"text-Section\"><a href=\"#text-Section\" class=\"headerlink\" title=\".text Section\"></a>.text Section</h4><p>​    <u><strong>==只读==</strong></u> <strong>代码</strong>节，存放所有函数的机器指令即程序代码，有些常量也会与指令一起存放在此节中（如字面量）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    a = a + <span class=\"number\">100</span>;     <span class=\"comment\">// 此处的100会与指令一并存放在该节</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"rodata-Section\"><a href=\"#rodata-Section\" class=\"headerlink\" title=\".rodata Section\"></a>.rodata Section</h4><p>​    <strong><u>==只读==</u></strong> <strong>数据</strong>节，存放常量数据（如字符串常量）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *str = <span class=\"string\">&quot;HelloWorld!&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>,str);        <span class=\"comment\">// 这里的“%s” 与 “HelloWorld！”会存放在该节</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"data-Section\"><a href=\"#data-Section\" class=\"headerlink\" title=\".data Section\"></a>.data Section</h4><p>​    <u><strong>==可写==</strong></u> <strong>数据</strong>节，存放：</p>\n<ol>\n<li><p>已初始化的全局变量</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> global = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,global + <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>已初始化的静态局部变量</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getCount</span><span class=\"params\">(<span class=\"type\">char</span> *arr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;         <span class=\"comment\">// 该静态局部变量已被初始化</span></span><br><span class=\"line\">    count += <span class=\"built_in\">strlen</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"bss-Section\"><a href=\"#bss-Section\" class=\"headerlink\" title=\".bss Section\"></a>.bss Section</h4><p>​    <u><strong>==可写==</strong></u> <strong>数据</strong>节</p>\n<ol>\n<li><p>未初始化的全局变量</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> global;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,global + <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>未初始化的静态局部变量</p>\n  <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getCount</span><span class=\"params\">(<span class=\"type\">char</span> *arr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count;         <span class=\"comment\">// 该静态局部变量未被初始化</span></span><br><span class=\"line\">    count = <span class=\"built_in\">strlen</span>(arr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  由于.bss节存放没有初始化的数据，所以其并不占有真实地存储空间，.bss 节在可重定位目标文件中只作占位符，当程序真正运行起来时才会在内存中开辟.bss节的空间，并为其中的数据赋上初始值（0）</p>\n</li>\n</ol>\n<hr>\n<h4 id=\"symtab-Section\"><a href=\"#symtab-Section\" class=\"headerlink\" title=\".symtab Section\"></a>.symtab Section</h4><p>​    <strong>符号表</strong>（symbol table），用于存放可重定位目标文件中的 <strong>==定义==</strong> 与 <strong>==引用==</strong> 的全局符号信息，包括全局变量、函数.symtab</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -s main.o     <span class=\"comment\"># 查看符号表</span></span><br><span class=\"line\"></span><br><span class=\"line\">gcc -s main.o -o main      <span class=\"comment\"># 编译时剔除符号信息与重定位信息</span></span><br><span class=\"line\">strip main.o   <span class=\"comment\"># 丢弃目标文件中的符号</span></span><br></pre></td></tr></table></figure>\n\n<p>符号表包含很多条目，每个条目记录的就是一个符号的基本信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf32_Word    st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf32_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">&#125; Elf32_Sym;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf64_Word    st_name;                <span class=\"comment\">/* Symbol name (string tbl index) */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_info;                <span class=\"comment\">/* Symbol type and binding */</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span> st_other;               <span class=\"comment\">/* Symbol visibility */</span></span><br><span class=\"line\">  Elf64_Section st_shndx;               <span class=\"comment\">/* Section index */</span></span><br><span class=\"line\">  Elf64_Addr    st_value;               <span class=\"comment\">/* Symbol value */</span></span><br><span class=\"line\">  Elf64_Xword   st_size;                <span class=\"comment\">/* Symbol size */</span></span><br><span class=\"line\">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>\n\n<p>​    <strong>1）name</strong></p>\n<p>​                    name中记录的并不是名字的字符串，我们前面说过所有的字符串都是放在了.strtab中。name里面只记录字符            串在 <strong>.strtab</strong> 中的偏移，通过这个偏移就能在 <strong>.strtab</strong> 中索引到符号的名字。</p>\n<p>​            e.g.</p>\n<p>​                name = 5 //偏移5<br>​                假如.strtab中的内容为main\\0fun2\\0a_va\\0……<br>​                使用偏移5到.strtab中进行搜索，当遇到\\0时就截止，那么取出来的就是符号fun2。</p>\n<p>​    <strong>2）value</strong></p>\n<p>​            放的是地址：指向符号所代表的空间。不过对于.o（可重定位目标文件）和可执行目标文件来说，value的值有所不        同。</p>\n<ul>\n<li>  可重定位目标文件</li>\n</ul>\n<p>​                    value总中放的只是相对于节起始地址的偏移。</p>\n<ul>\n<li>  可执行目标文件</li>\n</ul>\n<p>​                    value中放的是绝对地址。“可重定位目标文件”被连接在一起后，value中放的是链接时重定位后的绝对地址。</p>\n<p>​    <strong>3）size</strong></p>\n<p>​            size代表的是value所指向空间的大小，毕竟value只是起始地址，不能说明空间的大小。</p>\n<p>​            比如：</p>\n<ul>\n<li><p>​    如果符号是初始化了的全局变量的话<br>  ​     size代表的全局变量在.data中所占字节数。</p>\n</li>\n<li><p>如果符号是函数的话</p>\n<pre><code>   size代表的是函数指令在.text中所占空间的大小\n</code></pre>\n</li>\n</ul>\n<p>​    <strong>4）type</strong></p>\n<p>​        符号类型，大致有如下几种类型。</p>\n<ul>\n<li>  FUNC：符号代表的是函数</li>\n<li>  OBJECT：符号代表的是全局变量</li>\n<li>  FILE：符号是源文件的名字</li>\n<li>  SECTION：该符号关联的实体是个节，用于重定位</li>\n<li>  COMMON：未初始化的全局变量，储存在.bss节</li>\n<li>  NOTYPE：未知或未指定类型</li>\n<li>  WEAK：弱符号，在链接时忽略弱符号的声明，采纳强符号的定义，可用来解决多文件符号冲突问题</li>\n</ul>\n<p>​    <strong>5）bind</strong></p>\n<p>​            就两种情况，LCOAL、GLOBAL</p>\n<ul>\n<li>  bind=LOCAL</li>\n</ul>\n<p>​                    表示符号是本地的：符号在模块中定义后，只能由本模块引用，static修饰的全局变量和函数就是这种情况。</p>\n<ul>\n<li>  bind=CLOBAL(全局符号)</li>\n</ul>\n<p>​                    表示符号在本模块定义，但是可以被其它模块引用（使用），extern修饰的全局变量和函数就是这种情况。</p>\n<p>​    <strong>6）section</strong></p>\n<p>​        section的值有四种情况，节索引号、ABS、UNDEF、COM</p>\n<ul>\n<li>  section=节索引号</li>\n</ul>\n<p>​                说明符号所对应的空间在哪个节里面。</p>\n<ul>\n<li>  section=ABS</li>\n</ul>\n<p>​                表示该符号不需要被“链接程序”处理。</p>\n<p>​                比如，如果符号名是***.c，这个符号不是全局变量、不是函数，只是一个源文件名而已，链接器（ld/collect2）            在链接“可重定位目标文件”时，这个符号不需要被处理。</p>\n<ul>\n<li>  section=UNDEF</li>\n</ul>\n<p>​                表示这个符号，只是在本模块中被引用了，这个符号并不是由本模块定义的，表示这个符号被定义在了其它模块            中，链接时要到其它模块中去找搜寻它的定义。</p>\n<ul>\n<li><p>section=COM</p>\n<p>  表示还未被分配空间（位置）的未初始化的数据目标，比如未初始化的全局变量(.bss)。</p>\n</li>\n</ul>\n<p>​    .symtab 所记录的符号，严格说起来就两种：</p>\n<ol>\n<li>全局符号（由extern修饰的全局变量或函数）<ul>\n<li>  在本地文件声明，在其他文件中被引用</li>\n<li>  在其他文件声明，在本地文件中被引用</li>\n</ul>\n</li>\n<li>本地符号（由static修饰的静态变量或函数）<ul>\n<li>  在本地文件声明，且只能在本模块中使用</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"rel-text-Section-及-rel-data-Section\"><a href=\"#rel-text-Section-及-rel-data-Section\" class=\"headerlink\" title=\".rel.text Section 及 .rel.data Section\"></a>.rel.text Section 及 .rel.data Section</h4><p>​    用于多个.o文件链接在一起时，需要根据这两个节中的重定位信息，将各个文件中的 .text节 与 data节分别整合 </p>\n<h4 id=\"debug-Section-及-line-Section\"><a href=\"#debug-Section-及-line-Section\" class=\"headerlink\" title=\".debug Section 及 .line Section\"></a>.debug Section 及 .line Section</h4><p>​    前者存放调试信息，后者存放代码行号信息，编译时需要加入 -g 选项后，才会在这两节中存放相关调试信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -g main.c -o main</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"strtab-Section\"><a href=\"#strtab-Section\" class=\"headerlink\" title=\".strtab Section\"></a>.strtab Section</h4><p>​    字符串表，挨个存放：</p>\n<ul>\n<li>  .symtab 所用的符号名字</li>\n<li>  .debug 所用到的符号名字</li>\n<li>  每个节的段名</li>\n<li>  源文件名字</li>\n<li>  等等</li>\n</ul>\n<h4 id=\"Section-Header-Table\"><a href=\"#Section-Header-Table\" class=\"headerlink\" title=\"Section Header Table\"></a>Section Header Table</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  Elf32_Word sh_name; <span class=\"comment\">/* Section name (string tbl index) */</span></span><br><span class=\"line\">  Elf32_Word sh_type; <span class=\"comment\">/* Section type */</span></span><br><span class=\"line\">  Elf32_Word sh_flags; <span class=\"comment\">/* Section flags */</span></span><br><span class=\"line\">  Elf32_Addr sh_addr; <span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf32_Off sh_offset; <span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf32_Word sh_size; <span class=\"comment\">/* Section size in bytes */</span></span><br><span class=\"line\">  Elf32_Word sh_link; <span class=\"comment\">/* Link to another section */</span></span><br><span class=\"line\">  Elf32_Word sh_info; <span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf32_Word sh_addralign; <span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf32_Word sh_entsize; <span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -S main.o</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>  节名称</p>\n</li>\n<li><p>  节的类型</p>\n</li>\n<li><p>  节的属性（读写权限）</p>\n</li>\n<li><p>  节在ELF文件中所占的长度</p>\n</li>\n<li><p>  节的对齐方式</p>\n</li>\n<li><p>  偏移量</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"ELF格式可执行目标文件\"><a href=\"#ELF格式可执行目标文件\" class=\"headerlink\" title=\"ELF格式可执行目标文件\"></a>ELF格式可执行目标文件</h3><p><img src=\"https://img-blog.csdnimg.cn/img_convert/494d134bb25941bf46aba57ba98b4f5c.png\" alt=\"ELF和sectionheadertable(节头表)\"></p>\n"}],"PostAsset":[{"_id":"source/_posts/DGA域名/C2DGA.png","post":"clggc2xjd0001ecwdeyag3lt5","slug":"C2DGA.png","modified":1,"renderable":1},{"_id":"source/_posts/DGA域名/markov.png","post":"clggc2xjd0001ecwdeyag3lt5","slug":"markov.png","modified":1,"renderable":1},{"_id":"source/_posts/DGA域名/orchard.png","post":"clggc2xjd0001ecwdeyag3lt5","slug":"orchard.png","modified":1,"renderable":1},{"_id":"source/_posts/Etcd-学习/architecture.png","post":"clggc2xjf0003ecwd26x95sa3","slug":"architecture.png","modified":1,"renderable":1},{"_id":"source/_posts/GFS-解读/arch.jpg","post":"clggc2xji0007ecwdas5463aw","slug":"arch.jpg","modified":1,"renderable":1},{"_id":"source/_posts/GFS-解读/cons.png","post":"clggc2xji0007ecwdas5463aw","slug":"cons.png","modified":1,"renderable":1},{"_id":"source/_posts/GFS-解读/react.jpg","post":"clggc2xji0007ecwdas5463aw","slug":"react.jpg","modified":1,"renderable":1},{"_id":"source/_posts/IPFS-Windows/zip.png","post":"clggc2xjm000eecwdc60e9gg1","slug":"zip.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err0.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err0.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err1.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err1.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err2.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err2.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err3.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err3.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err4.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err4.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err5.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err5.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/err6.png","post":"clggc2xjm000fecwdf3efblgb","slug":"err6.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/succ0.png","post":"clggc2xjm000fecwdf3efblgb","slug":"succ0.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/succ1.png","post":"clggc2xjm000fecwdf3efblgb","slug":"succ1.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use0.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use0.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use1.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use1.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use2.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use2.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use3.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use3.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use4.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use4.png","modified":1,"renderable":1},{"_id":"source/_posts/K8s(1)/use5.png","post":"clggc2xjm000fecwdf3efblgb","slug":"use5.png","modified":1,"renderable":1},{"_id":"source/_posts/Raft算法/fm.png","post":"clggc2xjn000jecwd1n1jeykk","slug":"fm.png","modified":1,"renderable":1},{"_id":"source/_posts/Raft算法/role.jpg","post":"clggc2xjn000jecwd1n1jeykk","slug":"role.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Raft算法/voting.png","post":"clggc2xjn000jecwd1n1jeykk","slug":"voting.png","modified":1,"renderable":1},{"_id":"source/_posts/Raft算法/votin_fail.png","post":"clggc2xjn000jecwd1n1jeykk","slug":"votin_fail.png","modified":1,"renderable":1},{"_id":"source/_posts/docker学习/2a9868ee4596ff49f1311f20178704f.png","post":"clggc2xjo000kecwdepqsfz2q","slug":"2a9868ee4596ff49f1311f20178704f.png","modified":1,"renderable":1},{"_id":"source/_posts/docker学习/c5f7d7d0c8d5f55c6c637a68a704e9d.png","post":"clggc2xjo000kecwdepqsfz2q","slug":"c5f7d7d0c8d5f55c6c637a68a704e9d.png","modified":1,"renderable":1},{"_id":"source/_posts/docker学习/dockerfile_cmd.png","post":"clggc2xjo000kecwdepqsfz2q","slug":"dockerfile_cmd.png","modified":1,"renderable":1},{"_id":"source/_posts/docker学习/ufs.png","post":"clggc2xjo000kecwdepqsfz2q","slug":"ufs.png","modified":1,"renderable":1},{"_id":"source/_posts/conda安装jupyter/1.png","post":"clggc2xjq000necwdd7ep8exa","slug":"1.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clggc2xjd0001ecwdeyag3lt5","category_id":"clggc2xjh0004ecwdertm8iaj","_id":"clggc2xjn000gecwd77jv95f0"},{"post_id":"clggc2xjn000jecwd1n1jeykk","category_id":"clggc2xjn000hecwd2qcf05j7","_id":"clggc2xjr000oecwdas8s7la5"},{"post_id":"clggc2xji0007ecwdas5463aw","category_id":"clggc2xjn000hecwd2qcf05j7","_id":"clggc2xjr000recwd80mr14ur"},{"post_id":"clggc2xjk000aecwd79dq7n92","category_id":"clggc2xjr000pecwd8gi66org","_id":"clggc2xjs000xecwddxlg0508"},{"post_id":"clggc2xjf0003ecwd26x95sa3","category_id":"clggc2xjl000becwdclnyhwrg","_id":"clggc2xju0014ecwdfq7f6h2w"},{"post_id":"clggc2xjf0003ecwd26x95sa3","category_id":"clggc2xjs000yecwde6p8hkbq","_id":"clggc2xju0018ecwd1cflfscz"},{"post_id":"clggc2xjo000kecwdepqsfz2q","category_id":"clggc2xjt0010ecwdfgh6c2cf","_id":"clggc2xjv001becwd7npu4c05"},{"post_id":"clggc2xjq000necwdd7ep8exa","category_id":"clggc2xju0019ecwd0rrae7vq","_id":"clggc2xjv001gecwda3iggd01"},{"post_id":"clggc2xjk0009ecwdg8784zqo","category_id":"clggc2xjl000becwdclnyhwrg","_id":"clggc2xjw001kecwdcezi0m38"},{"post_id":"clggc2xjk0009ecwdg8784zqo","category_id":"clggc2xjv001cecwd1an644er","_id":"clggc2xjw001necwd7pxy9zmn"},{"post_id":"clggc2xjm000eecwdc60e9gg1","category_id":"clggc2xjs000uecwd8el597sh","_id":"clggc2xjx001qecwd1fvgf7vz"},{"post_id":"clggc2xjm000eecwdc60e9gg1","category_id":"clggc2xjv001hecwdf9xkb4wj","_id":"clggc2xjx001secwdd1uq5mkh"},{"post_id":"clggc2xjm000fecwdf3efblgb","category_id":"clggc2xjt0010ecwdfgh6c2cf","_id":"clggc2xjx001tecwd8o312dqo"},{"post_id":"clggc2xjm000fecwdf3efblgb","category_id":"clggc2xjw001lecwd75y8fydh","_id":"clggc2xjx001vecwd0avw10xd"},{"post_id":"clggc2xk2002decwd7o0q9g77","category_id":"clggc2xk3002fecwd5b9efqkf","_id":"clggc2xk4002kecwdeiw2avtf"},{"post_id":"clggc2xk3002eecwd68kibljr","category_id":"clggc2xk4002hecwd6zev8hc6","_id":"clggc2xk4002mecwdb06cel7q"}],"PostTag":[{"post_id":"clggc2xjd0001ecwdeyag3lt5","tag_id":"clggc2xji0005ecwd8pyq1ol4","_id":"clggc2xjm000decwd671hfs7x"},{"post_id":"clggc2xjf0003ecwd26x95sa3","tag_id":"clggc2xjl000cecwd1unahgye","_id":"clggc2xjs000secwd4n3g7hyn"},{"post_id":"clggc2xjf0003ecwd26x95sa3","tag_id":"clggc2xjn000iecwd561rckb6","_id":"clggc2xjs000tecwde9rk1ur1"},{"post_id":"clggc2xjf0003ecwd26x95sa3","tag_id":"clggc2xjp000mecwdblze6m72","_id":"clggc2xjs000wecwdchjd6vru"},{"post_id":"clggc2xji0007ecwdas5463aw","tag_id":"clggc2xjn000iecwd561rckb6","_id":"clggc2xjt0012ecwdfcr003gr"},{"post_id":"clggc2xji0007ecwdas5463aw","tag_id":"clggc2xjs000vecwd69f17o6h","_id":"clggc2xju0013ecwddwmocyf7"},{"post_id":"clggc2xji0007ecwdas5463aw","tag_id":"clggc2xjt000zecwd0dzp2we4","_id":"clggc2xju0017ecwd0ad31xp5"},{"post_id":"clggc2xjk0009ecwdg8784zqo","tag_id":"clggc2xjl000cecwd1unahgye","_id":"clggc2xjv001eecwdai8233ef"},{"post_id":"clggc2xjk0009ecwdg8784zqo","tag_id":"clggc2xju0015ecwdc1ckdzpk","_id":"clggc2xjv001fecwd7k5q2gez"},{"post_id":"clggc2xjk0009ecwdg8784zqo","tag_id":"clggc2xjv001aecwdbv8h676j","_id":"clggc2xjw001jecwdgyva7dt2"},{"post_id":"clggc2xjk000aecwd79dq7n92","tag_id":"clggc2xjv001decwd5ck36kzt","_id":"clggc2xjw001oecwdazfcgqrz"},{"post_id":"clggc2xjk000aecwd79dq7n92","tag_id":"clggc2xjw001iecwd88je4tib","_id":"clggc2xjw001pecwd2g8zhkqn"},{"post_id":"clggc2xjm000eecwdc60e9gg1","tag_id":"clggc2xjw001mecwd7aok5p1q","_id":"clggc2xjx001xecwd1fceftak"},{"post_id":"clggc2xjm000eecwdc60e9gg1","tag_id":"clggc2xjx001recwd6tkt6aut","_id":"clggc2xjx001yecwd3f4gaaiv"},{"post_id":"clggc2xjm000eecwdc60e9gg1","tag_id":"clggc2xjx001uecwd8aphga4d","_id":"clggc2xjy0020ecwd0ffo7485"},{"post_id":"clggc2xjm000fecwdf3efblgb","tag_id":"clggc2xjx001wecwdbp8gdveo","_id":"clggc2xjy0022ecwdg09323uq"},{"post_id":"clggc2xjm000fecwdf3efblgb","tag_id":"clggc2xjx001zecwdfprzhkp9","_id":"clggc2xjy0023ecwd7vou946x"},{"post_id":"clggc2xjn000jecwd1n1jeykk","tag_id":"clggc2xjn000iecwd561rckb6","_id":"clggc2xjy0025ecwd2waw5n7g"},{"post_id":"clggc2xjn000jecwd1n1jeykk","tag_id":"clggc2xjy0021ecwd5upi7gbv","_id":"clggc2xjy0026ecwde4j15tum"},{"post_id":"clggc2xjo000kecwdepqsfz2q","tag_id":"clggc2xjx001wecwdbp8gdveo","_id":"clggc2xjz0029ecwd9wcm2s7k"},{"post_id":"clggc2xjo000kecwdepqsfz2q","tag_id":"clggc2xjx001zecwdfprzhkp9","_id":"clggc2xjz002aecwd9oo8595d"},{"post_id":"clggc2xjq000necwdd7ep8exa","tag_id":"clggc2xjy0028ecwd23mh1nyw","_id":"clggc2xjz002becwdhopl8dob"},{"post_id":"clggc2xk2002decwd7o0q9g77","tag_id":"clggc2xk4002gecwd6wqkd4vq","_id":"clggc2xk4002jecwdfjbrhjec"},{"post_id":"clggc2xk3002eecwd68kibljr","tag_id":"clggc2xk4002iecwdfxns08g4","_id":"clggc2xk4002lecwddx9tdlm2"}],"Tag":[{"name":"DGA","_id":"clggc2xji0005ecwd8pyq1ol4"},{"name":"微服务","_id":"clggc2xjl000cecwd1unahgye"},{"name":"分布式","_id":"clggc2xjn000iecwd561rckb6"},{"name":"Raft","_id":"clggc2xjp000mecwdblze6m72"},{"name":"文件系统","_id":"clggc2xjs000vecwd69f17o6h"},{"name":"存储","_id":"clggc2xjt000zecwd0dzp2we4"},{"name":"web","_id":"clggc2xju0015ecwdc1ckdzpk"},{"name":"RPC","_id":"clggc2xjv001aecwdbv8h676j"},{"name":"OpenGL","_id":"clggc2xjv001decwd5ck36kzt"},{"name":"图形学","_id":"clggc2xjw001iecwd88je4tib"},{"name":"Decentralization","_id":"clggc2xjw001mecwd7aok5p1q"},{"name":"区块链","_id":"clggc2xjx001recwd6tkt6aut"},{"name":"P2P","_id":"clggc2xjx001uecwd8aphga4d"},{"name":"docker","_id":"clggc2xjx001wecwdbp8gdveo"},{"name":"容器","_id":"clggc2xjx001zecwdfprzhkp9"},{"name":"共识算法(consensus)","_id":"clggc2xjy0021ecwd5upi7gbv"},{"name":"jupyter notebook","_id":"clggc2xjy0028ecwd23mh1nyw"},{"name":"life","_id":"clggc2xk4002gecwd6wqkd4vq"},{"name":"汇编语言","_id":"clggc2xk4002iecwdfxns08g4"}]}}